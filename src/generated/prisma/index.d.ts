
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model DreamEntry
 * 
 */
export type DreamEntry = $Result.DefaultSelection<Prisma.$DreamEntryPayload>
/**
 * Model JournalFact
 * 
 */
export type JournalFact = $Result.DefaultSelection<Prisma.$JournalFactPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model DreamTag
 * 
 */
export type DreamTag = $Result.DefaultSelection<Prisma.$DreamTagPayload>
/**
 * Model CensusInstrument
 * 
 */
export type CensusInstrument = $Result.DefaultSelection<Prisma.$CensusInstrumentPayload>
/**
 * Model CensusSection
 * 
 */
export type CensusSection = $Result.DefaultSelection<Prisma.$CensusSectionPayload>
/**
 * Model CensusQuestion
 * 
 */
export type CensusQuestion = $Result.DefaultSelection<Prisma.$CensusQuestionPayload>
/**
 * Model CensusAnswer
 * 
 */
export type CensusAnswer = $Result.DefaultSelection<Prisma.$CensusAnswerPayload>
/**
 * Model CensusProgress
 * 
 */
export type CensusProgress = $Result.DefaultSelection<Prisma.$CensusProgressPayload>
/**
 * Model Prompt
 * 
 */
export type Prompt = $Result.DefaultSelection<Prisma.$PromptPayload>
/**
 * Model PromptResponse
 * 
 */
export type PromptResponse = $Result.DefaultSelection<Prisma.$PromptResponsePayload>
/**
 * Model Consent
 * 
 */
export type Consent = $Result.DefaultSelection<Prisma.$ConsentPayload>
/**
 * Model WeatherAggregate
 * 
 */
export type WeatherAggregate = $Result.DefaultSelection<Prisma.$WeatherAggregatePayload>
/**
 * Model PersonalWeather
 * 
 */
export type PersonalWeather = $Result.DefaultSelection<Prisma.$PersonalWeatherPayload>
/**
 * Model Study
 * 
 */
export type Study = $Result.DefaultSelection<Prisma.$StudyPayload>
/**
 * Model StudyParticipation
 * 
 */
export type StudyParticipation = $Result.DefaultSelection<Prisma.$StudyParticipationPayload>
/**
 * Model Emotion
 * 
 */
export type Emotion = $Result.DefaultSelection<Prisma.$EmotionPayload>
/**
 * Model Symbol
 * 
 */
export type Symbol = $Result.DefaultSelection<Prisma.$SymbolPayload>
/**
 * Model Theme
 * 
 */
export type Theme = $Result.DefaultSelection<Prisma.$ThemePayload>
/**
 * Model NightCheckIn
 * 
 */
export type NightCheckIn = $Result.DefaultSelection<Prisma.$NightCheckInPayload>
/**
 * Model SyncQueueItem
 * 
 */
export type SyncQueueItem = $Result.DefaultSelection<Prisma.$SyncQueueItemPayload>
/**
 * Model AlarmSettings
 * 
 */
export type AlarmSettings = $Result.DefaultSelection<Prisma.$AlarmSettingsPayload>
/**
 * Model DreamerProfile
 * 
 */
export type DreamerProfile = $Result.DefaultSelection<Prisma.$DreamerProfilePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dreamEntry`: Exposes CRUD operations for the **DreamEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DreamEntries
    * const dreamEntries = await prisma.dreamEntry.findMany()
    * ```
    */
  get dreamEntry(): Prisma.DreamEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalFact`: Exposes CRUD operations for the **JournalFact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalFacts
    * const journalFacts = await prisma.journalFact.findMany()
    * ```
    */
  get journalFact(): Prisma.JournalFactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dreamTag`: Exposes CRUD operations for the **DreamTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DreamTags
    * const dreamTags = await prisma.dreamTag.findMany()
    * ```
    */
  get dreamTag(): Prisma.DreamTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusInstrument`: Exposes CRUD operations for the **CensusInstrument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusInstruments
    * const censusInstruments = await prisma.censusInstrument.findMany()
    * ```
    */
  get censusInstrument(): Prisma.CensusInstrumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusSection`: Exposes CRUD operations for the **CensusSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusSections
    * const censusSections = await prisma.censusSection.findMany()
    * ```
    */
  get censusSection(): Prisma.CensusSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusQuestion`: Exposes CRUD operations for the **CensusQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusQuestions
    * const censusQuestions = await prisma.censusQuestion.findMany()
    * ```
    */
  get censusQuestion(): Prisma.CensusQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusAnswer`: Exposes CRUD operations for the **CensusAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusAnswers
    * const censusAnswers = await prisma.censusAnswer.findMany()
    * ```
    */
  get censusAnswer(): Prisma.CensusAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusProgress`: Exposes CRUD operations for the **CensusProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusProgresses
    * const censusProgresses = await prisma.censusProgress.findMany()
    * ```
    */
  get censusProgress(): Prisma.CensusProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prompt`: Exposes CRUD operations for the **Prompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompts
    * const prompts = await prisma.prompt.findMany()
    * ```
    */
  get prompt(): Prisma.PromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promptResponse`: Exposes CRUD operations for the **PromptResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptResponses
    * const promptResponses = await prisma.promptResponse.findMany()
    * ```
    */
  get promptResponse(): Prisma.PromptResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consent`: Exposes CRUD operations for the **Consent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consents
    * const consents = await prisma.consent.findMany()
    * ```
    */
  get consent(): Prisma.ConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weatherAggregate`: Exposes CRUD operations for the **WeatherAggregate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherAggregates
    * const weatherAggregates = await prisma.weatherAggregate.findMany()
    * ```
    */
  get weatherAggregate(): Prisma.WeatherAggregateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalWeather`: Exposes CRUD operations for the **PersonalWeather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalWeathers
    * const personalWeathers = await prisma.personalWeather.findMany()
    * ```
    */
  get personalWeather(): Prisma.PersonalWeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study`: Exposes CRUD operations for the **Study** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Studies
    * const studies = await prisma.study.findMany()
    * ```
    */
  get study(): Prisma.StudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyParticipation`: Exposes CRUD operations for the **StudyParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyParticipations
    * const studyParticipations = await prisma.studyParticipation.findMany()
    * ```
    */
  get studyParticipation(): Prisma.StudyParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emotion`: Exposes CRUD operations for the **Emotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emotions
    * const emotions = await prisma.emotion.findMany()
    * ```
    */
  get emotion(): Prisma.EmotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbol`: Exposes CRUD operations for the **Symbol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symbols
    * const symbols = await prisma.symbol.findMany()
    * ```
    */
  get symbol(): Prisma.SymbolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.theme`: Exposes CRUD operations for the **Theme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themes
    * const themes = await prisma.theme.findMany()
    * ```
    */
  get theme(): Prisma.ThemeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nightCheckIn`: Exposes CRUD operations for the **NightCheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NightCheckIns
    * const nightCheckIns = await prisma.nightCheckIn.findMany()
    * ```
    */
  get nightCheckIn(): Prisma.NightCheckInDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncQueueItem`: Exposes CRUD operations for the **SyncQueueItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncQueueItems
    * const syncQueueItems = await prisma.syncQueueItem.findMany()
    * ```
    */
  get syncQueueItem(): Prisma.SyncQueueItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alarmSettings`: Exposes CRUD operations for the **AlarmSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlarmSettings
    * const alarmSettings = await prisma.alarmSettings.findMany()
    * ```
    */
  get alarmSettings(): Prisma.AlarmSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dreamerProfile`: Exposes CRUD operations for the **DreamerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DreamerProfiles
    * const dreamerProfiles = await prisma.dreamerProfile.findMany()
    * ```
    */
  get dreamerProfile(): Prisma.DreamerProfileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Event: 'Event',
    DreamEntry: 'DreamEntry',
    JournalFact: 'JournalFact',
    Tag: 'Tag',
    DreamTag: 'DreamTag',
    CensusInstrument: 'CensusInstrument',
    CensusSection: 'CensusSection',
    CensusQuestion: 'CensusQuestion',
    CensusAnswer: 'CensusAnswer',
    CensusProgress: 'CensusProgress',
    Prompt: 'Prompt',
    PromptResponse: 'PromptResponse',
    Consent: 'Consent',
    WeatherAggregate: 'WeatherAggregate',
    PersonalWeather: 'PersonalWeather',
    Study: 'Study',
    StudyParticipation: 'StudyParticipation',
    Emotion: 'Emotion',
    Symbol: 'Symbol',
    Theme: 'Theme',
    NightCheckIn: 'NightCheckIn',
    SyncQueueItem: 'SyncQueueItem',
    AlarmSettings: 'AlarmSettings',
    DreamerProfile: 'DreamerProfile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "verificationToken" | "event" | "dreamEntry" | "journalFact" | "tag" | "dreamTag" | "censusInstrument" | "censusSection" | "censusQuestion" | "censusAnswer" | "censusProgress" | "prompt" | "promptResponse" | "consent" | "weatherAggregate" | "personalWeather" | "study" | "studyParticipation" | "emotion" | "symbol" | "theme" | "nightCheckIn" | "syncQueueItem" | "alarmSettings" | "dreamerProfile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      DreamEntry: {
        payload: Prisma.$DreamEntryPayload<ExtArgs>
        fields: Prisma.DreamEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DreamEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DreamEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          findFirst: {
            args: Prisma.DreamEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DreamEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          findMany: {
            args: Prisma.DreamEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>[]
          }
          create: {
            args: Prisma.DreamEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          createMany: {
            args: Prisma.DreamEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DreamEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>[]
          }
          delete: {
            args: Prisma.DreamEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          update: {
            args: Prisma.DreamEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          deleteMany: {
            args: Prisma.DreamEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DreamEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DreamEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>[]
          }
          upsert: {
            args: Prisma.DreamEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamEntryPayload>
          }
          aggregate: {
            args: Prisma.DreamEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDreamEntry>
          }
          groupBy: {
            args: Prisma.DreamEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DreamEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DreamEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DreamEntryCountAggregateOutputType> | number
          }
        }
      }
      JournalFact: {
        payload: Prisma.$JournalFactPayload<ExtArgs>
        fields: Prisma.JournalFactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          findFirst: {
            args: Prisma.JournalFactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          findMany: {
            args: Prisma.JournalFactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>[]
          }
          create: {
            args: Prisma.JournalFactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          createMany: {
            args: Prisma.JournalFactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalFactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>[]
          }
          delete: {
            args: Prisma.JournalFactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          update: {
            args: Prisma.JournalFactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          deleteMany: {
            args: Prisma.JournalFactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalFactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalFactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>[]
          }
          upsert: {
            args: Prisma.JournalFactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFactPayload>
          }
          aggregate: {
            args: Prisma.JournalFactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalFact>
          }
          groupBy: {
            args: Prisma.JournalFactGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalFactGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalFactCountArgs<ExtArgs>
            result: $Utils.Optional<JournalFactCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      DreamTag: {
        payload: Prisma.$DreamTagPayload<ExtArgs>
        fields: Prisma.DreamTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DreamTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DreamTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          findFirst: {
            args: Prisma.DreamTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DreamTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          findMany: {
            args: Prisma.DreamTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>[]
          }
          create: {
            args: Prisma.DreamTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          createMany: {
            args: Prisma.DreamTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DreamTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>[]
          }
          delete: {
            args: Prisma.DreamTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          update: {
            args: Prisma.DreamTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          deleteMany: {
            args: Prisma.DreamTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DreamTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DreamTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>[]
          }
          upsert: {
            args: Prisma.DreamTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamTagPayload>
          }
          aggregate: {
            args: Prisma.DreamTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDreamTag>
          }
          groupBy: {
            args: Prisma.DreamTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DreamTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DreamTagCountArgs<ExtArgs>
            result: $Utils.Optional<DreamTagCountAggregateOutputType> | number
          }
        }
      }
      CensusInstrument: {
        payload: Prisma.$CensusInstrumentPayload<ExtArgs>
        fields: Prisma.CensusInstrumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusInstrumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusInstrumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          findFirst: {
            args: Prisma.CensusInstrumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusInstrumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          findMany: {
            args: Prisma.CensusInstrumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>[]
          }
          create: {
            args: Prisma.CensusInstrumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          createMany: {
            args: Prisma.CensusInstrumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusInstrumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>[]
          }
          delete: {
            args: Prisma.CensusInstrumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          update: {
            args: Prisma.CensusInstrumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          deleteMany: {
            args: Prisma.CensusInstrumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusInstrumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusInstrumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>[]
          }
          upsert: {
            args: Prisma.CensusInstrumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusInstrumentPayload>
          }
          aggregate: {
            args: Prisma.CensusInstrumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusInstrument>
          }
          groupBy: {
            args: Prisma.CensusInstrumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusInstrumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusInstrumentCountArgs<ExtArgs>
            result: $Utils.Optional<CensusInstrumentCountAggregateOutputType> | number
          }
        }
      }
      CensusSection: {
        payload: Prisma.$CensusSectionPayload<ExtArgs>
        fields: Prisma.CensusSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          findFirst: {
            args: Prisma.CensusSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          findMany: {
            args: Prisma.CensusSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>[]
          }
          create: {
            args: Prisma.CensusSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          createMany: {
            args: Prisma.CensusSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>[]
          }
          delete: {
            args: Prisma.CensusSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          update: {
            args: Prisma.CensusSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          deleteMany: {
            args: Prisma.CensusSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>[]
          }
          upsert: {
            args: Prisma.CensusSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusSectionPayload>
          }
          aggregate: {
            args: Prisma.CensusSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusSection>
          }
          groupBy: {
            args: Prisma.CensusSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusSectionCountArgs<ExtArgs>
            result: $Utils.Optional<CensusSectionCountAggregateOutputType> | number
          }
        }
      }
      CensusQuestion: {
        payload: Prisma.$CensusQuestionPayload<ExtArgs>
        fields: Prisma.CensusQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          findFirst: {
            args: Prisma.CensusQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          findMany: {
            args: Prisma.CensusQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>[]
          }
          create: {
            args: Prisma.CensusQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          createMany: {
            args: Prisma.CensusQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>[]
          }
          delete: {
            args: Prisma.CensusQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          update: {
            args: Prisma.CensusQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          deleteMany: {
            args: Prisma.CensusQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>[]
          }
          upsert: {
            args: Prisma.CensusQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusQuestionPayload>
          }
          aggregate: {
            args: Prisma.CensusQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusQuestion>
          }
          groupBy: {
            args: Prisma.CensusQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<CensusQuestionCountAggregateOutputType> | number
          }
        }
      }
      CensusAnswer: {
        payload: Prisma.$CensusAnswerPayload<ExtArgs>
        fields: Prisma.CensusAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          findFirst: {
            args: Prisma.CensusAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          findMany: {
            args: Prisma.CensusAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>[]
          }
          create: {
            args: Prisma.CensusAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          createMany: {
            args: Prisma.CensusAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>[]
          }
          delete: {
            args: Prisma.CensusAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          update: {
            args: Prisma.CensusAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          deleteMany: {
            args: Prisma.CensusAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>[]
          }
          upsert: {
            args: Prisma.CensusAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusAnswerPayload>
          }
          aggregate: {
            args: Prisma.CensusAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusAnswer>
          }
          groupBy: {
            args: Prisma.CensusAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<CensusAnswerCountAggregateOutputType> | number
          }
        }
      }
      CensusProgress: {
        payload: Prisma.$CensusProgressPayload<ExtArgs>
        fields: Prisma.CensusProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          findFirst: {
            args: Prisma.CensusProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          findMany: {
            args: Prisma.CensusProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>[]
          }
          create: {
            args: Prisma.CensusProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          createMany: {
            args: Prisma.CensusProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>[]
          }
          delete: {
            args: Prisma.CensusProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          update: {
            args: Prisma.CensusProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          deleteMany: {
            args: Prisma.CensusProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>[]
          }
          upsert: {
            args: Prisma.CensusProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusProgressPayload>
          }
          aggregate: {
            args: Prisma.CensusProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusProgress>
          }
          groupBy: {
            args: Prisma.CensusProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusProgressCountArgs<ExtArgs>
            result: $Utils.Optional<CensusProgressCountAggregateOutputType> | number
          }
        }
      }
      Prompt: {
        payload: Prisma.$PromptPayload<ExtArgs>
        fields: Prisma.PromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findFirst: {
            args: Prisma.PromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findMany: {
            args: Prisma.PromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          create: {
            args: Prisma.PromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          createMany: {
            args: Prisma.PromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          delete: {
            args: Prisma.PromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          update: {
            args: Prisma.PromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          deleteMany: {
            args: Prisma.PromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          upsert: {
            args: Prisma.PromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          aggregate: {
            args: Prisma.PromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt>
          }
          groupBy: {
            args: Prisma.PromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCountArgs<ExtArgs>
            result: $Utils.Optional<PromptCountAggregateOutputType> | number
          }
        }
      }
      PromptResponse: {
        payload: Prisma.$PromptResponsePayload<ExtArgs>
        fields: Prisma.PromptResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          findFirst: {
            args: Prisma.PromptResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          findMany: {
            args: Prisma.PromptResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>[]
          }
          create: {
            args: Prisma.PromptResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          createMany: {
            args: Prisma.PromptResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>[]
          }
          delete: {
            args: Prisma.PromptResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          update: {
            args: Prisma.PromptResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          deleteMany: {
            args: Prisma.PromptResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromptResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>[]
          }
          upsert: {
            args: Prisma.PromptResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptResponsePayload>
          }
          aggregate: {
            args: Prisma.PromptResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromptResponse>
          }
          groupBy: {
            args: Prisma.PromptResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptResponseCountArgs<ExtArgs>
            result: $Utils.Optional<PromptResponseCountAggregateOutputType> | number
          }
        }
      }
      Consent: {
        payload: Prisma.$ConsentPayload<ExtArgs>
        fields: Prisma.ConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          findFirst: {
            args: Prisma.ConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          findMany: {
            args: Prisma.ConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          create: {
            args: Prisma.ConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          createMany: {
            args: Prisma.ConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          delete: {
            args: Prisma.ConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          update: {
            args: Prisma.ConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          deleteMany: {
            args: Prisma.ConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>[]
          }
          upsert: {
            args: Prisma.ConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentPayload>
          }
          aggregate: {
            args: Prisma.ConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsent>
          }
          groupBy: {
            args: Prisma.ConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentCountAggregateOutputType> | number
          }
        }
      }
      WeatherAggregate: {
        payload: Prisma.$WeatherAggregatePayload<ExtArgs>
        fields: Prisma.WeatherAggregateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherAggregateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherAggregateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          findFirst: {
            args: Prisma.WeatherAggregateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherAggregateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          findMany: {
            args: Prisma.WeatherAggregateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>[]
          }
          create: {
            args: Prisma.WeatherAggregateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          createMany: {
            args: Prisma.WeatherAggregateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherAggregateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>[]
          }
          delete: {
            args: Prisma.WeatherAggregateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          update: {
            args: Prisma.WeatherAggregateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          deleteMany: {
            args: Prisma.WeatherAggregateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherAggregateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherAggregateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>[]
          }
          upsert: {
            args: Prisma.WeatherAggregateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherAggregatePayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherAggregate>
          }
          groupBy: {
            args: Prisma.WeatherAggregateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherAggregateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherAggregateCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherAggregateCountAggregateOutputType> | number
          }
        }
      }
      PersonalWeather: {
        payload: Prisma.$PersonalWeatherPayload<ExtArgs>
        fields: Prisma.PersonalWeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalWeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalWeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          findFirst: {
            args: Prisma.PersonalWeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalWeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          findMany: {
            args: Prisma.PersonalWeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>[]
          }
          create: {
            args: Prisma.PersonalWeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          createMany: {
            args: Prisma.PersonalWeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalWeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>[]
          }
          delete: {
            args: Prisma.PersonalWeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          update: {
            args: Prisma.PersonalWeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          deleteMany: {
            args: Prisma.PersonalWeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalWeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalWeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>[]
          }
          upsert: {
            args: Prisma.PersonalWeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalWeatherPayload>
          }
          aggregate: {
            args: Prisma.PersonalWeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalWeather>
          }
          groupBy: {
            args: Prisma.PersonalWeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalWeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalWeatherCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalWeatherCountAggregateOutputType> | number
          }
        }
      }
      Study: {
        payload: Prisma.$StudyPayload<ExtArgs>
        fields: Prisma.StudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          findFirst: {
            args: Prisma.StudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          findMany: {
            args: Prisma.StudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          create: {
            args: Prisma.StudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          createMany: {
            args: Prisma.StudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          delete: {
            args: Prisma.StudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          update: {
            args: Prisma.StudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          deleteMany: {
            args: Prisma.StudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          upsert: {
            args: Prisma.StudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          aggregate: {
            args: Prisma.StudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy>
          }
          groupBy: {
            args: Prisma.StudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyCountArgs<ExtArgs>
            result: $Utils.Optional<StudyCountAggregateOutputType> | number
          }
        }
      }
      StudyParticipation: {
        payload: Prisma.$StudyParticipationPayload<ExtArgs>
        fields: Prisma.StudyParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          findFirst: {
            args: Prisma.StudyParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          findMany: {
            args: Prisma.StudyParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>[]
          }
          create: {
            args: Prisma.StudyParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          createMany: {
            args: Prisma.StudyParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>[]
          }
          delete: {
            args: Prisma.StudyParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          update: {
            args: Prisma.StudyParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          deleteMany: {
            args: Prisma.StudyParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>[]
          }
          upsert: {
            args: Prisma.StudyParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyParticipationPayload>
          }
          aggregate: {
            args: Prisma.StudyParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyParticipation>
          }
          groupBy: {
            args: Prisma.StudyParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<StudyParticipationCountAggregateOutputType> | number
          }
        }
      }
      Emotion: {
        payload: Prisma.$EmotionPayload<ExtArgs>
        fields: Prisma.EmotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          findFirst: {
            args: Prisma.EmotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          findMany: {
            args: Prisma.EmotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>[]
          }
          create: {
            args: Prisma.EmotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          createMany: {
            args: Prisma.EmotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>[]
          }
          delete: {
            args: Prisma.EmotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          update: {
            args: Prisma.EmotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          deleteMany: {
            args: Prisma.EmotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>[]
          }
          upsert: {
            args: Prisma.EmotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmotionPayload>
          }
          aggregate: {
            args: Prisma.EmotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmotion>
          }
          groupBy: {
            args: Prisma.EmotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmotionCountArgs<ExtArgs>
            result: $Utils.Optional<EmotionCountAggregateOutputType> | number
          }
        }
      }
      Symbol: {
        payload: Prisma.$SymbolPayload<ExtArgs>
        fields: Prisma.SymbolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymbolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymbolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          findFirst: {
            args: Prisma.SymbolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymbolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          findMany: {
            args: Prisma.SymbolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>[]
          }
          create: {
            args: Prisma.SymbolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          createMany: {
            args: Prisma.SymbolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymbolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>[]
          }
          delete: {
            args: Prisma.SymbolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          update: {
            args: Prisma.SymbolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          deleteMany: {
            args: Prisma.SymbolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymbolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SymbolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>[]
          }
          upsert: {
            args: Prisma.SymbolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolPayload>
          }
          aggregate: {
            args: Prisma.SymbolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbol>
          }
          groupBy: {
            args: Prisma.SymbolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymbolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymbolCountArgs<ExtArgs>
            result: $Utils.Optional<SymbolCountAggregateOutputType> | number
          }
        }
      }
      Theme: {
        payload: Prisma.$ThemePayload<ExtArgs>
        fields: Prisma.ThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findFirst: {
            args: Prisma.ThemeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findMany: {
            args: Prisma.ThemeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          create: {
            args: Prisma.ThemeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          createMany: {
            args: Prisma.ThemeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          delete: {
            args: Prisma.ThemeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          update: {
            args: Prisma.ThemeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          deleteMany: {
            args: Prisma.ThemeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          upsert: {
            args: Prisma.ThemeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          aggregate: {
            args: Prisma.ThemeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTheme>
          }
          groupBy: {
            args: Prisma.ThemeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeCountAggregateOutputType> | number
          }
        }
      }
      NightCheckIn: {
        payload: Prisma.$NightCheckInPayload<ExtArgs>
        fields: Prisma.NightCheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NightCheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NightCheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          findFirst: {
            args: Prisma.NightCheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NightCheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          findMany: {
            args: Prisma.NightCheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>[]
          }
          create: {
            args: Prisma.NightCheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          createMany: {
            args: Prisma.NightCheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NightCheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>[]
          }
          delete: {
            args: Prisma.NightCheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          update: {
            args: Prisma.NightCheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          deleteMany: {
            args: Prisma.NightCheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NightCheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NightCheckInUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>[]
          }
          upsert: {
            args: Prisma.NightCheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightCheckInPayload>
          }
          aggregate: {
            args: Prisma.NightCheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNightCheckIn>
          }
          groupBy: {
            args: Prisma.NightCheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<NightCheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.NightCheckInCountArgs<ExtArgs>
            result: $Utils.Optional<NightCheckInCountAggregateOutputType> | number
          }
        }
      }
      SyncQueueItem: {
        payload: Prisma.$SyncQueueItemPayload<ExtArgs>
        fields: Prisma.SyncQueueItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncQueueItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncQueueItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          findFirst: {
            args: Prisma.SyncQueueItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncQueueItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          findMany: {
            args: Prisma.SyncQueueItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>[]
          }
          create: {
            args: Prisma.SyncQueueItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          createMany: {
            args: Prisma.SyncQueueItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncQueueItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>[]
          }
          delete: {
            args: Prisma.SyncQueueItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          update: {
            args: Prisma.SyncQueueItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          deleteMany: {
            args: Prisma.SyncQueueItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncQueueItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncQueueItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>[]
          }
          upsert: {
            args: Prisma.SyncQueueItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueueItemPayload>
          }
          aggregate: {
            args: Prisma.SyncQueueItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncQueueItem>
          }
          groupBy: {
            args: Prisma.SyncQueueItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncQueueItemCountArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueItemCountAggregateOutputType> | number
          }
        }
      }
      AlarmSettings: {
        payload: Prisma.$AlarmSettingsPayload<ExtArgs>
        fields: Prisma.AlarmSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlarmSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlarmSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          findFirst: {
            args: Prisma.AlarmSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlarmSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          findMany: {
            args: Prisma.AlarmSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>[]
          }
          create: {
            args: Prisma.AlarmSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          createMany: {
            args: Prisma.AlarmSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlarmSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>[]
          }
          delete: {
            args: Prisma.AlarmSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          update: {
            args: Prisma.AlarmSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          deleteMany: {
            args: Prisma.AlarmSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlarmSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlarmSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>[]
          }
          upsert: {
            args: Prisma.AlarmSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmSettingsPayload>
          }
          aggregate: {
            args: Prisma.AlarmSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlarmSettings>
          }
          groupBy: {
            args: Prisma.AlarmSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlarmSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlarmSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<AlarmSettingsCountAggregateOutputType> | number
          }
        }
      }
      DreamerProfile: {
        payload: Prisma.$DreamerProfilePayload<ExtArgs>
        fields: Prisma.DreamerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DreamerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DreamerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          findFirst: {
            args: Prisma.DreamerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DreamerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          findMany: {
            args: Prisma.DreamerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>[]
          }
          create: {
            args: Prisma.DreamerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          createMany: {
            args: Prisma.DreamerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DreamerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>[]
          }
          delete: {
            args: Prisma.DreamerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          update: {
            args: Prisma.DreamerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          deleteMany: {
            args: Prisma.DreamerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DreamerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DreamerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>[]
          }
          upsert: {
            args: Prisma.DreamerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DreamerProfilePayload>
          }
          aggregate: {
            args: Prisma.DreamerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDreamerProfile>
          }
          groupBy: {
            args: Prisma.DreamerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<DreamerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.DreamerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<DreamerProfileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    event?: EventOmit
    dreamEntry?: DreamEntryOmit
    journalFact?: JournalFactOmit
    tag?: TagOmit
    dreamTag?: DreamTagOmit
    censusInstrument?: CensusInstrumentOmit
    censusSection?: CensusSectionOmit
    censusQuestion?: CensusQuestionOmit
    censusAnswer?: CensusAnswerOmit
    censusProgress?: CensusProgressOmit
    prompt?: PromptOmit
    promptResponse?: PromptResponseOmit
    consent?: ConsentOmit
    weatherAggregate?: WeatherAggregateOmit
    personalWeather?: PersonalWeatherOmit
    study?: StudyOmit
    studyParticipation?: StudyParticipationOmit
    emotion?: EmotionOmit
    symbol?: SymbolOmit
    theme?: ThemeOmit
    nightCheckIn?: NightCheckInOmit
    syncQueueItem?: SyncQueueItemOmit
    alarmSettings?: AlarmSettingsOmit
    dreamerProfile?: DreamerProfileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    censusAnswers: number
    consents: number
    dreamEntries: number
    events: number
    nightCheckIns: number
    promptResponses: number
    sessions: number
    studyParticipations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    censusAnswers?: boolean | UserCountOutputTypeCountCensusAnswersArgs
    consents?: boolean | UserCountOutputTypeCountConsentsArgs
    dreamEntries?: boolean | UserCountOutputTypeCountDreamEntriesArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
    nightCheckIns?: boolean | UserCountOutputTypeCountNightCheckInsArgs
    promptResponses?: boolean | UserCountOutputTypeCountPromptResponsesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    studyParticipations?: boolean | UserCountOutputTypeCountStudyParticipationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCensusAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusAnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDreamEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNightCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NightCheckInWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPromptResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyParticipationWhereInput
  }


  /**
   * Count Type DreamEntryCountOutputType
   */

  export type DreamEntryCountOutputType = {
    tags: number
    facts: number
  }

  export type DreamEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | DreamEntryCountOutputTypeCountTagsArgs
    facts?: boolean | DreamEntryCountOutputTypeCountFactsArgs
  }

  // Custom InputTypes
  /**
   * DreamEntryCountOutputType without action
   */
  export type DreamEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntryCountOutputType
     */
    select?: DreamEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DreamEntryCountOutputType without action
   */
  export type DreamEntryCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamTagWhereInput
  }

  /**
   * DreamEntryCountOutputType without action
   */
  export type DreamEntryCountOutputTypeCountFactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFactWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    dreamTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamTags?: boolean | TagCountOutputTypeCountDreamTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountDreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamTagWhereInput
  }


  /**
   * Count Type CensusInstrumentCountOutputType
   */

  export type CensusInstrumentCountOutputType = {
    sections: number
  }

  export type CensusInstrumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | CensusInstrumentCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * CensusInstrumentCountOutputType without action
   */
  export type CensusInstrumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrumentCountOutputType
     */
    select?: CensusInstrumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CensusInstrumentCountOutputType without action
   */
  export type CensusInstrumentCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusSectionWhereInput
  }


  /**
   * Count Type CensusSectionCountOutputType
   */

  export type CensusSectionCountOutputType = {
    questions: number
  }

  export type CensusSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CensusSectionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * CensusSectionCountOutputType without action
   */
  export type CensusSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSectionCountOutputType
     */
    select?: CensusSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CensusSectionCountOutputType without action
   */
  export type CensusSectionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusQuestionWhereInput
  }


  /**
   * Count Type CensusQuestionCountOutputType
   */

  export type CensusQuestionCountOutputType = {
    answers: number
  }

  export type CensusQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | CensusQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * CensusQuestionCountOutputType without action
   */
  export type CensusQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestionCountOutputType
     */
    select?: CensusQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CensusQuestionCountOutputType without action
   */
  export type CensusQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusAnswerWhereInput
  }


  /**
   * Count Type PromptCountOutputType
   */

  export type PromptCountOutputType = {
    responses: number
  }

  export type PromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | PromptCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCountOutputType
     */
    select?: PromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptResponseWhereInput
  }


  /**
   * Count Type StudyCountOutputType
   */

  export type StudyCountOutputType = {
    prompts: number
    participations: number
  }

  export type StudyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompts?: boolean | StudyCountOutputTypeCountPromptsArgs
    participations?: boolean | StudyCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyCountOutputType
     */
    select?: StudyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyParticipationWhereInput
  }


  /**
   * Count Type EmotionCountOutputType
   */

  export type EmotionCountOutputType = {
    children: number
  }

  export type EmotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | EmotionCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * EmotionCountOutputType without action
   */
  export type EmotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmotionCountOutputType
     */
    select?: EmotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmotionCountOutputType without action
   */
  export type EmotionCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmotionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    encryptionKeyVersion: number | null
  }

  export type UserSumAggregateOutputType = {
    encryptionKeyVersion: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    displayName: string | null
    avatarEmoji: string | null
    avatarBgColor: string | null
    email: string | null
    emailVerifiedAt: Date | null
    timezone: string | null
    locale: string | null
    encryptionKeyVersion: number | null
    keyRecoveryMethod: string | null
    keySalt: Bytes | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    displayName: string | null
    avatarEmoji: string | null
    avatarBgColor: string | null
    email: string | null
    emailVerifiedAt: Date | null
    timezone: string | null
    locale: string | null
    encryptionKeyVersion: number | null
    keyRecoveryMethod: string | null
    keySalt: Bytes | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    displayName: number
    avatarEmoji: number
    avatarBgColor: number
    email: number
    emailVerifiedAt: number
    timezone: number
    locale: number
    encryptionKeyVersion: number
    keyRecoveryMethod: number
    keySalt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    encryptionKeyVersion?: true
  }

  export type UserSumAggregateInputType = {
    encryptionKeyVersion?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    avatarEmoji?: true
    avatarBgColor?: true
    email?: true
    emailVerifiedAt?: true
    timezone?: true
    locale?: true
    encryptionKeyVersion?: true
    keyRecoveryMethod?: true
    keySalt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    avatarEmoji?: true
    avatarBgColor?: true
    email?: true
    emailVerifiedAt?: true
    timezone?: true
    locale?: true
    encryptionKeyVersion?: true
    keyRecoveryMethod?: true
    keySalt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    avatarEmoji?: true
    avatarBgColor?: true
    email?: true
    emailVerifiedAt?: true
    timezone?: true
    locale?: true
    encryptionKeyVersion?: true
    keyRecoveryMethod?: true
    keySalt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    displayName: string | null
    avatarEmoji: string
    avatarBgColor: string
    email: string | null
    emailVerifiedAt: Date | null
    timezone: string
    locale: string
    encryptionKeyVersion: number
    keyRecoveryMethod: string | null
    keySalt: Bytes | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    avatarEmoji?: boolean
    avatarBgColor?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    timezone?: boolean
    locale?: boolean
    encryptionKeyVersion?: boolean
    keyRecoveryMethod?: boolean
    keySalt?: boolean
    alarmSettings?: boolean | User$alarmSettingsArgs<ExtArgs>
    censusAnswers?: boolean | User$censusAnswersArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    dreamEntries?: boolean | User$dreamEntriesArgs<ExtArgs>
    dreamerProfile?: boolean | User$dreamerProfileArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    nightCheckIns?: boolean | User$nightCheckInsArgs<ExtArgs>
    promptResponses?: boolean | User$promptResponsesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    studyParticipations?: boolean | User$studyParticipationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    avatarEmoji?: boolean
    avatarBgColor?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    timezone?: boolean
    locale?: boolean
    encryptionKeyVersion?: boolean
    keyRecoveryMethod?: boolean
    keySalt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    avatarEmoji?: boolean
    avatarBgColor?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    timezone?: boolean
    locale?: boolean
    encryptionKeyVersion?: boolean
    keyRecoveryMethod?: boolean
    keySalt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    avatarEmoji?: boolean
    avatarBgColor?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    timezone?: boolean
    locale?: boolean
    encryptionKeyVersion?: boolean
    keyRecoveryMethod?: boolean
    keySalt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "displayName" | "avatarEmoji" | "avatarBgColor" | "email" | "emailVerifiedAt" | "timezone" | "locale" | "encryptionKeyVersion" | "keyRecoveryMethod" | "keySalt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alarmSettings?: boolean | User$alarmSettingsArgs<ExtArgs>
    censusAnswers?: boolean | User$censusAnswersArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    dreamEntries?: boolean | User$dreamEntriesArgs<ExtArgs>
    dreamerProfile?: boolean | User$dreamerProfileArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    nightCheckIns?: boolean | User$nightCheckInsArgs<ExtArgs>
    promptResponses?: boolean | User$promptResponsesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    studyParticipations?: boolean | User$studyParticipationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      alarmSettings: Prisma.$AlarmSettingsPayload<ExtArgs> | null
      censusAnswers: Prisma.$CensusAnswerPayload<ExtArgs>[]
      consents: Prisma.$ConsentPayload<ExtArgs>[]
      dreamEntries: Prisma.$DreamEntryPayload<ExtArgs>[]
      dreamerProfile: Prisma.$DreamerProfilePayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
      nightCheckIns: Prisma.$NightCheckInPayload<ExtArgs>[]
      promptResponses: Prisma.$PromptResponsePayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      studyParticipations: Prisma.$StudyParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      displayName: string | null
      avatarEmoji: string
      avatarBgColor: string
      email: string | null
      emailVerifiedAt: Date | null
      timezone: string
      locale: string
      encryptionKeyVersion: number
      keyRecoveryMethod: string | null
      keySalt: Prisma.Bytes | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alarmSettings<T extends User$alarmSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$alarmSettingsArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    censusAnswers<T extends User$censusAnswersArgs<ExtArgs> = {}>(args?: Subset<T, User$censusAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consents<T extends User$consentsArgs<ExtArgs> = {}>(args?: Subset<T, User$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dreamEntries<T extends User$dreamEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$dreamEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dreamerProfile<T extends User$dreamerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$dreamerProfileArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nightCheckIns<T extends User$nightCheckInsArgs<ExtArgs> = {}>(args?: Subset<T, User$nightCheckInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promptResponses<T extends User$promptResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$promptResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studyParticipations<T extends User$studyParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, User$studyParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarEmoji: FieldRef<"User", 'String'>
    readonly avatarBgColor: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly locale: FieldRef<"User", 'String'>
    readonly encryptionKeyVersion: FieldRef<"User", 'Int'>
    readonly keyRecoveryMethod: FieldRef<"User", 'String'>
    readonly keySalt: FieldRef<"User", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.alarmSettings
   */
  export type User$alarmSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    where?: AlarmSettingsWhereInput
  }

  /**
   * User.censusAnswers
   */
  export type User$censusAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    where?: CensusAnswerWhereInput
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    cursor?: CensusAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusAnswerScalarFieldEnum | CensusAnswerScalarFieldEnum[]
  }

  /**
   * User.consents
   */
  export type User$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    where?: ConsentWhereInput
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    cursor?: ConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * User.dreamEntries
   */
  export type User$dreamEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    where?: DreamEntryWhereInput
    orderBy?: DreamEntryOrderByWithRelationInput | DreamEntryOrderByWithRelationInput[]
    cursor?: DreamEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DreamEntryScalarFieldEnum | DreamEntryScalarFieldEnum[]
  }

  /**
   * User.dreamerProfile
   */
  export type User$dreamerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    where?: DreamerProfileWhereInput
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.nightCheckIns
   */
  export type User$nightCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    where?: NightCheckInWhereInput
    orderBy?: NightCheckInOrderByWithRelationInput | NightCheckInOrderByWithRelationInput[]
    cursor?: NightCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NightCheckInScalarFieldEnum | NightCheckInScalarFieldEnum[]
  }

  /**
   * User.promptResponses
   */
  export type User$promptResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    where?: PromptResponseWhereInput
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    cursor?: PromptResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptResponseScalarFieldEnum | PromptResponseScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.studyParticipations
   */
  export type User$studyParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    where?: StudyParticipationWhereInput
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    cursor?: StudyParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyParticipationScalarFieldEnum | StudyParticipationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    deviceId: string | null
    deviceName: string | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    deviceId: string | null
    deviceName: string | null
    lastActiveAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    deviceId: number
    deviceName: number
    lastActiveAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    deviceId?: true
    deviceName?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    deviceId?: true
    deviceName?: true
    lastActiveAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    deviceId?: true
    deviceName?: true
    lastActiveAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    deviceId: string | null
    deviceName: string | null
    lastActiveAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    deviceId?: boolean
    deviceName?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    deviceId?: boolean
    deviceName?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    deviceId?: boolean
    deviceName?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    deviceId?: boolean
    deviceName?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokenHash" | "expiresAt" | "deviceId" | "deviceName" | "lastActiveAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      deviceId: string | null
      deviceName: string | null
      lastActiveAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly tokenHash: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly deviceId: FieldRef<"Session", 'String'>
    readonly deviceName: FieldRef<"Session", 'String'>
    readonly lastActiveAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expiresAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    sequence: number | null
  }

  export type EventSumAggregateOutputType = {
    sequence: bigint | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    timestamp: Date | null
    sequence: bigint | null
    aggregateId: string | null
    aggregateType: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    timestamp: Date | null
    sequence: bigint | null
    aggregateId: string | null
    aggregateType: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    payload: number
    timestamp: number
    sequence: number
    aggregateId: number
    aggregateType: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    sequence?: true
  }

  export type EventSumAggregateInputType = {
    sequence?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    timestamp?: true
    sequence?: true
    aggregateId?: true
    aggregateType?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    timestamp?: true
    sequence?: true
    aggregateId?: true
    aggregateType?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    payload?: true
    timestamp?: true
    sequence?: true
    aggregateId?: true
    aggregateType?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    userId: string
    type: string
    payload: JsonValue
    timestamp: Date
    sequence: bigint
    aggregateId: string | null
    aggregateType: string | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    timestamp?: boolean
    sequence?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    timestamp?: boolean
    sequence?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    timestamp?: boolean
    sequence?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    payload?: boolean
    timestamp?: boolean
    sequence?: boolean
    aggregateId?: boolean
    aggregateType?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "payload" | "timestamp" | "sequence" | "aggregateId" | "aggregateType", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      payload: Prisma.JsonValue
      timestamp: Date
      sequence: bigint
      aggregateId: string | null
      aggregateType: string | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
    readonly type: FieldRef<"Event", 'String'>
    readonly payload: FieldRef<"Event", 'Json'>
    readonly timestamp: FieldRef<"Event", 'DateTime'>
    readonly sequence: FieldRef<"Event", 'BigInt'>
    readonly aggregateId: FieldRef<"Event", 'String'>
    readonly aggregateType: FieldRef<"Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model DreamEntry
   */

  export type AggregateDreamEntry = {
    _count: DreamEntryCountAggregateOutputType | null
    _avg: DreamEntryAvgAggregateOutputType | null
    _sum: DreamEntrySumAggregateOutputType | null
    _min: DreamEntryMinAggregateOutputType | null
    _max: DreamEntryMaxAggregateOutputType | null
  }

  export type DreamEntryAvgAggregateOutputType = {
    keyVersion: number | null
    vividness: number | null
    sleepQuality: number | null
    hoursSlept: number | null
  }

  export type DreamEntrySumAggregateOutputType = {
    keyVersion: number | null
    vividness: number | null
    sleepQuality: number | null
    hoursSlept: number | null
  }

  export type DreamEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ciphertext: Bytes | null
    iv: Bytes | null
    keyVersion: number | null
    audioUrl: string | null
    title: string | null
    vividness: number | null
    lucidity: string | null
    sleepQuality: number | null
    hoursSlept: number | null
    wakeTime: Date | null
    wakingLifeLink: string | null
    capturedAt: Date | null
    updatedAt: Date | null
  }

  export type DreamEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ciphertext: Bytes | null
    iv: Bytes | null
    keyVersion: number | null
    audioUrl: string | null
    title: string | null
    vividness: number | null
    lucidity: string | null
    sleepQuality: number | null
    hoursSlept: number | null
    wakeTime: Date | null
    wakingLifeLink: string | null
    capturedAt: Date | null
    updatedAt: Date | null
  }

  export type DreamEntryCountAggregateOutputType = {
    id: number
    userId: number
    ciphertext: number
    iv: number
    keyVersion: number
    audioUrl: number
    title: number
    emotions: number
    vividness: number
    lucidity: number
    dreamTypes: number
    sleepQuality: number
    hoursSlept: number
    wakeTime: number
    wakingLifeLink: number
    capturedAt: number
    updatedAt: number
    _all: number
  }


  export type DreamEntryAvgAggregateInputType = {
    keyVersion?: true
    vividness?: true
    sleepQuality?: true
    hoursSlept?: true
  }

  export type DreamEntrySumAggregateInputType = {
    keyVersion?: true
    vividness?: true
    sleepQuality?: true
    hoursSlept?: true
  }

  export type DreamEntryMinAggregateInputType = {
    id?: true
    userId?: true
    ciphertext?: true
    iv?: true
    keyVersion?: true
    audioUrl?: true
    title?: true
    vividness?: true
    lucidity?: true
    sleepQuality?: true
    hoursSlept?: true
    wakeTime?: true
    wakingLifeLink?: true
    capturedAt?: true
    updatedAt?: true
  }

  export type DreamEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    ciphertext?: true
    iv?: true
    keyVersion?: true
    audioUrl?: true
    title?: true
    vividness?: true
    lucidity?: true
    sleepQuality?: true
    hoursSlept?: true
    wakeTime?: true
    wakingLifeLink?: true
    capturedAt?: true
    updatedAt?: true
  }

  export type DreamEntryCountAggregateInputType = {
    id?: true
    userId?: true
    ciphertext?: true
    iv?: true
    keyVersion?: true
    audioUrl?: true
    title?: true
    emotions?: true
    vividness?: true
    lucidity?: true
    dreamTypes?: true
    sleepQuality?: true
    hoursSlept?: true
    wakeTime?: true
    wakingLifeLink?: true
    capturedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DreamEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamEntry to aggregate.
     */
    where?: DreamEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamEntries to fetch.
     */
    orderBy?: DreamEntryOrderByWithRelationInput | DreamEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DreamEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DreamEntries
    **/
    _count?: true | DreamEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DreamEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DreamEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DreamEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DreamEntryMaxAggregateInputType
  }

  export type GetDreamEntryAggregateType<T extends DreamEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDreamEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDreamEntry[P]>
      : GetScalarType<T[P], AggregateDreamEntry[P]>
  }




  export type DreamEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamEntryWhereInput
    orderBy?: DreamEntryOrderByWithAggregationInput | DreamEntryOrderByWithAggregationInput[]
    by: DreamEntryScalarFieldEnum[] | DreamEntryScalarFieldEnum
    having?: DreamEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DreamEntryCountAggregateInputType | true
    _avg?: DreamEntryAvgAggregateInputType
    _sum?: DreamEntrySumAggregateInputType
    _min?: DreamEntryMinAggregateInputType
    _max?: DreamEntryMaxAggregateInputType
  }

  export type DreamEntryGroupByOutputType = {
    id: string
    userId: string
    ciphertext: Bytes | null
    iv: Bytes | null
    keyVersion: number
    audioUrl: string | null
    title: string | null
    emotions: string[]
    vividness: number | null
    lucidity: string | null
    dreamTypes: string[]
    sleepQuality: number | null
    hoursSlept: number | null
    wakeTime: Date | null
    wakingLifeLink: string | null
    capturedAt: Date
    updatedAt: Date
    _count: DreamEntryCountAggregateOutputType | null
    _avg: DreamEntryAvgAggregateOutputType | null
    _sum: DreamEntrySumAggregateOutputType | null
    _min: DreamEntryMinAggregateOutputType | null
    _max: DreamEntryMaxAggregateOutputType | null
  }

  type GetDreamEntryGroupByPayload<T extends DreamEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DreamEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DreamEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DreamEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DreamEntryGroupByOutputType[P]>
        }
      >
    >


  export type DreamEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ciphertext?: boolean
    iv?: boolean
    keyVersion?: boolean
    audioUrl?: boolean
    title?: boolean
    emotions?: boolean
    vividness?: boolean
    lucidity?: boolean
    dreamTypes?: boolean
    sleepQuality?: boolean
    hoursSlept?: boolean
    wakeTime?: boolean
    wakingLifeLink?: boolean
    capturedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | DreamEntry$tagsArgs<ExtArgs>
    facts?: boolean | DreamEntry$factsArgs<ExtArgs>
    _count?: boolean | DreamEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamEntry"]>

  export type DreamEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ciphertext?: boolean
    iv?: boolean
    keyVersion?: boolean
    audioUrl?: boolean
    title?: boolean
    emotions?: boolean
    vividness?: boolean
    lucidity?: boolean
    dreamTypes?: boolean
    sleepQuality?: boolean
    hoursSlept?: boolean
    wakeTime?: boolean
    wakingLifeLink?: boolean
    capturedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamEntry"]>

  export type DreamEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ciphertext?: boolean
    iv?: boolean
    keyVersion?: boolean
    audioUrl?: boolean
    title?: boolean
    emotions?: boolean
    vividness?: boolean
    lucidity?: boolean
    dreamTypes?: boolean
    sleepQuality?: boolean
    hoursSlept?: boolean
    wakeTime?: boolean
    wakingLifeLink?: boolean
    capturedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamEntry"]>

  export type DreamEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    ciphertext?: boolean
    iv?: boolean
    keyVersion?: boolean
    audioUrl?: boolean
    title?: boolean
    emotions?: boolean
    vividness?: boolean
    lucidity?: boolean
    dreamTypes?: boolean
    sleepQuality?: boolean
    hoursSlept?: boolean
    wakeTime?: boolean
    wakingLifeLink?: boolean
    capturedAt?: boolean
    updatedAt?: boolean
  }

  export type DreamEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ciphertext" | "iv" | "keyVersion" | "audioUrl" | "title" | "emotions" | "vividness" | "lucidity" | "dreamTypes" | "sleepQuality" | "hoursSlept" | "wakeTime" | "wakingLifeLink" | "capturedAt" | "updatedAt", ExtArgs["result"]["dreamEntry"]>
  export type DreamEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | DreamEntry$tagsArgs<ExtArgs>
    facts?: boolean | DreamEntry$factsArgs<ExtArgs>
    _count?: boolean | DreamEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DreamEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DreamEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DreamEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DreamEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tags: Prisma.$DreamTagPayload<ExtArgs>[]
      facts: Prisma.$JournalFactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      ciphertext: Prisma.Bytes | null
      iv: Prisma.Bytes | null
      keyVersion: number
      audioUrl: string | null
      title: string | null
      emotions: string[]
      vividness: number | null
      lucidity: string | null
      dreamTypes: string[]
      sleepQuality: number | null
      hoursSlept: number | null
      wakeTime: Date | null
      wakingLifeLink: string | null
      capturedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dreamEntry"]>
    composites: {}
  }

  type DreamEntryGetPayload<S extends boolean | null | undefined | DreamEntryDefaultArgs> = $Result.GetResult<Prisma.$DreamEntryPayload, S>

  type DreamEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DreamEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DreamEntryCountAggregateInputType | true
    }

  export interface DreamEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DreamEntry'], meta: { name: 'DreamEntry' } }
    /**
     * Find zero or one DreamEntry that matches the filter.
     * @param {DreamEntryFindUniqueArgs} args - Arguments to find a DreamEntry
     * @example
     * // Get one DreamEntry
     * const dreamEntry = await prisma.dreamEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DreamEntryFindUniqueArgs>(args: SelectSubset<T, DreamEntryFindUniqueArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DreamEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DreamEntryFindUniqueOrThrowArgs} args - Arguments to find a DreamEntry
     * @example
     * // Get one DreamEntry
     * const dreamEntry = await prisma.dreamEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DreamEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DreamEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryFindFirstArgs} args - Arguments to find a DreamEntry
     * @example
     * // Get one DreamEntry
     * const dreamEntry = await prisma.dreamEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DreamEntryFindFirstArgs>(args?: SelectSubset<T, DreamEntryFindFirstArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryFindFirstOrThrowArgs} args - Arguments to find a DreamEntry
     * @example
     * // Get one DreamEntry
     * const dreamEntry = await prisma.dreamEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DreamEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DreamEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DreamEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DreamEntries
     * const dreamEntries = await prisma.dreamEntry.findMany()
     * 
     * // Get first 10 DreamEntries
     * const dreamEntries = await prisma.dreamEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dreamEntryWithIdOnly = await prisma.dreamEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DreamEntryFindManyArgs>(args?: SelectSubset<T, DreamEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DreamEntry.
     * @param {DreamEntryCreateArgs} args - Arguments to create a DreamEntry.
     * @example
     * // Create one DreamEntry
     * const DreamEntry = await prisma.dreamEntry.create({
     *   data: {
     *     // ... data to create a DreamEntry
     *   }
     * })
     * 
     */
    create<T extends DreamEntryCreateArgs>(args: SelectSubset<T, DreamEntryCreateArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DreamEntries.
     * @param {DreamEntryCreateManyArgs} args - Arguments to create many DreamEntries.
     * @example
     * // Create many DreamEntries
     * const dreamEntry = await prisma.dreamEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DreamEntryCreateManyArgs>(args?: SelectSubset<T, DreamEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DreamEntries and returns the data saved in the database.
     * @param {DreamEntryCreateManyAndReturnArgs} args - Arguments to create many DreamEntries.
     * @example
     * // Create many DreamEntries
     * const dreamEntry = await prisma.dreamEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DreamEntries and only return the `id`
     * const dreamEntryWithIdOnly = await prisma.dreamEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DreamEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DreamEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DreamEntry.
     * @param {DreamEntryDeleteArgs} args - Arguments to delete one DreamEntry.
     * @example
     * // Delete one DreamEntry
     * const DreamEntry = await prisma.dreamEntry.delete({
     *   where: {
     *     // ... filter to delete one DreamEntry
     *   }
     * })
     * 
     */
    delete<T extends DreamEntryDeleteArgs>(args: SelectSubset<T, DreamEntryDeleteArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DreamEntry.
     * @param {DreamEntryUpdateArgs} args - Arguments to update one DreamEntry.
     * @example
     * // Update one DreamEntry
     * const dreamEntry = await prisma.dreamEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DreamEntryUpdateArgs>(args: SelectSubset<T, DreamEntryUpdateArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DreamEntries.
     * @param {DreamEntryDeleteManyArgs} args - Arguments to filter DreamEntries to delete.
     * @example
     * // Delete a few DreamEntries
     * const { count } = await prisma.dreamEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DreamEntryDeleteManyArgs>(args?: SelectSubset<T, DreamEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DreamEntries
     * const dreamEntry = await prisma.dreamEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DreamEntryUpdateManyArgs>(args: SelectSubset<T, DreamEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamEntries and returns the data updated in the database.
     * @param {DreamEntryUpdateManyAndReturnArgs} args - Arguments to update many DreamEntries.
     * @example
     * // Update many DreamEntries
     * const dreamEntry = await prisma.dreamEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DreamEntries and only return the `id`
     * const dreamEntryWithIdOnly = await prisma.dreamEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DreamEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, DreamEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DreamEntry.
     * @param {DreamEntryUpsertArgs} args - Arguments to update or create a DreamEntry.
     * @example
     * // Update or create a DreamEntry
     * const dreamEntry = await prisma.dreamEntry.upsert({
     *   create: {
     *     // ... data to create a DreamEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DreamEntry we want to update
     *   }
     * })
     */
    upsert<T extends DreamEntryUpsertArgs>(args: SelectSubset<T, DreamEntryUpsertArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DreamEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryCountArgs} args - Arguments to filter DreamEntries to count.
     * @example
     * // Count the number of DreamEntries
     * const count = await prisma.dreamEntry.count({
     *   where: {
     *     // ... the filter for the DreamEntries we want to count
     *   }
     * })
    **/
    count<T extends DreamEntryCountArgs>(
      args?: Subset<T, DreamEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DreamEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DreamEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DreamEntryAggregateArgs>(args: Subset<T, DreamEntryAggregateArgs>): Prisma.PrismaPromise<GetDreamEntryAggregateType<T>>

    /**
     * Group by DreamEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DreamEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DreamEntryGroupByArgs['orderBy'] }
        : { orderBy?: DreamEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DreamEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDreamEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DreamEntry model
   */
  readonly fields: DreamEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DreamEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DreamEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends DreamEntry$tagsArgs<ExtArgs> = {}>(args?: Subset<T, DreamEntry$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facts<T extends DreamEntry$factsArgs<ExtArgs> = {}>(args?: Subset<T, DreamEntry$factsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DreamEntry model
   */
  interface DreamEntryFieldRefs {
    readonly id: FieldRef<"DreamEntry", 'String'>
    readonly userId: FieldRef<"DreamEntry", 'String'>
    readonly ciphertext: FieldRef<"DreamEntry", 'Bytes'>
    readonly iv: FieldRef<"DreamEntry", 'Bytes'>
    readonly keyVersion: FieldRef<"DreamEntry", 'Int'>
    readonly audioUrl: FieldRef<"DreamEntry", 'String'>
    readonly title: FieldRef<"DreamEntry", 'String'>
    readonly emotions: FieldRef<"DreamEntry", 'String[]'>
    readonly vividness: FieldRef<"DreamEntry", 'Int'>
    readonly lucidity: FieldRef<"DreamEntry", 'String'>
    readonly dreamTypes: FieldRef<"DreamEntry", 'String[]'>
    readonly sleepQuality: FieldRef<"DreamEntry", 'Int'>
    readonly hoursSlept: FieldRef<"DreamEntry", 'Float'>
    readonly wakeTime: FieldRef<"DreamEntry", 'DateTime'>
    readonly wakingLifeLink: FieldRef<"DreamEntry", 'String'>
    readonly capturedAt: FieldRef<"DreamEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"DreamEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DreamEntry findUnique
   */
  export type DreamEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter, which DreamEntry to fetch.
     */
    where: DreamEntryWhereUniqueInput
  }

  /**
   * DreamEntry findUniqueOrThrow
   */
  export type DreamEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter, which DreamEntry to fetch.
     */
    where: DreamEntryWhereUniqueInput
  }

  /**
   * DreamEntry findFirst
   */
  export type DreamEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter, which DreamEntry to fetch.
     */
    where?: DreamEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamEntries to fetch.
     */
    orderBy?: DreamEntryOrderByWithRelationInput | DreamEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamEntries.
     */
    cursor?: DreamEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamEntries.
     */
    distinct?: DreamEntryScalarFieldEnum | DreamEntryScalarFieldEnum[]
  }

  /**
   * DreamEntry findFirstOrThrow
   */
  export type DreamEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter, which DreamEntry to fetch.
     */
    where?: DreamEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamEntries to fetch.
     */
    orderBy?: DreamEntryOrderByWithRelationInput | DreamEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamEntries.
     */
    cursor?: DreamEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamEntries.
     */
    distinct?: DreamEntryScalarFieldEnum | DreamEntryScalarFieldEnum[]
  }

  /**
   * DreamEntry findMany
   */
  export type DreamEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter, which DreamEntries to fetch.
     */
    where?: DreamEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamEntries to fetch.
     */
    orderBy?: DreamEntryOrderByWithRelationInput | DreamEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DreamEntries.
     */
    cursor?: DreamEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamEntries.
     */
    skip?: number
    distinct?: DreamEntryScalarFieldEnum | DreamEntryScalarFieldEnum[]
  }

  /**
   * DreamEntry create
   */
  export type DreamEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DreamEntry.
     */
    data: XOR<DreamEntryCreateInput, DreamEntryUncheckedCreateInput>
  }

  /**
   * DreamEntry createMany
   */
  export type DreamEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DreamEntries.
     */
    data: DreamEntryCreateManyInput | DreamEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DreamEntry createManyAndReturn
   */
  export type DreamEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * The data used to create many DreamEntries.
     */
    data: DreamEntryCreateManyInput | DreamEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamEntry update
   */
  export type DreamEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DreamEntry.
     */
    data: XOR<DreamEntryUpdateInput, DreamEntryUncheckedUpdateInput>
    /**
     * Choose, which DreamEntry to update.
     */
    where: DreamEntryWhereUniqueInput
  }

  /**
   * DreamEntry updateMany
   */
  export type DreamEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DreamEntries.
     */
    data: XOR<DreamEntryUpdateManyMutationInput, DreamEntryUncheckedUpdateManyInput>
    /**
     * Filter which DreamEntries to update
     */
    where?: DreamEntryWhereInput
    /**
     * Limit how many DreamEntries to update.
     */
    limit?: number
  }

  /**
   * DreamEntry updateManyAndReturn
   */
  export type DreamEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * The data used to update DreamEntries.
     */
    data: XOR<DreamEntryUpdateManyMutationInput, DreamEntryUncheckedUpdateManyInput>
    /**
     * Filter which DreamEntries to update
     */
    where?: DreamEntryWhereInput
    /**
     * Limit how many DreamEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamEntry upsert
   */
  export type DreamEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DreamEntry to update in case it exists.
     */
    where: DreamEntryWhereUniqueInput
    /**
     * In case the DreamEntry found by the `where` argument doesn't exist, create a new DreamEntry with this data.
     */
    create: XOR<DreamEntryCreateInput, DreamEntryUncheckedCreateInput>
    /**
     * In case the DreamEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DreamEntryUpdateInput, DreamEntryUncheckedUpdateInput>
  }

  /**
   * DreamEntry delete
   */
  export type DreamEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
    /**
     * Filter which DreamEntry to delete.
     */
    where: DreamEntryWhereUniqueInput
  }

  /**
   * DreamEntry deleteMany
   */
  export type DreamEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamEntries to delete
     */
    where?: DreamEntryWhereInput
    /**
     * Limit how many DreamEntries to delete.
     */
    limit?: number
  }

  /**
   * DreamEntry.tags
   */
  export type DreamEntry$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    where?: DreamTagWhereInput
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    cursor?: DreamTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DreamTagScalarFieldEnum | DreamTagScalarFieldEnum[]
  }

  /**
   * DreamEntry.facts
   */
  export type DreamEntry$factsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    where?: JournalFactWhereInput
    orderBy?: JournalFactOrderByWithRelationInput | JournalFactOrderByWithRelationInput[]
    cursor?: JournalFactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalFactScalarFieldEnum | JournalFactScalarFieldEnum[]
  }

  /**
   * DreamEntry without action
   */
  export type DreamEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamEntry
     */
    select?: DreamEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamEntry
     */
    omit?: DreamEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamEntryInclude<ExtArgs> | null
  }


  /**
   * Model JournalFact
   */

  export type AggregateJournalFact = {
    _count: JournalFactCountAggregateOutputType | null
    _avg: JournalFactAvgAggregateOutputType | null
    _sum: JournalFactSumAggregateOutputType | null
    _min: JournalFactMinAggregateOutputType | null
    _max: JournalFactMaxAggregateOutputType | null
  }

  export type JournalFactAvgAggregateOutputType = {
    confidence: number | null
    ontologyVersion: number | null
    promptVersion: number | null
    startIndex: number | null
    endIndex: number | null
  }

  export type JournalFactSumAggregateOutputType = {
    confidence: number | null
    ontologyVersion: number | null
    promptVersion: number | null
    startIndex: number | null
    endIndex: number | null
  }

  export type JournalFactMinAggregateOutputType = {
    id: string | null
    dreamEntryId: string | null
    factType: string | null
    confidence: number | null
    ontologyVersion: number | null
    modelVersion: string | null
    promptVersion: number | null
    startIndex: number | null
    endIndex: number | null
    extractedAt: Date | null
  }

  export type JournalFactMaxAggregateOutputType = {
    id: string | null
    dreamEntryId: string | null
    factType: string | null
    confidence: number | null
    ontologyVersion: number | null
    modelVersion: string | null
    promptVersion: number | null
    startIndex: number | null
    endIndex: number | null
    extractedAt: Date | null
  }

  export type JournalFactCountAggregateOutputType = {
    id: number
    dreamEntryId: number
    factType: number
    value: number
    confidence: number
    ontologyVersion: number
    modelVersion: number
    promptVersion: number
    startIndex: number
    endIndex: number
    extractedAt: number
    _all: number
  }


  export type JournalFactAvgAggregateInputType = {
    confidence?: true
    ontologyVersion?: true
    promptVersion?: true
    startIndex?: true
    endIndex?: true
  }

  export type JournalFactSumAggregateInputType = {
    confidence?: true
    ontologyVersion?: true
    promptVersion?: true
    startIndex?: true
    endIndex?: true
  }

  export type JournalFactMinAggregateInputType = {
    id?: true
    dreamEntryId?: true
    factType?: true
    confidence?: true
    ontologyVersion?: true
    modelVersion?: true
    promptVersion?: true
    startIndex?: true
    endIndex?: true
    extractedAt?: true
  }

  export type JournalFactMaxAggregateInputType = {
    id?: true
    dreamEntryId?: true
    factType?: true
    confidence?: true
    ontologyVersion?: true
    modelVersion?: true
    promptVersion?: true
    startIndex?: true
    endIndex?: true
    extractedAt?: true
  }

  export type JournalFactCountAggregateInputType = {
    id?: true
    dreamEntryId?: true
    factType?: true
    value?: true
    confidence?: true
    ontologyVersion?: true
    modelVersion?: true
    promptVersion?: true
    startIndex?: true
    endIndex?: true
    extractedAt?: true
    _all?: true
  }

  export type JournalFactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFact to aggregate.
     */
    where?: JournalFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFacts to fetch.
     */
    orderBy?: JournalFactOrderByWithRelationInput | JournalFactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalFacts
    **/
    _count?: true | JournalFactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalFactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalFactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalFactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalFactMaxAggregateInputType
  }

  export type GetJournalFactAggregateType<T extends JournalFactAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalFact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalFact[P]>
      : GetScalarType<T[P], AggregateJournalFact[P]>
  }




  export type JournalFactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFactWhereInput
    orderBy?: JournalFactOrderByWithAggregationInput | JournalFactOrderByWithAggregationInput[]
    by: JournalFactScalarFieldEnum[] | JournalFactScalarFieldEnum
    having?: JournalFactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalFactCountAggregateInputType | true
    _avg?: JournalFactAvgAggregateInputType
    _sum?: JournalFactSumAggregateInputType
    _min?: JournalFactMinAggregateInputType
    _max?: JournalFactMaxAggregateInputType
  }

  export type JournalFactGroupByOutputType = {
    id: string
    dreamEntryId: string
    factType: string
    value: JsonValue
    confidence: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex: number | null
    endIndex: number | null
    extractedAt: Date
    _count: JournalFactCountAggregateOutputType | null
    _avg: JournalFactAvgAggregateOutputType | null
    _sum: JournalFactSumAggregateOutputType | null
    _min: JournalFactMinAggregateOutputType | null
    _max: JournalFactMaxAggregateOutputType | null
  }

  type GetJournalFactGroupByPayload<T extends JournalFactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalFactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalFactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalFactGroupByOutputType[P]>
            : GetScalarType<T[P], JournalFactGroupByOutputType[P]>
        }
      >
    >


  export type JournalFactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    factType?: boolean
    value?: boolean
    confidence?: boolean
    ontologyVersion?: boolean
    modelVersion?: boolean
    promptVersion?: boolean
    startIndex?: boolean
    endIndex?: boolean
    extractedAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFact"]>

  export type JournalFactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    factType?: boolean
    value?: boolean
    confidence?: boolean
    ontologyVersion?: boolean
    modelVersion?: boolean
    promptVersion?: boolean
    startIndex?: boolean
    endIndex?: boolean
    extractedAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFact"]>

  export type JournalFactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    factType?: boolean
    value?: boolean
    confidence?: boolean
    ontologyVersion?: boolean
    modelVersion?: boolean
    promptVersion?: boolean
    startIndex?: boolean
    endIndex?: boolean
    extractedAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFact"]>

  export type JournalFactSelectScalar = {
    id?: boolean
    dreamEntryId?: boolean
    factType?: boolean
    value?: boolean
    confidence?: boolean
    ontologyVersion?: boolean
    modelVersion?: boolean
    promptVersion?: boolean
    startIndex?: boolean
    endIndex?: boolean
    extractedAt?: boolean
  }

  export type JournalFactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dreamEntryId" | "factType" | "value" | "confidence" | "ontologyVersion" | "modelVersion" | "promptVersion" | "startIndex" | "endIndex" | "extractedAt", ExtArgs["result"]["journalFact"]>
  export type JournalFactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }
  export type JournalFactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }
  export type JournalFactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
  }

  export type $JournalFactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalFact"
    objects: {
      dreamEntry: Prisma.$DreamEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dreamEntryId: string
      factType: string
      value: Prisma.JsonValue
      confidence: number
      ontologyVersion: number
      modelVersion: string
      promptVersion: number
      startIndex: number | null
      endIndex: number | null
      extractedAt: Date
    }, ExtArgs["result"]["journalFact"]>
    composites: {}
  }

  type JournalFactGetPayload<S extends boolean | null | undefined | JournalFactDefaultArgs> = $Result.GetResult<Prisma.$JournalFactPayload, S>

  type JournalFactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalFactCountAggregateInputType | true
    }

  export interface JournalFactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalFact'], meta: { name: 'JournalFact' } }
    /**
     * Find zero or one JournalFact that matches the filter.
     * @param {JournalFactFindUniqueArgs} args - Arguments to find a JournalFact
     * @example
     * // Get one JournalFact
     * const journalFact = await prisma.journalFact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFactFindUniqueArgs>(args: SelectSubset<T, JournalFactFindUniqueArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalFact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFactFindUniqueOrThrowArgs} args - Arguments to find a JournalFact
     * @example
     * // Get one JournalFact
     * const journalFact = await prisma.journalFact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFactFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactFindFirstArgs} args - Arguments to find a JournalFact
     * @example
     * // Get one JournalFact
     * const journalFact = await prisma.journalFact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFactFindFirstArgs>(args?: SelectSubset<T, JournalFactFindFirstArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactFindFirstOrThrowArgs} args - Arguments to find a JournalFact
     * @example
     * // Get one JournalFact
     * const journalFact = await prisma.journalFact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFactFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFactFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalFacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalFacts
     * const journalFacts = await prisma.journalFact.findMany()
     * 
     * // Get first 10 JournalFacts
     * const journalFacts = await prisma.journalFact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalFactWithIdOnly = await prisma.journalFact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFactFindManyArgs>(args?: SelectSubset<T, JournalFactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalFact.
     * @param {JournalFactCreateArgs} args - Arguments to create a JournalFact.
     * @example
     * // Create one JournalFact
     * const JournalFact = await prisma.journalFact.create({
     *   data: {
     *     // ... data to create a JournalFact
     *   }
     * })
     * 
     */
    create<T extends JournalFactCreateArgs>(args: SelectSubset<T, JournalFactCreateArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalFacts.
     * @param {JournalFactCreateManyArgs} args - Arguments to create many JournalFacts.
     * @example
     * // Create many JournalFacts
     * const journalFact = await prisma.journalFact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalFactCreateManyArgs>(args?: SelectSubset<T, JournalFactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalFacts and returns the data saved in the database.
     * @param {JournalFactCreateManyAndReturnArgs} args - Arguments to create many JournalFacts.
     * @example
     * // Create many JournalFacts
     * const journalFact = await prisma.journalFact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalFacts and only return the `id`
     * const journalFactWithIdOnly = await prisma.journalFact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalFactCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalFactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalFact.
     * @param {JournalFactDeleteArgs} args - Arguments to delete one JournalFact.
     * @example
     * // Delete one JournalFact
     * const JournalFact = await prisma.journalFact.delete({
     *   where: {
     *     // ... filter to delete one JournalFact
     *   }
     * })
     * 
     */
    delete<T extends JournalFactDeleteArgs>(args: SelectSubset<T, JournalFactDeleteArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalFact.
     * @param {JournalFactUpdateArgs} args - Arguments to update one JournalFact.
     * @example
     * // Update one JournalFact
     * const journalFact = await prisma.journalFact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalFactUpdateArgs>(args: SelectSubset<T, JournalFactUpdateArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalFacts.
     * @param {JournalFactDeleteManyArgs} args - Arguments to filter JournalFacts to delete.
     * @example
     * // Delete a few JournalFacts
     * const { count } = await prisma.journalFact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalFactDeleteManyArgs>(args?: SelectSubset<T, JournalFactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalFacts
     * const journalFact = await prisma.journalFact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalFactUpdateManyArgs>(args: SelectSubset<T, JournalFactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFacts and returns the data updated in the database.
     * @param {JournalFactUpdateManyAndReturnArgs} args - Arguments to update many JournalFacts.
     * @example
     * // Update many JournalFacts
     * const journalFact = await prisma.journalFact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalFacts and only return the `id`
     * const journalFactWithIdOnly = await prisma.journalFact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalFactUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalFactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalFact.
     * @param {JournalFactUpsertArgs} args - Arguments to update or create a JournalFact.
     * @example
     * // Update or create a JournalFact
     * const journalFact = await prisma.journalFact.upsert({
     *   create: {
     *     // ... data to create a JournalFact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalFact we want to update
     *   }
     * })
     */
    upsert<T extends JournalFactUpsertArgs>(args: SelectSubset<T, JournalFactUpsertArgs<ExtArgs>>): Prisma__JournalFactClient<$Result.GetResult<Prisma.$JournalFactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactCountArgs} args - Arguments to filter JournalFacts to count.
     * @example
     * // Count the number of JournalFacts
     * const count = await prisma.journalFact.count({
     *   where: {
     *     // ... the filter for the JournalFacts we want to count
     *   }
     * })
    **/
    count<T extends JournalFactCountArgs>(
      args?: Subset<T, JournalFactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalFactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalFactAggregateArgs>(args: Subset<T, JournalFactAggregateArgs>): Prisma.PrismaPromise<GetJournalFactAggregateType<T>>

    /**
     * Group by JournalFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalFactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalFactGroupByArgs['orderBy'] }
        : { orderBy?: JournalFactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalFactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalFactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalFact model
   */
  readonly fields: JournalFactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalFact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalFactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dreamEntry<T extends DreamEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DreamEntryDefaultArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalFact model
   */
  interface JournalFactFieldRefs {
    readonly id: FieldRef<"JournalFact", 'String'>
    readonly dreamEntryId: FieldRef<"JournalFact", 'String'>
    readonly factType: FieldRef<"JournalFact", 'String'>
    readonly value: FieldRef<"JournalFact", 'Json'>
    readonly confidence: FieldRef<"JournalFact", 'Float'>
    readonly ontologyVersion: FieldRef<"JournalFact", 'Int'>
    readonly modelVersion: FieldRef<"JournalFact", 'String'>
    readonly promptVersion: FieldRef<"JournalFact", 'Int'>
    readonly startIndex: FieldRef<"JournalFact", 'Int'>
    readonly endIndex: FieldRef<"JournalFact", 'Int'>
    readonly extractedAt: FieldRef<"JournalFact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalFact findUnique
   */
  export type JournalFactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter, which JournalFact to fetch.
     */
    where: JournalFactWhereUniqueInput
  }

  /**
   * JournalFact findUniqueOrThrow
   */
  export type JournalFactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter, which JournalFact to fetch.
     */
    where: JournalFactWhereUniqueInput
  }

  /**
   * JournalFact findFirst
   */
  export type JournalFactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter, which JournalFact to fetch.
     */
    where?: JournalFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFacts to fetch.
     */
    orderBy?: JournalFactOrderByWithRelationInput | JournalFactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFacts.
     */
    cursor?: JournalFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFacts.
     */
    distinct?: JournalFactScalarFieldEnum | JournalFactScalarFieldEnum[]
  }

  /**
   * JournalFact findFirstOrThrow
   */
  export type JournalFactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter, which JournalFact to fetch.
     */
    where?: JournalFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFacts to fetch.
     */
    orderBy?: JournalFactOrderByWithRelationInput | JournalFactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFacts.
     */
    cursor?: JournalFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFacts.
     */
    distinct?: JournalFactScalarFieldEnum | JournalFactScalarFieldEnum[]
  }

  /**
   * JournalFact findMany
   */
  export type JournalFactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter, which JournalFacts to fetch.
     */
    where?: JournalFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFacts to fetch.
     */
    orderBy?: JournalFactOrderByWithRelationInput | JournalFactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalFacts.
     */
    cursor?: JournalFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFacts.
     */
    skip?: number
    distinct?: JournalFactScalarFieldEnum | JournalFactScalarFieldEnum[]
  }

  /**
   * JournalFact create
   */
  export type JournalFactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalFact.
     */
    data: XOR<JournalFactCreateInput, JournalFactUncheckedCreateInput>
  }

  /**
   * JournalFact createMany
   */
  export type JournalFactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalFacts.
     */
    data: JournalFactCreateManyInput | JournalFactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalFact createManyAndReturn
   */
  export type JournalFactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * The data used to create many JournalFacts.
     */
    data: JournalFactCreateManyInput | JournalFactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFact update
   */
  export type JournalFactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalFact.
     */
    data: XOR<JournalFactUpdateInput, JournalFactUncheckedUpdateInput>
    /**
     * Choose, which JournalFact to update.
     */
    where: JournalFactWhereUniqueInput
  }

  /**
   * JournalFact updateMany
   */
  export type JournalFactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalFacts.
     */
    data: XOR<JournalFactUpdateManyMutationInput, JournalFactUncheckedUpdateManyInput>
    /**
     * Filter which JournalFacts to update
     */
    where?: JournalFactWhereInput
    /**
     * Limit how many JournalFacts to update.
     */
    limit?: number
  }

  /**
   * JournalFact updateManyAndReturn
   */
  export type JournalFactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * The data used to update JournalFacts.
     */
    data: XOR<JournalFactUpdateManyMutationInput, JournalFactUncheckedUpdateManyInput>
    /**
     * Filter which JournalFacts to update
     */
    where?: JournalFactWhereInput
    /**
     * Limit how many JournalFacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFact upsert
   */
  export type JournalFactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalFact to update in case it exists.
     */
    where: JournalFactWhereUniqueInput
    /**
     * In case the JournalFact found by the `where` argument doesn't exist, create a new JournalFact with this data.
     */
    create: XOR<JournalFactCreateInput, JournalFactUncheckedCreateInput>
    /**
     * In case the JournalFact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalFactUpdateInput, JournalFactUncheckedUpdateInput>
  }

  /**
   * JournalFact delete
   */
  export type JournalFactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
    /**
     * Filter which JournalFact to delete.
     */
    where: JournalFactWhereUniqueInput
  }

  /**
   * JournalFact deleteMany
   */
  export type JournalFactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFacts to delete
     */
    where?: JournalFactWhereInput
    /**
     * Limit how many JournalFacts to delete.
     */
    limit?: number
  }

  /**
   * JournalFact without action
   */
  export type JournalFactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFact
     */
    select?: JournalFactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFact
     */
    omit?: JournalFactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFactInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    taxonomyVersion: number | null
    usageCount: number | null
  }

  export type TagSumAggregateOutputType = {
    taxonomyVersion: number | null
    usageCount: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    taxonomyId: string | null
    taxonomyVersion: number | null
    usageCount: number | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    taxonomyId: string | null
    taxonomyVersion: number | null
    usageCount: number | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    category: number
    taxonomyId: number
    taxonomyVersion: number
    usageCount: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    taxonomyVersion?: true
    usageCount?: true
  }

  export type TagSumAggregateInputType = {
    taxonomyVersion?: true
    usageCount?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    taxonomyId?: true
    taxonomyVersion?: true
    usageCount?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    taxonomyId?: true
    taxonomyVersion?: true
    usageCount?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    taxonomyId?: true
    taxonomyVersion?: true
    usageCount?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    category: string
    taxonomyId: string | null
    taxonomyVersion: number | null
    usageCount: number
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    taxonomyId?: boolean
    taxonomyVersion?: boolean
    usageCount?: boolean
    dreamTags?: boolean | Tag$dreamTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    taxonomyId?: boolean
    taxonomyVersion?: boolean
    usageCount?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    taxonomyId?: boolean
    taxonomyVersion?: boolean
    usageCount?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    taxonomyId?: boolean
    taxonomyVersion?: boolean
    usageCount?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "category" | "taxonomyId" | "taxonomyVersion" | "usageCount", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamTags?: boolean | Tag$dreamTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      dreamTags: Prisma.$DreamTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      category: string
      taxonomyId: string | null
      taxonomyVersion: number | null
      usageCount: number
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dreamTags<T extends Tag$dreamTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$dreamTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly category: FieldRef<"Tag", 'String'>
    readonly taxonomyId: FieldRef<"Tag", 'String'>
    readonly taxonomyVersion: FieldRef<"Tag", 'Int'>
    readonly usageCount: FieldRef<"Tag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.dreamTags
   */
  export type Tag$dreamTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    where?: DreamTagWhereInput
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    cursor?: DreamTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DreamTagScalarFieldEnum | DreamTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model DreamTag
   */

  export type AggregateDreamTag = {
    _count: DreamTagCountAggregateOutputType | null
    _min: DreamTagMinAggregateOutputType | null
    _max: DreamTagMaxAggregateOutputType | null
  }

  export type DreamTagMinAggregateOutputType = {
    id: string | null
    dreamEntryId: string | null
    tagId: string | null
    source: string | null
    createdAt: Date | null
  }

  export type DreamTagMaxAggregateOutputType = {
    id: string | null
    dreamEntryId: string | null
    tagId: string | null
    source: string | null
    createdAt: Date | null
  }

  export type DreamTagCountAggregateOutputType = {
    id: number
    dreamEntryId: number
    tagId: number
    source: number
    createdAt: number
    _all: number
  }


  export type DreamTagMinAggregateInputType = {
    id?: true
    dreamEntryId?: true
    tagId?: true
    source?: true
    createdAt?: true
  }

  export type DreamTagMaxAggregateInputType = {
    id?: true
    dreamEntryId?: true
    tagId?: true
    source?: true
    createdAt?: true
  }

  export type DreamTagCountAggregateInputType = {
    id?: true
    dreamEntryId?: true
    tagId?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type DreamTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamTag to aggregate.
     */
    where?: DreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamTags to fetch.
     */
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DreamTags
    **/
    _count?: true | DreamTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DreamTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DreamTagMaxAggregateInputType
  }

  export type GetDreamTagAggregateType<T extends DreamTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDreamTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDreamTag[P]>
      : GetScalarType<T[P], AggregateDreamTag[P]>
  }




  export type DreamTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamTagWhereInput
    orderBy?: DreamTagOrderByWithAggregationInput | DreamTagOrderByWithAggregationInput[]
    by: DreamTagScalarFieldEnum[] | DreamTagScalarFieldEnum
    having?: DreamTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DreamTagCountAggregateInputType | true
    _min?: DreamTagMinAggregateInputType
    _max?: DreamTagMaxAggregateInputType
  }

  export type DreamTagGroupByOutputType = {
    id: string
    dreamEntryId: string
    tagId: string
    source: string
    createdAt: Date
    _count: DreamTagCountAggregateOutputType | null
    _min: DreamTagMinAggregateOutputType | null
    _max: DreamTagMaxAggregateOutputType | null
  }

  type GetDreamTagGroupByPayload<T extends DreamTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DreamTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DreamTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DreamTagGroupByOutputType[P]>
            : GetScalarType<T[P], DreamTagGroupByOutputType[P]>
        }
      >
    >


  export type DreamTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    tagId?: boolean
    source?: boolean
    createdAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamTag"]>

  export type DreamTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    tagId?: boolean
    source?: boolean
    createdAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamTag"]>

  export type DreamTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dreamEntryId?: boolean
    tagId?: boolean
    source?: boolean
    createdAt?: boolean
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamTag"]>

  export type DreamTagSelectScalar = {
    id?: boolean
    dreamEntryId?: boolean
    tagId?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type DreamTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dreamEntryId" | "tagId" | "source" | "createdAt", ExtArgs["result"]["dreamTag"]>
  export type DreamTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DreamTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DreamTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dreamEntry?: boolean | DreamEntryDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $DreamTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DreamTag"
    objects: {
      dreamEntry: Prisma.$DreamEntryPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dreamEntryId: string
      tagId: string
      source: string
      createdAt: Date
    }, ExtArgs["result"]["dreamTag"]>
    composites: {}
  }

  type DreamTagGetPayload<S extends boolean | null | undefined | DreamTagDefaultArgs> = $Result.GetResult<Prisma.$DreamTagPayload, S>

  type DreamTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DreamTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DreamTagCountAggregateInputType | true
    }

  export interface DreamTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DreamTag'], meta: { name: 'DreamTag' } }
    /**
     * Find zero or one DreamTag that matches the filter.
     * @param {DreamTagFindUniqueArgs} args - Arguments to find a DreamTag
     * @example
     * // Get one DreamTag
     * const dreamTag = await prisma.dreamTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DreamTagFindUniqueArgs>(args: SelectSubset<T, DreamTagFindUniqueArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DreamTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DreamTagFindUniqueOrThrowArgs} args - Arguments to find a DreamTag
     * @example
     * // Get one DreamTag
     * const dreamTag = await prisma.dreamTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DreamTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DreamTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagFindFirstArgs} args - Arguments to find a DreamTag
     * @example
     * // Get one DreamTag
     * const dreamTag = await prisma.dreamTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DreamTagFindFirstArgs>(args?: SelectSubset<T, DreamTagFindFirstArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagFindFirstOrThrowArgs} args - Arguments to find a DreamTag
     * @example
     * // Get one DreamTag
     * const dreamTag = await prisma.dreamTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DreamTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DreamTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DreamTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DreamTags
     * const dreamTags = await prisma.dreamTag.findMany()
     * 
     * // Get first 10 DreamTags
     * const dreamTags = await prisma.dreamTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dreamTagWithIdOnly = await prisma.dreamTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DreamTagFindManyArgs>(args?: SelectSubset<T, DreamTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DreamTag.
     * @param {DreamTagCreateArgs} args - Arguments to create a DreamTag.
     * @example
     * // Create one DreamTag
     * const DreamTag = await prisma.dreamTag.create({
     *   data: {
     *     // ... data to create a DreamTag
     *   }
     * })
     * 
     */
    create<T extends DreamTagCreateArgs>(args: SelectSubset<T, DreamTagCreateArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DreamTags.
     * @param {DreamTagCreateManyArgs} args - Arguments to create many DreamTags.
     * @example
     * // Create many DreamTags
     * const dreamTag = await prisma.dreamTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DreamTagCreateManyArgs>(args?: SelectSubset<T, DreamTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DreamTags and returns the data saved in the database.
     * @param {DreamTagCreateManyAndReturnArgs} args - Arguments to create many DreamTags.
     * @example
     * // Create many DreamTags
     * const dreamTag = await prisma.dreamTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DreamTags and only return the `id`
     * const dreamTagWithIdOnly = await prisma.dreamTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DreamTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DreamTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DreamTag.
     * @param {DreamTagDeleteArgs} args - Arguments to delete one DreamTag.
     * @example
     * // Delete one DreamTag
     * const DreamTag = await prisma.dreamTag.delete({
     *   where: {
     *     // ... filter to delete one DreamTag
     *   }
     * })
     * 
     */
    delete<T extends DreamTagDeleteArgs>(args: SelectSubset<T, DreamTagDeleteArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DreamTag.
     * @param {DreamTagUpdateArgs} args - Arguments to update one DreamTag.
     * @example
     * // Update one DreamTag
     * const dreamTag = await prisma.dreamTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DreamTagUpdateArgs>(args: SelectSubset<T, DreamTagUpdateArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DreamTags.
     * @param {DreamTagDeleteManyArgs} args - Arguments to filter DreamTags to delete.
     * @example
     * // Delete a few DreamTags
     * const { count } = await prisma.dreamTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DreamTagDeleteManyArgs>(args?: SelectSubset<T, DreamTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DreamTags
     * const dreamTag = await prisma.dreamTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DreamTagUpdateManyArgs>(args: SelectSubset<T, DreamTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamTags and returns the data updated in the database.
     * @param {DreamTagUpdateManyAndReturnArgs} args - Arguments to update many DreamTags.
     * @example
     * // Update many DreamTags
     * const dreamTag = await prisma.dreamTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DreamTags and only return the `id`
     * const dreamTagWithIdOnly = await prisma.dreamTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DreamTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DreamTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DreamTag.
     * @param {DreamTagUpsertArgs} args - Arguments to update or create a DreamTag.
     * @example
     * // Update or create a DreamTag
     * const dreamTag = await prisma.dreamTag.upsert({
     *   create: {
     *     // ... data to create a DreamTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DreamTag we want to update
     *   }
     * })
     */
    upsert<T extends DreamTagUpsertArgs>(args: SelectSubset<T, DreamTagUpsertArgs<ExtArgs>>): Prisma__DreamTagClient<$Result.GetResult<Prisma.$DreamTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DreamTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagCountArgs} args - Arguments to filter DreamTags to count.
     * @example
     * // Count the number of DreamTags
     * const count = await prisma.dreamTag.count({
     *   where: {
     *     // ... the filter for the DreamTags we want to count
     *   }
     * })
    **/
    count<T extends DreamTagCountArgs>(
      args?: Subset<T, DreamTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DreamTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DreamTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DreamTagAggregateArgs>(args: Subset<T, DreamTagAggregateArgs>): Prisma.PrismaPromise<GetDreamTagAggregateType<T>>

    /**
     * Group by DreamTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DreamTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DreamTagGroupByArgs['orderBy'] }
        : { orderBy?: DreamTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DreamTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDreamTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DreamTag model
   */
  readonly fields: DreamTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DreamTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DreamTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dreamEntry<T extends DreamEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DreamEntryDefaultArgs<ExtArgs>>): Prisma__DreamEntryClient<$Result.GetResult<Prisma.$DreamEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DreamTag model
   */
  interface DreamTagFieldRefs {
    readonly id: FieldRef<"DreamTag", 'String'>
    readonly dreamEntryId: FieldRef<"DreamTag", 'String'>
    readonly tagId: FieldRef<"DreamTag", 'String'>
    readonly source: FieldRef<"DreamTag", 'String'>
    readonly createdAt: FieldRef<"DreamTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DreamTag findUnique
   */
  export type DreamTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter, which DreamTag to fetch.
     */
    where: DreamTagWhereUniqueInput
  }

  /**
   * DreamTag findUniqueOrThrow
   */
  export type DreamTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter, which DreamTag to fetch.
     */
    where: DreamTagWhereUniqueInput
  }

  /**
   * DreamTag findFirst
   */
  export type DreamTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter, which DreamTag to fetch.
     */
    where?: DreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamTags to fetch.
     */
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamTags.
     */
    cursor?: DreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamTags.
     */
    distinct?: DreamTagScalarFieldEnum | DreamTagScalarFieldEnum[]
  }

  /**
   * DreamTag findFirstOrThrow
   */
  export type DreamTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter, which DreamTag to fetch.
     */
    where?: DreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamTags to fetch.
     */
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamTags.
     */
    cursor?: DreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamTags.
     */
    distinct?: DreamTagScalarFieldEnum | DreamTagScalarFieldEnum[]
  }

  /**
   * DreamTag findMany
   */
  export type DreamTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter, which DreamTags to fetch.
     */
    where?: DreamTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamTags to fetch.
     */
    orderBy?: DreamTagOrderByWithRelationInput | DreamTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DreamTags.
     */
    cursor?: DreamTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamTags.
     */
    skip?: number
    distinct?: DreamTagScalarFieldEnum | DreamTagScalarFieldEnum[]
  }

  /**
   * DreamTag create
   */
  export type DreamTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DreamTag.
     */
    data: XOR<DreamTagCreateInput, DreamTagUncheckedCreateInput>
  }

  /**
   * DreamTag createMany
   */
  export type DreamTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DreamTags.
     */
    data: DreamTagCreateManyInput | DreamTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DreamTag createManyAndReturn
   */
  export type DreamTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * The data used to create many DreamTags.
     */
    data: DreamTagCreateManyInput | DreamTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamTag update
   */
  export type DreamTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DreamTag.
     */
    data: XOR<DreamTagUpdateInput, DreamTagUncheckedUpdateInput>
    /**
     * Choose, which DreamTag to update.
     */
    where: DreamTagWhereUniqueInput
  }

  /**
   * DreamTag updateMany
   */
  export type DreamTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DreamTags.
     */
    data: XOR<DreamTagUpdateManyMutationInput, DreamTagUncheckedUpdateManyInput>
    /**
     * Filter which DreamTags to update
     */
    where?: DreamTagWhereInput
    /**
     * Limit how many DreamTags to update.
     */
    limit?: number
  }

  /**
   * DreamTag updateManyAndReturn
   */
  export type DreamTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * The data used to update DreamTags.
     */
    data: XOR<DreamTagUpdateManyMutationInput, DreamTagUncheckedUpdateManyInput>
    /**
     * Filter which DreamTags to update
     */
    where?: DreamTagWhereInput
    /**
     * Limit how many DreamTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamTag upsert
   */
  export type DreamTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DreamTag to update in case it exists.
     */
    where: DreamTagWhereUniqueInput
    /**
     * In case the DreamTag found by the `where` argument doesn't exist, create a new DreamTag with this data.
     */
    create: XOR<DreamTagCreateInput, DreamTagUncheckedCreateInput>
    /**
     * In case the DreamTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DreamTagUpdateInput, DreamTagUncheckedUpdateInput>
  }

  /**
   * DreamTag delete
   */
  export type DreamTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
    /**
     * Filter which DreamTag to delete.
     */
    where: DreamTagWhereUniqueInput
  }

  /**
   * DreamTag deleteMany
   */
  export type DreamTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamTags to delete
     */
    where?: DreamTagWhereInput
    /**
     * Limit how many DreamTags to delete.
     */
    limit?: number
  }

  /**
   * DreamTag without action
   */
  export type DreamTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamTag
     */
    select?: DreamTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamTag
     */
    omit?: DreamTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamTagInclude<ExtArgs> | null
  }


  /**
   * Model CensusInstrument
   */

  export type AggregateCensusInstrument = {
    _count: CensusInstrumentCountAggregateOutputType | null
    _avg: CensusInstrumentAvgAggregateOutputType | null
    _sum: CensusInstrumentSumAggregateOutputType | null
    _min: CensusInstrumentMinAggregateOutputType | null
    _max: CensusInstrumentMaxAggregateOutputType | null
  }

  export type CensusInstrumentAvgAggregateOutputType = {
    version: number | null
    sortOrder: number | null
  }

  export type CensusInstrumentSumAggregateOutputType = {
    version: number | null
    sortOrder: number | null
  }

  export type CensusInstrumentMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    isRequired: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CensusInstrumentMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    isRequired: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CensusInstrumentCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    version: number
    isActive: number
    isRequired: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CensusInstrumentAvgAggregateInputType = {
    version?: true
    sortOrder?: true
  }

  export type CensusInstrumentSumAggregateInputType = {
    version?: true
    sortOrder?: true
  }

  export type CensusInstrumentMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    isRequired?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CensusInstrumentMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    isRequired?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CensusInstrumentCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    isRequired?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CensusInstrumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusInstrument to aggregate.
     */
    where?: CensusInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusInstruments to fetch.
     */
    orderBy?: CensusInstrumentOrderByWithRelationInput | CensusInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusInstruments
    **/
    _count?: true | CensusInstrumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusInstrumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusInstrumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusInstrumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusInstrumentMaxAggregateInputType
  }

  export type GetCensusInstrumentAggregateType<T extends CensusInstrumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusInstrument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusInstrument[P]>
      : GetScalarType<T[P], AggregateCensusInstrument[P]>
  }




  export type CensusInstrumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusInstrumentWhereInput
    orderBy?: CensusInstrumentOrderByWithAggregationInput | CensusInstrumentOrderByWithAggregationInput[]
    by: CensusInstrumentScalarFieldEnum[] | CensusInstrumentScalarFieldEnum
    having?: CensusInstrumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusInstrumentCountAggregateInputType | true
    _avg?: CensusInstrumentAvgAggregateInputType
    _sum?: CensusInstrumentSumAggregateInputType
    _min?: CensusInstrumentMinAggregateInputType
    _max?: CensusInstrumentMaxAggregateInputType
  }

  export type CensusInstrumentGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    version: number
    isActive: boolean
    isRequired: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CensusInstrumentCountAggregateOutputType | null
    _avg: CensusInstrumentAvgAggregateOutputType | null
    _sum: CensusInstrumentSumAggregateOutputType | null
    _min: CensusInstrumentMinAggregateOutputType | null
    _max: CensusInstrumentMaxAggregateOutputType | null
  }

  type GetCensusInstrumentGroupByPayload<T extends CensusInstrumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusInstrumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusInstrumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusInstrumentGroupByOutputType[P]>
            : GetScalarType<T[P], CensusInstrumentGroupByOutputType[P]>
        }
      >
    >


  export type CensusInstrumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sections?: boolean | CensusInstrument$sectionsArgs<ExtArgs>
    _count?: boolean | CensusInstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusInstrument"]>

  export type CensusInstrumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["censusInstrument"]>

  export type CensusInstrumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["censusInstrument"]>

  export type CensusInstrumentSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CensusInstrumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "version" | "isActive" | "isRequired" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["censusInstrument"]>
  export type CensusInstrumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | CensusInstrument$sectionsArgs<ExtArgs>
    _count?: boolean | CensusInstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CensusInstrumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CensusInstrumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CensusInstrumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusInstrument"
    objects: {
      sections: Prisma.$CensusSectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      version: number
      isActive: boolean
      isRequired: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["censusInstrument"]>
    composites: {}
  }

  type CensusInstrumentGetPayload<S extends boolean | null | undefined | CensusInstrumentDefaultArgs> = $Result.GetResult<Prisma.$CensusInstrumentPayload, S>

  type CensusInstrumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusInstrumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusInstrumentCountAggregateInputType | true
    }

  export interface CensusInstrumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusInstrument'], meta: { name: 'CensusInstrument' } }
    /**
     * Find zero or one CensusInstrument that matches the filter.
     * @param {CensusInstrumentFindUniqueArgs} args - Arguments to find a CensusInstrument
     * @example
     * // Get one CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusInstrumentFindUniqueArgs>(args: SelectSubset<T, CensusInstrumentFindUniqueArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusInstrument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusInstrumentFindUniqueOrThrowArgs} args - Arguments to find a CensusInstrument
     * @example
     * // Get one CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusInstrumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusInstrumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusInstrument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentFindFirstArgs} args - Arguments to find a CensusInstrument
     * @example
     * // Get one CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusInstrumentFindFirstArgs>(args?: SelectSubset<T, CensusInstrumentFindFirstArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusInstrument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentFindFirstOrThrowArgs} args - Arguments to find a CensusInstrument
     * @example
     * // Get one CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusInstrumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusInstrumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusInstruments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusInstruments
     * const censusInstruments = await prisma.censusInstrument.findMany()
     * 
     * // Get first 10 CensusInstruments
     * const censusInstruments = await prisma.censusInstrument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusInstrumentWithIdOnly = await prisma.censusInstrument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusInstrumentFindManyArgs>(args?: SelectSubset<T, CensusInstrumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusInstrument.
     * @param {CensusInstrumentCreateArgs} args - Arguments to create a CensusInstrument.
     * @example
     * // Create one CensusInstrument
     * const CensusInstrument = await prisma.censusInstrument.create({
     *   data: {
     *     // ... data to create a CensusInstrument
     *   }
     * })
     * 
     */
    create<T extends CensusInstrumentCreateArgs>(args: SelectSubset<T, CensusInstrumentCreateArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusInstruments.
     * @param {CensusInstrumentCreateManyArgs} args - Arguments to create many CensusInstruments.
     * @example
     * // Create many CensusInstruments
     * const censusInstrument = await prisma.censusInstrument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusInstrumentCreateManyArgs>(args?: SelectSubset<T, CensusInstrumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusInstruments and returns the data saved in the database.
     * @param {CensusInstrumentCreateManyAndReturnArgs} args - Arguments to create many CensusInstruments.
     * @example
     * // Create many CensusInstruments
     * const censusInstrument = await prisma.censusInstrument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusInstruments and only return the `id`
     * const censusInstrumentWithIdOnly = await prisma.censusInstrument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusInstrumentCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusInstrumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusInstrument.
     * @param {CensusInstrumentDeleteArgs} args - Arguments to delete one CensusInstrument.
     * @example
     * // Delete one CensusInstrument
     * const CensusInstrument = await prisma.censusInstrument.delete({
     *   where: {
     *     // ... filter to delete one CensusInstrument
     *   }
     * })
     * 
     */
    delete<T extends CensusInstrumentDeleteArgs>(args: SelectSubset<T, CensusInstrumentDeleteArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusInstrument.
     * @param {CensusInstrumentUpdateArgs} args - Arguments to update one CensusInstrument.
     * @example
     * // Update one CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusInstrumentUpdateArgs>(args: SelectSubset<T, CensusInstrumentUpdateArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusInstruments.
     * @param {CensusInstrumentDeleteManyArgs} args - Arguments to filter CensusInstruments to delete.
     * @example
     * // Delete a few CensusInstruments
     * const { count } = await prisma.censusInstrument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusInstrumentDeleteManyArgs>(args?: SelectSubset<T, CensusInstrumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusInstruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusInstruments
     * const censusInstrument = await prisma.censusInstrument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusInstrumentUpdateManyArgs>(args: SelectSubset<T, CensusInstrumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusInstruments and returns the data updated in the database.
     * @param {CensusInstrumentUpdateManyAndReturnArgs} args - Arguments to update many CensusInstruments.
     * @example
     * // Update many CensusInstruments
     * const censusInstrument = await prisma.censusInstrument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusInstruments and only return the `id`
     * const censusInstrumentWithIdOnly = await prisma.censusInstrument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusInstrumentUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusInstrumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusInstrument.
     * @param {CensusInstrumentUpsertArgs} args - Arguments to update or create a CensusInstrument.
     * @example
     * // Update or create a CensusInstrument
     * const censusInstrument = await prisma.censusInstrument.upsert({
     *   create: {
     *     // ... data to create a CensusInstrument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusInstrument we want to update
     *   }
     * })
     */
    upsert<T extends CensusInstrumentUpsertArgs>(args: SelectSubset<T, CensusInstrumentUpsertArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusInstruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentCountArgs} args - Arguments to filter CensusInstruments to count.
     * @example
     * // Count the number of CensusInstruments
     * const count = await prisma.censusInstrument.count({
     *   where: {
     *     // ... the filter for the CensusInstruments we want to count
     *   }
     * })
    **/
    count<T extends CensusInstrumentCountArgs>(
      args?: Subset<T, CensusInstrumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusInstrumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusInstrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusInstrumentAggregateArgs>(args: Subset<T, CensusInstrumentAggregateArgs>): Prisma.PrismaPromise<GetCensusInstrumentAggregateType<T>>

    /**
     * Group by CensusInstrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusInstrumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusInstrumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusInstrumentGroupByArgs['orderBy'] }
        : { orderBy?: CensusInstrumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusInstrumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusInstrumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusInstrument model
   */
  readonly fields: CensusInstrumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusInstrument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusInstrumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sections<T extends CensusInstrument$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, CensusInstrument$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusInstrument model
   */
  interface CensusInstrumentFieldRefs {
    readonly id: FieldRef<"CensusInstrument", 'String'>
    readonly slug: FieldRef<"CensusInstrument", 'String'>
    readonly name: FieldRef<"CensusInstrument", 'String'>
    readonly description: FieldRef<"CensusInstrument", 'String'>
    readonly version: FieldRef<"CensusInstrument", 'Int'>
    readonly isActive: FieldRef<"CensusInstrument", 'Boolean'>
    readonly isRequired: FieldRef<"CensusInstrument", 'Boolean'>
    readonly sortOrder: FieldRef<"CensusInstrument", 'Int'>
    readonly createdAt: FieldRef<"CensusInstrument", 'DateTime'>
    readonly updatedAt: FieldRef<"CensusInstrument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CensusInstrument findUnique
   */
  export type CensusInstrumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which CensusInstrument to fetch.
     */
    where: CensusInstrumentWhereUniqueInput
  }

  /**
   * CensusInstrument findUniqueOrThrow
   */
  export type CensusInstrumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which CensusInstrument to fetch.
     */
    where: CensusInstrumentWhereUniqueInput
  }

  /**
   * CensusInstrument findFirst
   */
  export type CensusInstrumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which CensusInstrument to fetch.
     */
    where?: CensusInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusInstruments to fetch.
     */
    orderBy?: CensusInstrumentOrderByWithRelationInput | CensusInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusInstruments.
     */
    cursor?: CensusInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusInstruments.
     */
    distinct?: CensusInstrumentScalarFieldEnum | CensusInstrumentScalarFieldEnum[]
  }

  /**
   * CensusInstrument findFirstOrThrow
   */
  export type CensusInstrumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which CensusInstrument to fetch.
     */
    where?: CensusInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusInstruments to fetch.
     */
    orderBy?: CensusInstrumentOrderByWithRelationInput | CensusInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusInstruments.
     */
    cursor?: CensusInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusInstruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusInstruments.
     */
    distinct?: CensusInstrumentScalarFieldEnum | CensusInstrumentScalarFieldEnum[]
  }

  /**
   * CensusInstrument findMany
   */
  export type CensusInstrumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter, which CensusInstruments to fetch.
     */
    where?: CensusInstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusInstruments to fetch.
     */
    orderBy?: CensusInstrumentOrderByWithRelationInput | CensusInstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusInstruments.
     */
    cursor?: CensusInstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusInstruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusInstruments.
     */
    skip?: number
    distinct?: CensusInstrumentScalarFieldEnum | CensusInstrumentScalarFieldEnum[]
  }

  /**
   * CensusInstrument create
   */
  export type CensusInstrumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CensusInstrument.
     */
    data: XOR<CensusInstrumentCreateInput, CensusInstrumentUncheckedCreateInput>
  }

  /**
   * CensusInstrument createMany
   */
  export type CensusInstrumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusInstruments.
     */
    data: CensusInstrumentCreateManyInput | CensusInstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusInstrument createManyAndReturn
   */
  export type CensusInstrumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * The data used to create many CensusInstruments.
     */
    data: CensusInstrumentCreateManyInput | CensusInstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusInstrument update
   */
  export type CensusInstrumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CensusInstrument.
     */
    data: XOR<CensusInstrumentUpdateInput, CensusInstrumentUncheckedUpdateInput>
    /**
     * Choose, which CensusInstrument to update.
     */
    where: CensusInstrumentWhereUniqueInput
  }

  /**
   * CensusInstrument updateMany
   */
  export type CensusInstrumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusInstruments.
     */
    data: XOR<CensusInstrumentUpdateManyMutationInput, CensusInstrumentUncheckedUpdateManyInput>
    /**
     * Filter which CensusInstruments to update
     */
    where?: CensusInstrumentWhereInput
    /**
     * Limit how many CensusInstruments to update.
     */
    limit?: number
  }

  /**
   * CensusInstrument updateManyAndReturn
   */
  export type CensusInstrumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * The data used to update CensusInstruments.
     */
    data: XOR<CensusInstrumentUpdateManyMutationInput, CensusInstrumentUncheckedUpdateManyInput>
    /**
     * Filter which CensusInstruments to update
     */
    where?: CensusInstrumentWhereInput
    /**
     * Limit how many CensusInstruments to update.
     */
    limit?: number
  }

  /**
   * CensusInstrument upsert
   */
  export type CensusInstrumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CensusInstrument to update in case it exists.
     */
    where: CensusInstrumentWhereUniqueInput
    /**
     * In case the CensusInstrument found by the `where` argument doesn't exist, create a new CensusInstrument with this data.
     */
    create: XOR<CensusInstrumentCreateInput, CensusInstrumentUncheckedCreateInput>
    /**
     * In case the CensusInstrument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusInstrumentUpdateInput, CensusInstrumentUncheckedUpdateInput>
  }

  /**
   * CensusInstrument delete
   */
  export type CensusInstrumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
    /**
     * Filter which CensusInstrument to delete.
     */
    where: CensusInstrumentWhereUniqueInput
  }

  /**
   * CensusInstrument deleteMany
   */
  export type CensusInstrumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusInstruments to delete
     */
    where?: CensusInstrumentWhereInput
    /**
     * Limit how many CensusInstruments to delete.
     */
    limit?: number
  }

  /**
   * CensusInstrument.sections
   */
  export type CensusInstrument$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    where?: CensusSectionWhereInput
    orderBy?: CensusSectionOrderByWithRelationInput | CensusSectionOrderByWithRelationInput[]
    cursor?: CensusSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusSectionScalarFieldEnum | CensusSectionScalarFieldEnum[]
  }

  /**
   * CensusInstrument without action
   */
  export type CensusInstrumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusInstrument
     */
    select?: CensusInstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusInstrument
     */
    omit?: CensusInstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusInstrumentInclude<ExtArgs> | null
  }


  /**
   * Model CensusSection
   */

  export type AggregateCensusSection = {
    _count: CensusSectionCountAggregateOutputType | null
    _avg: CensusSectionAvgAggregateOutputType | null
    _sum: CensusSectionSumAggregateOutputType | null
    _min: CensusSectionMinAggregateOutputType | null
    _max: CensusSectionMaxAggregateOutputType | null
  }

  export type CensusSectionAvgAggregateOutputType = {
    sortOrder: number | null
    estimatedTime: number | null
  }

  export type CensusSectionSumAggregateOutputType = {
    sortOrder: number | null
    estimatedTime: number | null
  }

  export type CensusSectionMinAggregateOutputType = {
    id: string | null
    instrumentId: string | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    sortOrder: number | null
    estimatedTime: number | null
  }

  export type CensusSectionMaxAggregateOutputType = {
    id: string | null
    instrumentId: string | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    sortOrder: number | null
    estimatedTime: number | null
  }

  export type CensusSectionCountAggregateOutputType = {
    id: number
    instrumentId: number
    slug: number
    name: number
    description: number
    icon: number
    sortOrder: number
    estimatedTime: number
    _all: number
  }


  export type CensusSectionAvgAggregateInputType = {
    sortOrder?: true
    estimatedTime?: true
  }

  export type CensusSectionSumAggregateInputType = {
    sortOrder?: true
    estimatedTime?: true
  }

  export type CensusSectionMinAggregateInputType = {
    id?: true
    instrumentId?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    estimatedTime?: true
  }

  export type CensusSectionMaxAggregateInputType = {
    id?: true
    instrumentId?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    estimatedTime?: true
  }

  export type CensusSectionCountAggregateInputType = {
    id?: true
    instrumentId?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    estimatedTime?: true
    _all?: true
  }

  export type CensusSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusSection to aggregate.
     */
    where?: CensusSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusSections to fetch.
     */
    orderBy?: CensusSectionOrderByWithRelationInput | CensusSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusSections
    **/
    _count?: true | CensusSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusSectionMaxAggregateInputType
  }

  export type GetCensusSectionAggregateType<T extends CensusSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusSection[P]>
      : GetScalarType<T[P], AggregateCensusSection[P]>
  }




  export type CensusSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusSectionWhereInput
    orderBy?: CensusSectionOrderByWithAggregationInput | CensusSectionOrderByWithAggregationInput[]
    by: CensusSectionScalarFieldEnum[] | CensusSectionScalarFieldEnum
    having?: CensusSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusSectionCountAggregateInputType | true
    _avg?: CensusSectionAvgAggregateInputType
    _sum?: CensusSectionSumAggregateInputType
    _min?: CensusSectionMinAggregateInputType
    _max?: CensusSectionMaxAggregateInputType
  }

  export type CensusSectionGroupByOutputType = {
    id: string
    instrumentId: string
    slug: string
    name: string
    description: string | null
    icon: string | null
    sortOrder: number
    estimatedTime: number
    _count: CensusSectionCountAggregateOutputType | null
    _avg: CensusSectionAvgAggregateOutputType | null
    _sum: CensusSectionSumAggregateOutputType | null
    _min: CensusSectionMinAggregateOutputType | null
    _max: CensusSectionMaxAggregateOutputType | null
  }

  type GetCensusSectionGroupByPayload<T extends CensusSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusSectionGroupByOutputType[P]>
            : GetScalarType<T[P], CensusSectionGroupByOutputType[P]>
        }
      >
    >


  export type CensusSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    estimatedTime?: boolean
    questions?: boolean | CensusSection$questionsArgs<ExtArgs>
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
    _count?: boolean | CensusSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusSection"]>

  export type CensusSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    estimatedTime?: boolean
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusSection"]>

  export type CensusSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrumentId?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    estimatedTime?: boolean
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusSection"]>

  export type CensusSectionSelectScalar = {
    id?: boolean
    instrumentId?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    estimatedTime?: boolean
  }

  export type CensusSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instrumentId" | "slug" | "name" | "description" | "icon" | "sortOrder" | "estimatedTime", ExtArgs["result"]["censusSection"]>
  export type CensusSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CensusSection$questionsArgs<ExtArgs>
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
    _count?: boolean | CensusSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CensusSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
  }
  export type CensusSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instrument?: boolean | CensusInstrumentDefaultArgs<ExtArgs>
  }

  export type $CensusSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusSection"
    objects: {
      questions: Prisma.$CensusQuestionPayload<ExtArgs>[]
      instrument: Prisma.$CensusInstrumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instrumentId: string
      slug: string
      name: string
      description: string | null
      icon: string | null
      sortOrder: number
      estimatedTime: number
    }, ExtArgs["result"]["censusSection"]>
    composites: {}
  }

  type CensusSectionGetPayload<S extends boolean | null | undefined | CensusSectionDefaultArgs> = $Result.GetResult<Prisma.$CensusSectionPayload, S>

  type CensusSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusSectionCountAggregateInputType | true
    }

  export interface CensusSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusSection'], meta: { name: 'CensusSection' } }
    /**
     * Find zero or one CensusSection that matches the filter.
     * @param {CensusSectionFindUniqueArgs} args - Arguments to find a CensusSection
     * @example
     * // Get one CensusSection
     * const censusSection = await prisma.censusSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusSectionFindUniqueArgs>(args: SelectSubset<T, CensusSectionFindUniqueArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusSectionFindUniqueOrThrowArgs} args - Arguments to find a CensusSection
     * @example
     * // Get one CensusSection
     * const censusSection = await prisma.censusSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionFindFirstArgs} args - Arguments to find a CensusSection
     * @example
     * // Get one CensusSection
     * const censusSection = await prisma.censusSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusSectionFindFirstArgs>(args?: SelectSubset<T, CensusSectionFindFirstArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionFindFirstOrThrowArgs} args - Arguments to find a CensusSection
     * @example
     * // Get one CensusSection
     * const censusSection = await prisma.censusSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusSections
     * const censusSections = await prisma.censusSection.findMany()
     * 
     * // Get first 10 CensusSections
     * const censusSections = await prisma.censusSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusSectionWithIdOnly = await prisma.censusSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusSectionFindManyArgs>(args?: SelectSubset<T, CensusSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusSection.
     * @param {CensusSectionCreateArgs} args - Arguments to create a CensusSection.
     * @example
     * // Create one CensusSection
     * const CensusSection = await prisma.censusSection.create({
     *   data: {
     *     // ... data to create a CensusSection
     *   }
     * })
     * 
     */
    create<T extends CensusSectionCreateArgs>(args: SelectSubset<T, CensusSectionCreateArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusSections.
     * @param {CensusSectionCreateManyArgs} args - Arguments to create many CensusSections.
     * @example
     * // Create many CensusSections
     * const censusSection = await prisma.censusSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusSectionCreateManyArgs>(args?: SelectSubset<T, CensusSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusSections and returns the data saved in the database.
     * @param {CensusSectionCreateManyAndReturnArgs} args - Arguments to create many CensusSections.
     * @example
     * // Create many CensusSections
     * const censusSection = await prisma.censusSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusSections and only return the `id`
     * const censusSectionWithIdOnly = await prisma.censusSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusSection.
     * @param {CensusSectionDeleteArgs} args - Arguments to delete one CensusSection.
     * @example
     * // Delete one CensusSection
     * const CensusSection = await prisma.censusSection.delete({
     *   where: {
     *     // ... filter to delete one CensusSection
     *   }
     * })
     * 
     */
    delete<T extends CensusSectionDeleteArgs>(args: SelectSubset<T, CensusSectionDeleteArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusSection.
     * @param {CensusSectionUpdateArgs} args - Arguments to update one CensusSection.
     * @example
     * // Update one CensusSection
     * const censusSection = await prisma.censusSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusSectionUpdateArgs>(args: SelectSubset<T, CensusSectionUpdateArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusSections.
     * @param {CensusSectionDeleteManyArgs} args - Arguments to filter CensusSections to delete.
     * @example
     * // Delete a few CensusSections
     * const { count } = await prisma.censusSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusSectionDeleteManyArgs>(args?: SelectSubset<T, CensusSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusSections
     * const censusSection = await prisma.censusSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusSectionUpdateManyArgs>(args: SelectSubset<T, CensusSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusSections and returns the data updated in the database.
     * @param {CensusSectionUpdateManyAndReturnArgs} args - Arguments to update many CensusSections.
     * @example
     * // Update many CensusSections
     * const censusSection = await prisma.censusSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusSections and only return the `id`
     * const censusSectionWithIdOnly = await prisma.censusSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusSection.
     * @param {CensusSectionUpsertArgs} args - Arguments to update or create a CensusSection.
     * @example
     * // Update or create a CensusSection
     * const censusSection = await prisma.censusSection.upsert({
     *   create: {
     *     // ... data to create a CensusSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusSection we want to update
     *   }
     * })
     */
    upsert<T extends CensusSectionUpsertArgs>(args: SelectSubset<T, CensusSectionUpsertArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionCountArgs} args - Arguments to filter CensusSections to count.
     * @example
     * // Count the number of CensusSections
     * const count = await prisma.censusSection.count({
     *   where: {
     *     // ... the filter for the CensusSections we want to count
     *   }
     * })
    **/
    count<T extends CensusSectionCountArgs>(
      args?: Subset<T, CensusSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusSectionAggregateArgs>(args: Subset<T, CensusSectionAggregateArgs>): Prisma.PrismaPromise<GetCensusSectionAggregateType<T>>

    /**
     * Group by CensusSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusSectionGroupByArgs['orderBy'] }
        : { orderBy?: CensusSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusSection model
   */
  readonly fields: CensusSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends CensusSection$questionsArgs<ExtArgs> = {}>(args?: Subset<T, CensusSection$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instrument<T extends CensusInstrumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CensusInstrumentDefaultArgs<ExtArgs>>): Prisma__CensusInstrumentClient<$Result.GetResult<Prisma.$CensusInstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusSection model
   */
  interface CensusSectionFieldRefs {
    readonly id: FieldRef<"CensusSection", 'String'>
    readonly instrumentId: FieldRef<"CensusSection", 'String'>
    readonly slug: FieldRef<"CensusSection", 'String'>
    readonly name: FieldRef<"CensusSection", 'String'>
    readonly description: FieldRef<"CensusSection", 'String'>
    readonly icon: FieldRef<"CensusSection", 'String'>
    readonly sortOrder: FieldRef<"CensusSection", 'Int'>
    readonly estimatedTime: FieldRef<"CensusSection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CensusSection findUnique
   */
  export type CensusSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter, which CensusSection to fetch.
     */
    where: CensusSectionWhereUniqueInput
  }

  /**
   * CensusSection findUniqueOrThrow
   */
  export type CensusSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter, which CensusSection to fetch.
     */
    where: CensusSectionWhereUniqueInput
  }

  /**
   * CensusSection findFirst
   */
  export type CensusSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter, which CensusSection to fetch.
     */
    where?: CensusSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusSections to fetch.
     */
    orderBy?: CensusSectionOrderByWithRelationInput | CensusSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusSections.
     */
    cursor?: CensusSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusSections.
     */
    distinct?: CensusSectionScalarFieldEnum | CensusSectionScalarFieldEnum[]
  }

  /**
   * CensusSection findFirstOrThrow
   */
  export type CensusSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter, which CensusSection to fetch.
     */
    where?: CensusSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusSections to fetch.
     */
    orderBy?: CensusSectionOrderByWithRelationInput | CensusSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusSections.
     */
    cursor?: CensusSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusSections.
     */
    distinct?: CensusSectionScalarFieldEnum | CensusSectionScalarFieldEnum[]
  }

  /**
   * CensusSection findMany
   */
  export type CensusSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter, which CensusSections to fetch.
     */
    where?: CensusSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusSections to fetch.
     */
    orderBy?: CensusSectionOrderByWithRelationInput | CensusSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusSections.
     */
    cursor?: CensusSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusSections.
     */
    skip?: number
    distinct?: CensusSectionScalarFieldEnum | CensusSectionScalarFieldEnum[]
  }

  /**
   * CensusSection create
   */
  export type CensusSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a CensusSection.
     */
    data: XOR<CensusSectionCreateInput, CensusSectionUncheckedCreateInput>
  }

  /**
   * CensusSection createMany
   */
  export type CensusSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusSections.
     */
    data: CensusSectionCreateManyInput | CensusSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusSection createManyAndReturn
   */
  export type CensusSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * The data used to create many CensusSections.
     */
    data: CensusSectionCreateManyInput | CensusSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusSection update
   */
  export type CensusSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a CensusSection.
     */
    data: XOR<CensusSectionUpdateInput, CensusSectionUncheckedUpdateInput>
    /**
     * Choose, which CensusSection to update.
     */
    where: CensusSectionWhereUniqueInput
  }

  /**
   * CensusSection updateMany
   */
  export type CensusSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusSections.
     */
    data: XOR<CensusSectionUpdateManyMutationInput, CensusSectionUncheckedUpdateManyInput>
    /**
     * Filter which CensusSections to update
     */
    where?: CensusSectionWhereInput
    /**
     * Limit how many CensusSections to update.
     */
    limit?: number
  }

  /**
   * CensusSection updateManyAndReturn
   */
  export type CensusSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * The data used to update CensusSections.
     */
    data: XOR<CensusSectionUpdateManyMutationInput, CensusSectionUncheckedUpdateManyInput>
    /**
     * Filter which CensusSections to update
     */
    where?: CensusSectionWhereInput
    /**
     * Limit how many CensusSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusSection upsert
   */
  export type CensusSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the CensusSection to update in case it exists.
     */
    where: CensusSectionWhereUniqueInput
    /**
     * In case the CensusSection found by the `where` argument doesn't exist, create a new CensusSection with this data.
     */
    create: XOR<CensusSectionCreateInput, CensusSectionUncheckedCreateInput>
    /**
     * In case the CensusSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusSectionUpdateInput, CensusSectionUncheckedUpdateInput>
  }

  /**
   * CensusSection delete
   */
  export type CensusSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
    /**
     * Filter which CensusSection to delete.
     */
    where: CensusSectionWhereUniqueInput
  }

  /**
   * CensusSection deleteMany
   */
  export type CensusSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusSections to delete
     */
    where?: CensusSectionWhereInput
    /**
     * Limit how many CensusSections to delete.
     */
    limit?: number
  }

  /**
   * CensusSection.questions
   */
  export type CensusSection$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    where?: CensusQuestionWhereInput
    orderBy?: CensusQuestionOrderByWithRelationInput | CensusQuestionOrderByWithRelationInput[]
    cursor?: CensusQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusQuestionScalarFieldEnum | CensusQuestionScalarFieldEnum[]
  }

  /**
   * CensusSection without action
   */
  export type CensusSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusSection
     */
    select?: CensusSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusSection
     */
    omit?: CensusSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusSectionInclude<ExtArgs> | null
  }


  /**
   * Model CensusQuestion
   */

  export type AggregateCensusQuestion = {
    _count: CensusQuestionCountAggregateOutputType | null
    _avg: CensusQuestionAvgAggregateOutputType | null
    _sum: CensusQuestionSumAggregateOutputType | null
    _min: CensusQuestionMinAggregateOutputType | null
    _max: CensusQuestionMaxAggregateOutputType | null
  }

  export type CensusQuestionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CensusQuestionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CensusQuestionMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    slug: string | null
    text: string | null
    helpText: string | null
    type: string | null
    isRequired: boolean | null
    sortOrder: number | null
    groupId: string | null
    groupLabel: string | null
  }

  export type CensusQuestionMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    slug: string | null
    text: string | null
    helpText: string | null
    type: string | null
    isRequired: boolean | null
    sortOrder: number | null
    groupId: string | null
    groupLabel: string | null
  }

  export type CensusQuestionCountAggregateOutputType = {
    id: number
    sectionId: number
    slug: number
    text: number
    helpText: number
    type: number
    props: number
    isRequired: number
    validation: number
    sortOrder: number
    irtParams: number
    groupId: number
    groupLabel: number
    showWhen: number
    _all: number
  }


  export type CensusQuestionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CensusQuestionSumAggregateInputType = {
    sortOrder?: true
  }

  export type CensusQuestionMinAggregateInputType = {
    id?: true
    sectionId?: true
    slug?: true
    text?: true
    helpText?: true
    type?: true
    isRequired?: true
    sortOrder?: true
    groupId?: true
    groupLabel?: true
  }

  export type CensusQuestionMaxAggregateInputType = {
    id?: true
    sectionId?: true
    slug?: true
    text?: true
    helpText?: true
    type?: true
    isRequired?: true
    sortOrder?: true
    groupId?: true
    groupLabel?: true
  }

  export type CensusQuestionCountAggregateInputType = {
    id?: true
    sectionId?: true
    slug?: true
    text?: true
    helpText?: true
    type?: true
    props?: true
    isRequired?: true
    validation?: true
    sortOrder?: true
    irtParams?: true
    groupId?: true
    groupLabel?: true
    showWhen?: true
    _all?: true
  }

  export type CensusQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusQuestion to aggregate.
     */
    where?: CensusQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusQuestions to fetch.
     */
    orderBy?: CensusQuestionOrderByWithRelationInput | CensusQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusQuestions
    **/
    _count?: true | CensusQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusQuestionMaxAggregateInputType
  }

  export type GetCensusQuestionAggregateType<T extends CensusQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusQuestion[P]>
      : GetScalarType<T[P], AggregateCensusQuestion[P]>
  }




  export type CensusQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusQuestionWhereInput
    orderBy?: CensusQuestionOrderByWithAggregationInput | CensusQuestionOrderByWithAggregationInput[]
    by: CensusQuestionScalarFieldEnum[] | CensusQuestionScalarFieldEnum
    having?: CensusQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusQuestionCountAggregateInputType | true
    _avg?: CensusQuestionAvgAggregateInputType
    _sum?: CensusQuestionSumAggregateInputType
    _min?: CensusQuestionMinAggregateInputType
    _max?: CensusQuestionMaxAggregateInputType
  }

  export type CensusQuestionGroupByOutputType = {
    id: string
    sectionId: string
    slug: string
    text: string
    helpText: string | null
    type: string
    props: JsonValue
    isRequired: boolean
    validation: JsonValue | null
    sortOrder: number
    irtParams: JsonValue | null
    groupId: string | null
    groupLabel: string | null
    showWhen: JsonValue | null
    _count: CensusQuestionCountAggregateOutputType | null
    _avg: CensusQuestionAvgAggregateOutputType | null
    _sum: CensusQuestionSumAggregateOutputType | null
    _min: CensusQuestionMinAggregateOutputType | null
    _max: CensusQuestionMaxAggregateOutputType | null
  }

  type GetCensusQuestionGroupByPayload<T extends CensusQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], CensusQuestionGroupByOutputType[P]>
        }
      >
    >


  export type CensusQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    slug?: boolean
    text?: boolean
    helpText?: boolean
    type?: boolean
    props?: boolean
    isRequired?: boolean
    validation?: boolean
    sortOrder?: boolean
    irtParams?: boolean
    groupId?: boolean
    groupLabel?: boolean
    showWhen?: boolean
    answers?: boolean | CensusQuestion$answersArgs<ExtArgs>
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
    _count?: boolean | CensusQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusQuestion"]>

  export type CensusQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    slug?: boolean
    text?: boolean
    helpText?: boolean
    type?: boolean
    props?: boolean
    isRequired?: boolean
    validation?: boolean
    sortOrder?: boolean
    irtParams?: boolean
    groupId?: boolean
    groupLabel?: boolean
    showWhen?: boolean
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusQuestion"]>

  export type CensusQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    slug?: boolean
    text?: boolean
    helpText?: boolean
    type?: boolean
    props?: boolean
    isRequired?: boolean
    validation?: boolean
    sortOrder?: boolean
    irtParams?: boolean
    groupId?: boolean
    groupLabel?: boolean
    showWhen?: boolean
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusQuestion"]>

  export type CensusQuestionSelectScalar = {
    id?: boolean
    sectionId?: boolean
    slug?: boolean
    text?: boolean
    helpText?: boolean
    type?: boolean
    props?: boolean
    isRequired?: boolean
    validation?: boolean
    sortOrder?: boolean
    irtParams?: boolean
    groupId?: boolean
    groupLabel?: boolean
    showWhen?: boolean
  }

  export type CensusQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "slug" | "text" | "helpText" | "type" | "props" | "isRequired" | "validation" | "sortOrder" | "irtParams" | "groupId" | "groupLabel" | "showWhen", ExtArgs["result"]["censusQuestion"]>
  export type CensusQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | CensusQuestion$answersArgs<ExtArgs>
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
    _count?: boolean | CensusQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CensusQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
  }
  export type CensusQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | CensusSectionDefaultArgs<ExtArgs>
  }

  export type $CensusQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusQuestion"
    objects: {
      answers: Prisma.$CensusAnswerPayload<ExtArgs>[]
      section: Prisma.$CensusSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      slug: string
      text: string
      helpText: string | null
      type: string
      props: Prisma.JsonValue
      isRequired: boolean
      validation: Prisma.JsonValue | null
      sortOrder: number
      irtParams: Prisma.JsonValue | null
      groupId: string | null
      groupLabel: string | null
      showWhen: Prisma.JsonValue | null
    }, ExtArgs["result"]["censusQuestion"]>
    composites: {}
  }

  type CensusQuestionGetPayload<S extends boolean | null | undefined | CensusQuestionDefaultArgs> = $Result.GetResult<Prisma.$CensusQuestionPayload, S>

  type CensusQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusQuestionCountAggregateInputType | true
    }

  export interface CensusQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusQuestion'], meta: { name: 'CensusQuestion' } }
    /**
     * Find zero or one CensusQuestion that matches the filter.
     * @param {CensusQuestionFindUniqueArgs} args - Arguments to find a CensusQuestion
     * @example
     * // Get one CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusQuestionFindUniqueArgs>(args: SelectSubset<T, CensusQuestionFindUniqueArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusQuestionFindUniqueOrThrowArgs} args - Arguments to find a CensusQuestion
     * @example
     * // Get one CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionFindFirstArgs} args - Arguments to find a CensusQuestion
     * @example
     * // Get one CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusQuestionFindFirstArgs>(args?: SelectSubset<T, CensusQuestionFindFirstArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionFindFirstOrThrowArgs} args - Arguments to find a CensusQuestion
     * @example
     * // Get one CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusQuestions
     * const censusQuestions = await prisma.censusQuestion.findMany()
     * 
     * // Get first 10 CensusQuestions
     * const censusQuestions = await prisma.censusQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusQuestionWithIdOnly = await prisma.censusQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusQuestionFindManyArgs>(args?: SelectSubset<T, CensusQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusQuestion.
     * @param {CensusQuestionCreateArgs} args - Arguments to create a CensusQuestion.
     * @example
     * // Create one CensusQuestion
     * const CensusQuestion = await prisma.censusQuestion.create({
     *   data: {
     *     // ... data to create a CensusQuestion
     *   }
     * })
     * 
     */
    create<T extends CensusQuestionCreateArgs>(args: SelectSubset<T, CensusQuestionCreateArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusQuestions.
     * @param {CensusQuestionCreateManyArgs} args - Arguments to create many CensusQuestions.
     * @example
     * // Create many CensusQuestions
     * const censusQuestion = await prisma.censusQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusQuestionCreateManyArgs>(args?: SelectSubset<T, CensusQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusQuestions and returns the data saved in the database.
     * @param {CensusQuestionCreateManyAndReturnArgs} args - Arguments to create many CensusQuestions.
     * @example
     * // Create many CensusQuestions
     * const censusQuestion = await prisma.censusQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusQuestions and only return the `id`
     * const censusQuestionWithIdOnly = await prisma.censusQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusQuestion.
     * @param {CensusQuestionDeleteArgs} args - Arguments to delete one CensusQuestion.
     * @example
     * // Delete one CensusQuestion
     * const CensusQuestion = await prisma.censusQuestion.delete({
     *   where: {
     *     // ... filter to delete one CensusQuestion
     *   }
     * })
     * 
     */
    delete<T extends CensusQuestionDeleteArgs>(args: SelectSubset<T, CensusQuestionDeleteArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusQuestion.
     * @param {CensusQuestionUpdateArgs} args - Arguments to update one CensusQuestion.
     * @example
     * // Update one CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusQuestionUpdateArgs>(args: SelectSubset<T, CensusQuestionUpdateArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusQuestions.
     * @param {CensusQuestionDeleteManyArgs} args - Arguments to filter CensusQuestions to delete.
     * @example
     * // Delete a few CensusQuestions
     * const { count } = await prisma.censusQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusQuestionDeleteManyArgs>(args?: SelectSubset<T, CensusQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusQuestions
     * const censusQuestion = await prisma.censusQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusQuestionUpdateManyArgs>(args: SelectSubset<T, CensusQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusQuestions and returns the data updated in the database.
     * @param {CensusQuestionUpdateManyAndReturnArgs} args - Arguments to update many CensusQuestions.
     * @example
     * // Update many CensusQuestions
     * const censusQuestion = await prisma.censusQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusQuestions and only return the `id`
     * const censusQuestionWithIdOnly = await prisma.censusQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusQuestion.
     * @param {CensusQuestionUpsertArgs} args - Arguments to update or create a CensusQuestion.
     * @example
     * // Update or create a CensusQuestion
     * const censusQuestion = await prisma.censusQuestion.upsert({
     *   create: {
     *     // ... data to create a CensusQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusQuestion we want to update
     *   }
     * })
     */
    upsert<T extends CensusQuestionUpsertArgs>(args: SelectSubset<T, CensusQuestionUpsertArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionCountArgs} args - Arguments to filter CensusQuestions to count.
     * @example
     * // Count the number of CensusQuestions
     * const count = await prisma.censusQuestion.count({
     *   where: {
     *     // ... the filter for the CensusQuestions we want to count
     *   }
     * })
    **/
    count<T extends CensusQuestionCountArgs>(
      args?: Subset<T, CensusQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusQuestionAggregateArgs>(args: Subset<T, CensusQuestionAggregateArgs>): Prisma.PrismaPromise<GetCensusQuestionAggregateType<T>>

    /**
     * Group by CensusQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusQuestionGroupByArgs['orderBy'] }
        : { orderBy?: CensusQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusQuestion model
   */
  readonly fields: CensusQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends CensusQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, CensusQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    section<T extends CensusSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CensusSectionDefaultArgs<ExtArgs>>): Prisma__CensusSectionClient<$Result.GetResult<Prisma.$CensusSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusQuestion model
   */
  interface CensusQuestionFieldRefs {
    readonly id: FieldRef<"CensusQuestion", 'String'>
    readonly sectionId: FieldRef<"CensusQuestion", 'String'>
    readonly slug: FieldRef<"CensusQuestion", 'String'>
    readonly text: FieldRef<"CensusQuestion", 'String'>
    readonly helpText: FieldRef<"CensusQuestion", 'String'>
    readonly type: FieldRef<"CensusQuestion", 'String'>
    readonly props: FieldRef<"CensusQuestion", 'Json'>
    readonly isRequired: FieldRef<"CensusQuestion", 'Boolean'>
    readonly validation: FieldRef<"CensusQuestion", 'Json'>
    readonly sortOrder: FieldRef<"CensusQuestion", 'Int'>
    readonly irtParams: FieldRef<"CensusQuestion", 'Json'>
    readonly groupId: FieldRef<"CensusQuestion", 'String'>
    readonly groupLabel: FieldRef<"CensusQuestion", 'String'>
    readonly showWhen: FieldRef<"CensusQuestion", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CensusQuestion findUnique
   */
  export type CensusQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CensusQuestion to fetch.
     */
    where: CensusQuestionWhereUniqueInput
  }

  /**
   * CensusQuestion findUniqueOrThrow
   */
  export type CensusQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CensusQuestion to fetch.
     */
    where: CensusQuestionWhereUniqueInput
  }

  /**
   * CensusQuestion findFirst
   */
  export type CensusQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CensusQuestion to fetch.
     */
    where?: CensusQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusQuestions to fetch.
     */
    orderBy?: CensusQuestionOrderByWithRelationInput | CensusQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusQuestions.
     */
    cursor?: CensusQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusQuestions.
     */
    distinct?: CensusQuestionScalarFieldEnum | CensusQuestionScalarFieldEnum[]
  }

  /**
   * CensusQuestion findFirstOrThrow
   */
  export type CensusQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CensusQuestion to fetch.
     */
    where?: CensusQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusQuestions to fetch.
     */
    orderBy?: CensusQuestionOrderByWithRelationInput | CensusQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusQuestions.
     */
    cursor?: CensusQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusQuestions.
     */
    distinct?: CensusQuestionScalarFieldEnum | CensusQuestionScalarFieldEnum[]
  }

  /**
   * CensusQuestion findMany
   */
  export type CensusQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CensusQuestions to fetch.
     */
    where?: CensusQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusQuestions to fetch.
     */
    orderBy?: CensusQuestionOrderByWithRelationInput | CensusQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusQuestions.
     */
    cursor?: CensusQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusQuestions.
     */
    skip?: number
    distinct?: CensusQuestionScalarFieldEnum | CensusQuestionScalarFieldEnum[]
  }

  /**
   * CensusQuestion create
   */
  export type CensusQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a CensusQuestion.
     */
    data: XOR<CensusQuestionCreateInput, CensusQuestionUncheckedCreateInput>
  }

  /**
   * CensusQuestion createMany
   */
  export type CensusQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusQuestions.
     */
    data: CensusQuestionCreateManyInput | CensusQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusQuestion createManyAndReturn
   */
  export type CensusQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many CensusQuestions.
     */
    data: CensusQuestionCreateManyInput | CensusQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusQuestion update
   */
  export type CensusQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a CensusQuestion.
     */
    data: XOR<CensusQuestionUpdateInput, CensusQuestionUncheckedUpdateInput>
    /**
     * Choose, which CensusQuestion to update.
     */
    where: CensusQuestionWhereUniqueInput
  }

  /**
   * CensusQuestion updateMany
   */
  export type CensusQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusQuestions.
     */
    data: XOR<CensusQuestionUpdateManyMutationInput, CensusQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CensusQuestions to update
     */
    where?: CensusQuestionWhereInput
    /**
     * Limit how many CensusQuestions to update.
     */
    limit?: number
  }

  /**
   * CensusQuestion updateManyAndReturn
   */
  export type CensusQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * The data used to update CensusQuestions.
     */
    data: XOR<CensusQuestionUpdateManyMutationInput, CensusQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CensusQuestions to update
     */
    where?: CensusQuestionWhereInput
    /**
     * Limit how many CensusQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusQuestion upsert
   */
  export type CensusQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the CensusQuestion to update in case it exists.
     */
    where: CensusQuestionWhereUniqueInput
    /**
     * In case the CensusQuestion found by the `where` argument doesn't exist, create a new CensusQuestion with this data.
     */
    create: XOR<CensusQuestionCreateInput, CensusQuestionUncheckedCreateInput>
    /**
     * In case the CensusQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusQuestionUpdateInput, CensusQuestionUncheckedUpdateInput>
  }

  /**
   * CensusQuestion delete
   */
  export type CensusQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
    /**
     * Filter which CensusQuestion to delete.
     */
    where: CensusQuestionWhereUniqueInput
  }

  /**
   * CensusQuestion deleteMany
   */
  export type CensusQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusQuestions to delete
     */
    where?: CensusQuestionWhereInput
    /**
     * Limit how many CensusQuestions to delete.
     */
    limit?: number
  }

  /**
   * CensusQuestion.answers
   */
  export type CensusQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    where?: CensusAnswerWhereInput
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    cursor?: CensusAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusAnswerScalarFieldEnum | CensusAnswerScalarFieldEnum[]
  }

  /**
   * CensusQuestion without action
   */
  export type CensusQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusQuestion
     */
    select?: CensusQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusQuestion
     */
    omit?: CensusQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusQuestionInclude<ExtArgs> | null
  }


  /**
   * Model CensusAnswer
   */

  export type AggregateCensusAnswer = {
    _count: CensusAnswerCountAggregateOutputType | null
    _avg: CensusAnswerAvgAggregateOutputType | null
    _sum: CensusAnswerSumAggregateOutputType | null
    _min: CensusAnswerMinAggregateOutputType | null
    _max: CensusAnswerMaxAggregateOutputType | null
  }

  export type CensusAnswerAvgAggregateOutputType = {
    instrumentVersion: number | null
  }

  export type CensusAnswerSumAggregateOutputType = {
    instrumentVersion: number | null
  }

  export type CensusAnswerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    instrumentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CensusAnswerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    instrumentVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CensusAnswerCountAggregateOutputType = {
    id: number
    userId: number
    questionId: number
    value: number
    instrumentVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CensusAnswerAvgAggregateInputType = {
    instrumentVersion?: true
  }

  export type CensusAnswerSumAggregateInputType = {
    instrumentVersion?: true
  }

  export type CensusAnswerMinAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    instrumentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CensusAnswerMaxAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    instrumentVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CensusAnswerCountAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    value?: true
    instrumentVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CensusAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusAnswer to aggregate.
     */
    where?: CensusAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusAnswers to fetch.
     */
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusAnswers
    **/
    _count?: true | CensusAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusAnswerMaxAggregateInputType
  }

  export type GetCensusAnswerAggregateType<T extends CensusAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusAnswer[P]>
      : GetScalarType<T[P], AggregateCensusAnswer[P]>
  }




  export type CensusAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusAnswerWhereInput
    orderBy?: CensusAnswerOrderByWithAggregationInput | CensusAnswerOrderByWithAggregationInput[]
    by: CensusAnswerScalarFieldEnum[] | CensusAnswerScalarFieldEnum
    having?: CensusAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusAnswerCountAggregateInputType | true
    _avg?: CensusAnswerAvgAggregateInputType
    _sum?: CensusAnswerSumAggregateInputType
    _min?: CensusAnswerMinAggregateInputType
    _max?: CensusAnswerMaxAggregateInputType
  }

  export type CensusAnswerGroupByOutputType = {
    id: string
    userId: string
    questionId: string
    value: JsonValue
    instrumentVersion: number
    createdAt: Date
    updatedAt: Date
    _count: CensusAnswerCountAggregateOutputType | null
    _avg: CensusAnswerAvgAggregateOutputType | null
    _sum: CensusAnswerSumAggregateOutputType | null
    _min: CensusAnswerMinAggregateOutputType | null
    _max: CensusAnswerMaxAggregateOutputType | null
  }

  type GetCensusAnswerGroupByPayload<T extends CensusAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], CensusAnswerGroupByOutputType[P]>
        }
      >
    >


  export type CensusAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    value?: boolean
    instrumentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusAnswer"]>

  export type CensusAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    value?: boolean
    instrumentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusAnswer"]>

  export type CensusAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    value?: boolean
    instrumentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["censusAnswer"]>

  export type CensusAnswerSelectScalar = {
    id?: boolean
    userId?: boolean
    questionId?: boolean
    value?: boolean
    instrumentVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CensusAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "questionId" | "value" | "instrumentVersion" | "createdAt" | "updatedAt", ExtArgs["result"]["censusAnswer"]>
  export type CensusAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CensusAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CensusAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | CensusQuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CensusAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusAnswer"
    objects: {
      question: Prisma.$CensusQuestionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      questionId: string
      value: Prisma.JsonValue
      instrumentVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["censusAnswer"]>
    composites: {}
  }

  type CensusAnswerGetPayload<S extends boolean | null | undefined | CensusAnswerDefaultArgs> = $Result.GetResult<Prisma.$CensusAnswerPayload, S>

  type CensusAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusAnswerCountAggregateInputType | true
    }

  export interface CensusAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusAnswer'], meta: { name: 'CensusAnswer' } }
    /**
     * Find zero or one CensusAnswer that matches the filter.
     * @param {CensusAnswerFindUniqueArgs} args - Arguments to find a CensusAnswer
     * @example
     * // Get one CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusAnswerFindUniqueArgs>(args: SelectSubset<T, CensusAnswerFindUniqueArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusAnswerFindUniqueOrThrowArgs} args - Arguments to find a CensusAnswer
     * @example
     * // Get one CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerFindFirstArgs} args - Arguments to find a CensusAnswer
     * @example
     * // Get one CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusAnswerFindFirstArgs>(args?: SelectSubset<T, CensusAnswerFindFirstArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerFindFirstOrThrowArgs} args - Arguments to find a CensusAnswer
     * @example
     * // Get one CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusAnswers
     * const censusAnswers = await prisma.censusAnswer.findMany()
     * 
     * // Get first 10 CensusAnswers
     * const censusAnswers = await prisma.censusAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusAnswerWithIdOnly = await prisma.censusAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusAnswerFindManyArgs>(args?: SelectSubset<T, CensusAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusAnswer.
     * @param {CensusAnswerCreateArgs} args - Arguments to create a CensusAnswer.
     * @example
     * // Create one CensusAnswer
     * const CensusAnswer = await prisma.censusAnswer.create({
     *   data: {
     *     // ... data to create a CensusAnswer
     *   }
     * })
     * 
     */
    create<T extends CensusAnswerCreateArgs>(args: SelectSubset<T, CensusAnswerCreateArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusAnswers.
     * @param {CensusAnswerCreateManyArgs} args - Arguments to create many CensusAnswers.
     * @example
     * // Create many CensusAnswers
     * const censusAnswer = await prisma.censusAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusAnswerCreateManyArgs>(args?: SelectSubset<T, CensusAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusAnswers and returns the data saved in the database.
     * @param {CensusAnswerCreateManyAndReturnArgs} args - Arguments to create many CensusAnswers.
     * @example
     * // Create many CensusAnswers
     * const censusAnswer = await prisma.censusAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusAnswers and only return the `id`
     * const censusAnswerWithIdOnly = await prisma.censusAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusAnswer.
     * @param {CensusAnswerDeleteArgs} args - Arguments to delete one CensusAnswer.
     * @example
     * // Delete one CensusAnswer
     * const CensusAnswer = await prisma.censusAnswer.delete({
     *   where: {
     *     // ... filter to delete one CensusAnswer
     *   }
     * })
     * 
     */
    delete<T extends CensusAnswerDeleteArgs>(args: SelectSubset<T, CensusAnswerDeleteArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusAnswer.
     * @param {CensusAnswerUpdateArgs} args - Arguments to update one CensusAnswer.
     * @example
     * // Update one CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusAnswerUpdateArgs>(args: SelectSubset<T, CensusAnswerUpdateArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusAnswers.
     * @param {CensusAnswerDeleteManyArgs} args - Arguments to filter CensusAnswers to delete.
     * @example
     * // Delete a few CensusAnswers
     * const { count } = await prisma.censusAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusAnswerDeleteManyArgs>(args?: SelectSubset<T, CensusAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusAnswers
     * const censusAnswer = await prisma.censusAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusAnswerUpdateManyArgs>(args: SelectSubset<T, CensusAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusAnswers and returns the data updated in the database.
     * @param {CensusAnswerUpdateManyAndReturnArgs} args - Arguments to update many CensusAnswers.
     * @example
     * // Update many CensusAnswers
     * const censusAnswer = await prisma.censusAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusAnswers and only return the `id`
     * const censusAnswerWithIdOnly = await prisma.censusAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusAnswer.
     * @param {CensusAnswerUpsertArgs} args - Arguments to update or create a CensusAnswer.
     * @example
     * // Update or create a CensusAnswer
     * const censusAnswer = await prisma.censusAnswer.upsert({
     *   create: {
     *     // ... data to create a CensusAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusAnswer we want to update
     *   }
     * })
     */
    upsert<T extends CensusAnswerUpsertArgs>(args: SelectSubset<T, CensusAnswerUpsertArgs<ExtArgs>>): Prisma__CensusAnswerClient<$Result.GetResult<Prisma.$CensusAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerCountArgs} args - Arguments to filter CensusAnswers to count.
     * @example
     * // Count the number of CensusAnswers
     * const count = await prisma.censusAnswer.count({
     *   where: {
     *     // ... the filter for the CensusAnswers we want to count
     *   }
     * })
    **/
    count<T extends CensusAnswerCountArgs>(
      args?: Subset<T, CensusAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusAnswerAggregateArgs>(args: Subset<T, CensusAnswerAggregateArgs>): Prisma.PrismaPromise<GetCensusAnswerAggregateType<T>>

    /**
     * Group by CensusAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusAnswerGroupByArgs['orderBy'] }
        : { orderBy?: CensusAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusAnswer model
   */
  readonly fields: CensusAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends CensusQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CensusQuestionDefaultArgs<ExtArgs>>): Prisma__CensusQuestionClient<$Result.GetResult<Prisma.$CensusQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusAnswer model
   */
  interface CensusAnswerFieldRefs {
    readonly id: FieldRef<"CensusAnswer", 'String'>
    readonly userId: FieldRef<"CensusAnswer", 'String'>
    readonly questionId: FieldRef<"CensusAnswer", 'String'>
    readonly value: FieldRef<"CensusAnswer", 'Json'>
    readonly instrumentVersion: FieldRef<"CensusAnswer", 'Int'>
    readonly createdAt: FieldRef<"CensusAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"CensusAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CensusAnswer findUnique
   */
  export type CensusAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CensusAnswer to fetch.
     */
    where: CensusAnswerWhereUniqueInput
  }

  /**
   * CensusAnswer findUniqueOrThrow
   */
  export type CensusAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CensusAnswer to fetch.
     */
    where: CensusAnswerWhereUniqueInput
  }

  /**
   * CensusAnswer findFirst
   */
  export type CensusAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CensusAnswer to fetch.
     */
    where?: CensusAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusAnswers to fetch.
     */
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusAnswers.
     */
    cursor?: CensusAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusAnswers.
     */
    distinct?: CensusAnswerScalarFieldEnum | CensusAnswerScalarFieldEnum[]
  }

  /**
   * CensusAnswer findFirstOrThrow
   */
  export type CensusAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CensusAnswer to fetch.
     */
    where?: CensusAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusAnswers to fetch.
     */
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusAnswers.
     */
    cursor?: CensusAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusAnswers.
     */
    distinct?: CensusAnswerScalarFieldEnum | CensusAnswerScalarFieldEnum[]
  }

  /**
   * CensusAnswer findMany
   */
  export type CensusAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter, which CensusAnswers to fetch.
     */
    where?: CensusAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusAnswers to fetch.
     */
    orderBy?: CensusAnswerOrderByWithRelationInput | CensusAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusAnswers.
     */
    cursor?: CensusAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusAnswers.
     */
    skip?: number
    distinct?: CensusAnswerScalarFieldEnum | CensusAnswerScalarFieldEnum[]
  }

  /**
   * CensusAnswer create
   */
  export type CensusAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a CensusAnswer.
     */
    data: XOR<CensusAnswerCreateInput, CensusAnswerUncheckedCreateInput>
  }

  /**
   * CensusAnswer createMany
   */
  export type CensusAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusAnswers.
     */
    data: CensusAnswerCreateManyInput | CensusAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusAnswer createManyAndReturn
   */
  export type CensusAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many CensusAnswers.
     */
    data: CensusAnswerCreateManyInput | CensusAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusAnswer update
   */
  export type CensusAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a CensusAnswer.
     */
    data: XOR<CensusAnswerUpdateInput, CensusAnswerUncheckedUpdateInput>
    /**
     * Choose, which CensusAnswer to update.
     */
    where: CensusAnswerWhereUniqueInput
  }

  /**
   * CensusAnswer updateMany
   */
  export type CensusAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusAnswers.
     */
    data: XOR<CensusAnswerUpdateManyMutationInput, CensusAnswerUncheckedUpdateManyInput>
    /**
     * Filter which CensusAnswers to update
     */
    where?: CensusAnswerWhereInput
    /**
     * Limit how many CensusAnswers to update.
     */
    limit?: number
  }

  /**
   * CensusAnswer updateManyAndReturn
   */
  export type CensusAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * The data used to update CensusAnswers.
     */
    data: XOR<CensusAnswerUpdateManyMutationInput, CensusAnswerUncheckedUpdateManyInput>
    /**
     * Filter which CensusAnswers to update
     */
    where?: CensusAnswerWhereInput
    /**
     * Limit how many CensusAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusAnswer upsert
   */
  export type CensusAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the CensusAnswer to update in case it exists.
     */
    where: CensusAnswerWhereUniqueInput
    /**
     * In case the CensusAnswer found by the `where` argument doesn't exist, create a new CensusAnswer with this data.
     */
    create: XOR<CensusAnswerCreateInput, CensusAnswerUncheckedCreateInput>
    /**
     * In case the CensusAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusAnswerUpdateInput, CensusAnswerUncheckedUpdateInput>
  }

  /**
   * CensusAnswer delete
   */
  export type CensusAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
    /**
     * Filter which CensusAnswer to delete.
     */
    where: CensusAnswerWhereUniqueInput
  }

  /**
   * CensusAnswer deleteMany
   */
  export type CensusAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusAnswers to delete
     */
    where?: CensusAnswerWhereInput
    /**
     * Limit how many CensusAnswers to delete.
     */
    limit?: number
  }

  /**
   * CensusAnswer without action
   */
  export type CensusAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusAnswer
     */
    select?: CensusAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusAnswer
     */
    omit?: CensusAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusAnswerInclude<ExtArgs> | null
  }


  /**
   * Model CensusProgress
   */

  export type AggregateCensusProgress = {
    _count: CensusProgressCountAggregateOutputType | null
    _avg: CensusProgressAvgAggregateOutputType | null
    _sum: CensusProgressSumAggregateOutputType | null
    _min: CensusProgressMinAggregateOutputType | null
    _max: CensusProgressMaxAggregateOutputType | null
  }

  export type CensusProgressAvgAggregateOutputType = {
    totalCompleted: number | null
    totalQuestions: number | null
  }

  export type CensusProgressSumAggregateOutputType = {
    totalCompleted: number | null
    totalQuestions: number | null
  }

  export type CensusProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalCompleted: number | null
    totalQuestions: number | null
    lastActivityAt: Date | null
    completedAt: Date | null
  }

  export type CensusProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalCompleted: number | null
    totalQuestions: number | null
    lastActivityAt: Date | null
    completedAt: Date | null
  }

  export type CensusProgressCountAggregateOutputType = {
    id: number
    userId: number
    sectionProgress: number
    totalCompleted: number
    totalQuestions: number
    scores: number
    lastActivityAt: number
    completedAt: number
    _all: number
  }


  export type CensusProgressAvgAggregateInputType = {
    totalCompleted?: true
    totalQuestions?: true
  }

  export type CensusProgressSumAggregateInputType = {
    totalCompleted?: true
    totalQuestions?: true
  }

  export type CensusProgressMinAggregateInputType = {
    id?: true
    userId?: true
    totalCompleted?: true
    totalQuestions?: true
    lastActivityAt?: true
    completedAt?: true
  }

  export type CensusProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    totalCompleted?: true
    totalQuestions?: true
    lastActivityAt?: true
    completedAt?: true
  }

  export type CensusProgressCountAggregateInputType = {
    id?: true
    userId?: true
    sectionProgress?: true
    totalCompleted?: true
    totalQuestions?: true
    scores?: true
    lastActivityAt?: true
    completedAt?: true
    _all?: true
  }

  export type CensusProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusProgress to aggregate.
     */
    where?: CensusProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusProgresses to fetch.
     */
    orderBy?: CensusProgressOrderByWithRelationInput | CensusProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusProgresses
    **/
    _count?: true | CensusProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusProgressMaxAggregateInputType
  }

  export type GetCensusProgressAggregateType<T extends CensusProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusProgress[P]>
      : GetScalarType<T[P], AggregateCensusProgress[P]>
  }




  export type CensusProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusProgressWhereInput
    orderBy?: CensusProgressOrderByWithAggregationInput | CensusProgressOrderByWithAggregationInput[]
    by: CensusProgressScalarFieldEnum[] | CensusProgressScalarFieldEnum
    having?: CensusProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusProgressCountAggregateInputType | true
    _avg?: CensusProgressAvgAggregateInputType
    _sum?: CensusProgressSumAggregateInputType
    _min?: CensusProgressMinAggregateInputType
    _max?: CensusProgressMaxAggregateInputType
  }

  export type CensusProgressGroupByOutputType = {
    id: string
    userId: string
    sectionProgress: JsonValue
    totalCompleted: number
    totalQuestions: number
    scores: JsonValue | null
    lastActivityAt: Date
    completedAt: Date | null
    _count: CensusProgressCountAggregateOutputType | null
    _avg: CensusProgressAvgAggregateOutputType | null
    _sum: CensusProgressSumAggregateOutputType | null
    _min: CensusProgressMinAggregateOutputType | null
    _max: CensusProgressMaxAggregateOutputType | null
  }

  type GetCensusProgressGroupByPayload<T extends CensusProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusProgressGroupByOutputType[P]>
            : GetScalarType<T[P], CensusProgressGroupByOutputType[P]>
        }
      >
    >


  export type CensusProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectionProgress?: boolean
    totalCompleted?: boolean
    totalQuestions?: boolean
    scores?: boolean
    lastActivityAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["censusProgress"]>

  export type CensusProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectionProgress?: boolean
    totalCompleted?: boolean
    totalQuestions?: boolean
    scores?: boolean
    lastActivityAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["censusProgress"]>

  export type CensusProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectionProgress?: boolean
    totalCompleted?: boolean
    totalQuestions?: boolean
    scores?: boolean
    lastActivityAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["censusProgress"]>

  export type CensusProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    sectionProgress?: boolean
    totalCompleted?: boolean
    totalQuestions?: boolean
    scores?: boolean
    lastActivityAt?: boolean
    completedAt?: boolean
  }

  export type CensusProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sectionProgress" | "totalCompleted" | "totalQuestions" | "scores" | "lastActivityAt" | "completedAt", ExtArgs["result"]["censusProgress"]>

  export type $CensusProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sectionProgress: Prisma.JsonValue
      totalCompleted: number
      totalQuestions: number
      scores: Prisma.JsonValue | null
      lastActivityAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["censusProgress"]>
    composites: {}
  }

  type CensusProgressGetPayload<S extends boolean | null | undefined | CensusProgressDefaultArgs> = $Result.GetResult<Prisma.$CensusProgressPayload, S>

  type CensusProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusProgressCountAggregateInputType | true
    }

  export interface CensusProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusProgress'], meta: { name: 'CensusProgress' } }
    /**
     * Find zero or one CensusProgress that matches the filter.
     * @param {CensusProgressFindUniqueArgs} args - Arguments to find a CensusProgress
     * @example
     * // Get one CensusProgress
     * const censusProgress = await prisma.censusProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusProgressFindUniqueArgs>(args: SelectSubset<T, CensusProgressFindUniqueArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusProgressFindUniqueOrThrowArgs} args - Arguments to find a CensusProgress
     * @example
     * // Get one CensusProgress
     * const censusProgress = await prisma.censusProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressFindFirstArgs} args - Arguments to find a CensusProgress
     * @example
     * // Get one CensusProgress
     * const censusProgress = await prisma.censusProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusProgressFindFirstArgs>(args?: SelectSubset<T, CensusProgressFindFirstArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressFindFirstOrThrowArgs} args - Arguments to find a CensusProgress
     * @example
     * // Get one CensusProgress
     * const censusProgress = await prisma.censusProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusProgresses
     * const censusProgresses = await prisma.censusProgress.findMany()
     * 
     * // Get first 10 CensusProgresses
     * const censusProgresses = await prisma.censusProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusProgressWithIdOnly = await prisma.censusProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusProgressFindManyArgs>(args?: SelectSubset<T, CensusProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusProgress.
     * @param {CensusProgressCreateArgs} args - Arguments to create a CensusProgress.
     * @example
     * // Create one CensusProgress
     * const CensusProgress = await prisma.censusProgress.create({
     *   data: {
     *     // ... data to create a CensusProgress
     *   }
     * })
     * 
     */
    create<T extends CensusProgressCreateArgs>(args: SelectSubset<T, CensusProgressCreateArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusProgresses.
     * @param {CensusProgressCreateManyArgs} args - Arguments to create many CensusProgresses.
     * @example
     * // Create many CensusProgresses
     * const censusProgress = await prisma.censusProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusProgressCreateManyArgs>(args?: SelectSubset<T, CensusProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusProgresses and returns the data saved in the database.
     * @param {CensusProgressCreateManyAndReturnArgs} args - Arguments to create many CensusProgresses.
     * @example
     * // Create many CensusProgresses
     * const censusProgress = await prisma.censusProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusProgresses and only return the `id`
     * const censusProgressWithIdOnly = await prisma.censusProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusProgress.
     * @param {CensusProgressDeleteArgs} args - Arguments to delete one CensusProgress.
     * @example
     * // Delete one CensusProgress
     * const CensusProgress = await prisma.censusProgress.delete({
     *   where: {
     *     // ... filter to delete one CensusProgress
     *   }
     * })
     * 
     */
    delete<T extends CensusProgressDeleteArgs>(args: SelectSubset<T, CensusProgressDeleteArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusProgress.
     * @param {CensusProgressUpdateArgs} args - Arguments to update one CensusProgress.
     * @example
     * // Update one CensusProgress
     * const censusProgress = await prisma.censusProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusProgressUpdateArgs>(args: SelectSubset<T, CensusProgressUpdateArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusProgresses.
     * @param {CensusProgressDeleteManyArgs} args - Arguments to filter CensusProgresses to delete.
     * @example
     * // Delete a few CensusProgresses
     * const { count } = await prisma.censusProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusProgressDeleteManyArgs>(args?: SelectSubset<T, CensusProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusProgresses
     * const censusProgress = await prisma.censusProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusProgressUpdateManyArgs>(args: SelectSubset<T, CensusProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusProgresses and returns the data updated in the database.
     * @param {CensusProgressUpdateManyAndReturnArgs} args - Arguments to update many CensusProgresses.
     * @example
     * // Update many CensusProgresses
     * const censusProgress = await prisma.censusProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusProgresses and only return the `id`
     * const censusProgressWithIdOnly = await prisma.censusProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusProgress.
     * @param {CensusProgressUpsertArgs} args - Arguments to update or create a CensusProgress.
     * @example
     * // Update or create a CensusProgress
     * const censusProgress = await prisma.censusProgress.upsert({
     *   create: {
     *     // ... data to create a CensusProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusProgress we want to update
     *   }
     * })
     */
    upsert<T extends CensusProgressUpsertArgs>(args: SelectSubset<T, CensusProgressUpsertArgs<ExtArgs>>): Prisma__CensusProgressClient<$Result.GetResult<Prisma.$CensusProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressCountArgs} args - Arguments to filter CensusProgresses to count.
     * @example
     * // Count the number of CensusProgresses
     * const count = await prisma.censusProgress.count({
     *   where: {
     *     // ... the filter for the CensusProgresses we want to count
     *   }
     * })
    **/
    count<T extends CensusProgressCountArgs>(
      args?: Subset<T, CensusProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusProgressAggregateArgs>(args: Subset<T, CensusProgressAggregateArgs>): Prisma.PrismaPromise<GetCensusProgressAggregateType<T>>

    /**
     * Group by CensusProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusProgressGroupByArgs['orderBy'] }
        : { orderBy?: CensusProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusProgress model
   */
  readonly fields: CensusProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusProgress model
   */
  interface CensusProgressFieldRefs {
    readonly id: FieldRef<"CensusProgress", 'String'>
    readonly userId: FieldRef<"CensusProgress", 'String'>
    readonly sectionProgress: FieldRef<"CensusProgress", 'Json'>
    readonly totalCompleted: FieldRef<"CensusProgress", 'Int'>
    readonly totalQuestions: FieldRef<"CensusProgress", 'Int'>
    readonly scores: FieldRef<"CensusProgress", 'Json'>
    readonly lastActivityAt: FieldRef<"CensusProgress", 'DateTime'>
    readonly completedAt: FieldRef<"CensusProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CensusProgress findUnique
   */
  export type CensusProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter, which CensusProgress to fetch.
     */
    where: CensusProgressWhereUniqueInput
  }

  /**
   * CensusProgress findUniqueOrThrow
   */
  export type CensusProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter, which CensusProgress to fetch.
     */
    where: CensusProgressWhereUniqueInput
  }

  /**
   * CensusProgress findFirst
   */
  export type CensusProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter, which CensusProgress to fetch.
     */
    where?: CensusProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusProgresses to fetch.
     */
    orderBy?: CensusProgressOrderByWithRelationInput | CensusProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusProgresses.
     */
    cursor?: CensusProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusProgresses.
     */
    distinct?: CensusProgressScalarFieldEnum | CensusProgressScalarFieldEnum[]
  }

  /**
   * CensusProgress findFirstOrThrow
   */
  export type CensusProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter, which CensusProgress to fetch.
     */
    where?: CensusProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusProgresses to fetch.
     */
    orderBy?: CensusProgressOrderByWithRelationInput | CensusProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusProgresses.
     */
    cursor?: CensusProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusProgresses.
     */
    distinct?: CensusProgressScalarFieldEnum | CensusProgressScalarFieldEnum[]
  }

  /**
   * CensusProgress findMany
   */
  export type CensusProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter, which CensusProgresses to fetch.
     */
    where?: CensusProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusProgresses to fetch.
     */
    orderBy?: CensusProgressOrderByWithRelationInput | CensusProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusProgresses.
     */
    cursor?: CensusProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusProgresses.
     */
    skip?: number
    distinct?: CensusProgressScalarFieldEnum | CensusProgressScalarFieldEnum[]
  }

  /**
   * CensusProgress create
   */
  export type CensusProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * The data needed to create a CensusProgress.
     */
    data: XOR<CensusProgressCreateInput, CensusProgressUncheckedCreateInput>
  }

  /**
   * CensusProgress createMany
   */
  export type CensusProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusProgresses.
     */
    data: CensusProgressCreateManyInput | CensusProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusProgress createManyAndReturn
   */
  export type CensusProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * The data used to create many CensusProgresses.
     */
    data: CensusProgressCreateManyInput | CensusProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusProgress update
   */
  export type CensusProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * The data needed to update a CensusProgress.
     */
    data: XOR<CensusProgressUpdateInput, CensusProgressUncheckedUpdateInput>
    /**
     * Choose, which CensusProgress to update.
     */
    where: CensusProgressWhereUniqueInput
  }

  /**
   * CensusProgress updateMany
   */
  export type CensusProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusProgresses.
     */
    data: XOR<CensusProgressUpdateManyMutationInput, CensusProgressUncheckedUpdateManyInput>
    /**
     * Filter which CensusProgresses to update
     */
    where?: CensusProgressWhereInput
    /**
     * Limit how many CensusProgresses to update.
     */
    limit?: number
  }

  /**
   * CensusProgress updateManyAndReturn
   */
  export type CensusProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * The data used to update CensusProgresses.
     */
    data: XOR<CensusProgressUpdateManyMutationInput, CensusProgressUncheckedUpdateManyInput>
    /**
     * Filter which CensusProgresses to update
     */
    where?: CensusProgressWhereInput
    /**
     * Limit how many CensusProgresses to update.
     */
    limit?: number
  }

  /**
   * CensusProgress upsert
   */
  export type CensusProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * The filter to search for the CensusProgress to update in case it exists.
     */
    where: CensusProgressWhereUniqueInput
    /**
     * In case the CensusProgress found by the `where` argument doesn't exist, create a new CensusProgress with this data.
     */
    create: XOR<CensusProgressCreateInput, CensusProgressUncheckedCreateInput>
    /**
     * In case the CensusProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusProgressUpdateInput, CensusProgressUncheckedUpdateInput>
  }

  /**
   * CensusProgress delete
   */
  export type CensusProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
    /**
     * Filter which CensusProgress to delete.
     */
    where: CensusProgressWhereUniqueInput
  }

  /**
   * CensusProgress deleteMany
   */
  export type CensusProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusProgresses to delete
     */
    where?: CensusProgressWhereInput
    /**
     * Limit how many CensusProgresses to delete.
     */
    limit?: number
  }

  /**
   * CensusProgress without action
   */
  export type CensusProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusProgress
     */
    select?: CensusProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusProgress
     */
    omit?: CensusProgressOmit<ExtArgs> | null
  }


  /**
   * Model Prompt
   */

  export type AggregatePrompt = {
    _count: PromptCountAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  export type PromptMinAggregateOutputType = {
    id: string | null
    text: string | null
    type: string | null
    responseType: string | null
    isActive: boolean | null
    frequency: string | null
    studyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptMaxAggregateOutputType = {
    id: string | null
    text: string | null
    type: string | null
    responseType: string | null
    isActive: boolean | null
    frequency: string | null
    studyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptCountAggregateOutputType = {
    id: number
    text: number
    type: number
    responseType: number
    responseProps: number
    isActive: number
    frequency: number
    targetingRules: number
    studyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromptMinAggregateInputType = {
    id?: true
    text?: true
    type?: true
    responseType?: true
    isActive?: true
    frequency?: true
    studyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptMaxAggregateInputType = {
    id?: true
    text?: true
    type?: true
    responseType?: true
    isActive?: true
    frequency?: true
    studyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptCountAggregateInputType = {
    id?: true
    text?: true
    type?: true
    responseType?: true
    responseProps?: true
    isActive?: true
    frequency?: true
    targetingRules?: true
    studyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompt to aggregate.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prompts
    **/
    _count?: true | PromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptMaxAggregateInputType
  }

  export type GetPromptAggregateType<T extends PromptAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt[P]>
      : GetScalarType<T[P], AggregatePrompt[P]>
  }




  export type PromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithAggregationInput | PromptOrderByWithAggregationInput[]
    by: PromptScalarFieldEnum[] | PromptScalarFieldEnum
    having?: PromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCountAggregateInputType | true
    _min?: PromptMinAggregateInputType
    _max?: PromptMaxAggregateInputType
  }

  export type PromptGroupByOutputType = {
    id: string
    text: string
    type: string
    responseType: string
    responseProps: JsonValue | null
    isActive: boolean
    frequency: string | null
    targetingRules: JsonValue | null
    studyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PromptCountAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  type GetPromptGroupByPayload<T extends PromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptGroupByOutputType[P]>
            : GetScalarType<T[P], PromptGroupByOutputType[P]>
        }
      >
    >


  export type PromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    responseType?: boolean
    responseProps?: boolean
    isActive?: boolean
    frequency?: boolean
    targetingRules?: boolean
    studyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | Prompt$studyArgs<ExtArgs>
    responses?: boolean | Prompt$responsesArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    responseType?: boolean
    responseProps?: boolean
    isActive?: boolean
    frequency?: boolean
    targetingRules?: boolean
    studyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | Prompt$studyArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    responseType?: boolean
    responseProps?: boolean
    isActive?: boolean
    frequency?: boolean
    targetingRules?: boolean
    studyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | Prompt$studyArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectScalar = {
    id?: boolean
    text?: boolean
    type?: boolean
    responseType?: boolean
    responseProps?: boolean
    isActive?: boolean
    frequency?: boolean
    targetingRules?: boolean
    studyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "type" | "responseType" | "responseProps" | "isActive" | "frequency" | "targetingRules" | "studyId" | "createdAt" | "updatedAt", ExtArgs["result"]["prompt"]>
  export type PromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | Prompt$studyArgs<ExtArgs>
    responses?: boolean | Prompt$responsesArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | Prompt$studyArgs<ExtArgs>
  }
  export type PromptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | Prompt$studyArgs<ExtArgs>
  }

  export type $PromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prompt"
    objects: {
      study: Prisma.$StudyPayload<ExtArgs> | null
      responses: Prisma.$PromptResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      type: string
      responseType: string
      responseProps: Prisma.JsonValue | null
      isActive: boolean
      frequency: string | null
      targetingRules: Prisma.JsonValue | null
      studyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prompt"]>
    composites: {}
  }

  type PromptGetPayload<S extends boolean | null | undefined | PromptDefaultArgs> = $Result.GetResult<Prisma.$PromptPayload, S>

  type PromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromptCountAggregateInputType | true
    }

  export interface PromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prompt'], meta: { name: 'Prompt' } }
    /**
     * Find zero or one Prompt that matches the filter.
     * @param {PromptFindUniqueArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptFindUniqueArgs>(args: SelectSubset<T, PromptFindUniqueArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromptFindUniqueOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptFindFirstArgs>(args?: SelectSubset<T, PromptFindFirstArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompts
     * const prompts = await prisma.prompt.findMany()
     * 
     * // Get first 10 Prompts
     * const prompts = await prisma.prompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptWithIdOnly = await prisma.prompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptFindManyArgs>(args?: SelectSubset<T, PromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prompt.
     * @param {PromptCreateArgs} args - Arguments to create a Prompt.
     * @example
     * // Create one Prompt
     * const Prompt = await prisma.prompt.create({
     *   data: {
     *     // ... data to create a Prompt
     *   }
     * })
     * 
     */
    create<T extends PromptCreateArgs>(args: SelectSubset<T, PromptCreateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prompts.
     * @param {PromptCreateManyArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptCreateManyArgs>(args?: SelectSubset<T, PromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prompts and returns the data saved in the database.
     * @param {PromptCreateManyAndReturnArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prompts and only return the `id`
     * const promptWithIdOnly = await prisma.prompt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prompt.
     * @param {PromptDeleteArgs} args - Arguments to delete one Prompt.
     * @example
     * // Delete one Prompt
     * const Prompt = await prisma.prompt.delete({
     *   where: {
     *     // ... filter to delete one Prompt
     *   }
     * })
     * 
     */
    delete<T extends PromptDeleteArgs>(args: SelectSubset<T, PromptDeleteArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prompt.
     * @param {PromptUpdateArgs} args - Arguments to update one Prompt.
     * @example
     * // Update one Prompt
     * const prompt = await prisma.prompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptUpdateArgs>(args: SelectSubset<T, PromptUpdateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prompts.
     * @param {PromptDeleteManyArgs} args - Arguments to filter Prompts to delete.
     * @example
     * // Delete a few Prompts
     * const { count } = await prisma.prompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptDeleteManyArgs>(args?: SelectSubset<T, PromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptUpdateManyArgs>(args: SelectSubset<T, PromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts and returns the data updated in the database.
     * @param {PromptUpdateManyAndReturnArgs} args - Arguments to update many Prompts.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prompts and only return the `id`
     * const promptWithIdOnly = await prisma.prompt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromptUpdateManyAndReturnArgs>(args: SelectSubset<T, PromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prompt.
     * @param {PromptUpsertArgs} args - Arguments to update or create a Prompt.
     * @example
     * // Update or create a Prompt
     * const prompt = await prisma.prompt.upsert({
     *   create: {
     *     // ... data to create a Prompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt we want to update
     *   }
     * })
     */
    upsert<T extends PromptUpsertArgs>(args: SelectSubset<T, PromptUpsertArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCountArgs} args - Arguments to filter Prompts to count.
     * @example
     * // Count the number of Prompts
     * const count = await prisma.prompt.count({
     *   where: {
     *     // ... the filter for the Prompts we want to count
     *   }
     * })
    **/
    count<T extends PromptCountArgs>(
      args?: Subset<T, PromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptAggregateArgs>(args: Subset<T, PromptAggregateArgs>): Prisma.PrismaPromise<GetPromptAggregateType<T>>

    /**
     * Group by Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptGroupByArgs['orderBy'] }
        : { orderBy?: PromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prompt model
   */
  readonly fields: PromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    study<T extends Prompt$studyArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$studyArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responses<T extends Prompt$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prompt model
   */
  interface PromptFieldRefs {
    readonly id: FieldRef<"Prompt", 'String'>
    readonly text: FieldRef<"Prompt", 'String'>
    readonly type: FieldRef<"Prompt", 'String'>
    readonly responseType: FieldRef<"Prompt", 'String'>
    readonly responseProps: FieldRef<"Prompt", 'Json'>
    readonly isActive: FieldRef<"Prompt", 'Boolean'>
    readonly frequency: FieldRef<"Prompt", 'String'>
    readonly targetingRules: FieldRef<"Prompt", 'Json'>
    readonly studyId: FieldRef<"Prompt", 'String'>
    readonly createdAt: FieldRef<"Prompt", 'DateTime'>
    readonly updatedAt: FieldRef<"Prompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prompt findUnique
   */
  export type PromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findUniqueOrThrow
   */
  export type PromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findFirst
   */
  export type PromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findFirstOrThrow
   */
  export type PromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findMany
   */
  export type PromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompts to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt create
   */
  export type PromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to create a Prompt.
     */
    data: XOR<PromptCreateInput, PromptUncheckedCreateInput>
  }

  /**
   * Prompt createMany
   */
  export type PromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prompt createManyAndReturn
   */
  export type PromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prompt update
   */
  export type PromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to update a Prompt.
     */
    data: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    /**
     * Choose, which Prompt to update.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt updateMany
   */
  export type PromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
    /**
     * Limit how many Prompts to update.
     */
    limit?: number
  }

  /**
   * Prompt updateManyAndReturn
   */
  export type PromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
    /**
     * Limit how many Prompts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prompt upsert
   */
  export type PromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The filter to search for the Prompt to update in case it exists.
     */
    where: PromptWhereUniqueInput
    /**
     * In case the Prompt found by the `where` argument doesn't exist, create a new Prompt with this data.
     */
    create: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    /**
     * In case the Prompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
  }

  /**
   * Prompt delete
   */
  export type PromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter which Prompt to delete.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt deleteMany
   */
  export type PromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompts to delete
     */
    where?: PromptWhereInput
    /**
     * Limit how many Prompts to delete.
     */
    limit?: number
  }

  /**
   * Prompt.study
   */
  export type Prompt$studyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    where?: StudyWhereInput
  }

  /**
   * Prompt.responses
   */
  export type Prompt$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    where?: PromptResponseWhereInput
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    cursor?: PromptResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptResponseScalarFieldEnum | PromptResponseScalarFieldEnum[]
  }

  /**
   * Prompt without action
   */
  export type PromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
  }


  /**
   * Model PromptResponse
   */

  export type AggregatePromptResponse = {
    _count: PromptResponseCountAggregateOutputType | null
    _min: PromptResponseMinAggregateOutputType | null
    _max: PromptResponseMaxAggregateOutputType | null
  }

  export type PromptResponseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    promptId: string | null
    shownAt: Date | null
    respondedAt: Date | null
    skipped: boolean | null
  }

  export type PromptResponseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    promptId: string | null
    shownAt: Date | null
    respondedAt: Date | null
    skipped: boolean | null
  }

  export type PromptResponseCountAggregateOutputType = {
    id: number
    userId: number
    promptId: number
    value: number
    shownAt: number
    respondedAt: number
    skipped: number
    _all: number
  }


  export type PromptResponseMinAggregateInputType = {
    id?: true
    userId?: true
    promptId?: true
    shownAt?: true
    respondedAt?: true
    skipped?: true
  }

  export type PromptResponseMaxAggregateInputType = {
    id?: true
    userId?: true
    promptId?: true
    shownAt?: true
    respondedAt?: true
    skipped?: true
  }

  export type PromptResponseCountAggregateInputType = {
    id?: true
    userId?: true
    promptId?: true
    value?: true
    shownAt?: true
    respondedAt?: true
    skipped?: true
    _all?: true
  }

  export type PromptResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptResponse to aggregate.
     */
    where?: PromptResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptResponses to fetch.
     */
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptResponses
    **/
    _count?: true | PromptResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptResponseMaxAggregateInputType
  }

  export type GetPromptResponseAggregateType<T extends PromptResponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptResponse[P]>
      : GetScalarType<T[P], AggregatePromptResponse[P]>
  }




  export type PromptResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptResponseWhereInput
    orderBy?: PromptResponseOrderByWithAggregationInput | PromptResponseOrderByWithAggregationInput[]
    by: PromptResponseScalarFieldEnum[] | PromptResponseScalarFieldEnum
    having?: PromptResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptResponseCountAggregateInputType | true
    _min?: PromptResponseMinAggregateInputType
    _max?: PromptResponseMaxAggregateInputType
  }

  export type PromptResponseGroupByOutputType = {
    id: string
    userId: string
    promptId: string
    value: JsonValue
    shownAt: Date
    respondedAt: Date
    skipped: boolean
    _count: PromptResponseCountAggregateOutputType | null
    _min: PromptResponseMinAggregateOutputType | null
    _max: PromptResponseMaxAggregateOutputType | null
  }

  type GetPromptResponseGroupByPayload<T extends PromptResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptResponseGroupByOutputType[P]>
            : GetScalarType<T[P], PromptResponseGroupByOutputType[P]>
        }
      >
    >


  export type PromptResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promptId?: boolean
    value?: boolean
    shownAt?: boolean
    respondedAt?: boolean
    skipped?: boolean
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptResponse"]>

  export type PromptResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promptId?: boolean
    value?: boolean
    shownAt?: boolean
    respondedAt?: boolean
    skipped?: boolean
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptResponse"]>

  export type PromptResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promptId?: boolean
    value?: boolean
    shownAt?: boolean
    respondedAt?: boolean
    skipped?: boolean
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptResponse"]>

  export type PromptResponseSelectScalar = {
    id?: boolean
    userId?: boolean
    promptId?: boolean
    value?: boolean
    shownAt?: boolean
    respondedAt?: boolean
    skipped?: boolean
  }

  export type PromptResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "promptId" | "value" | "shownAt" | "respondedAt" | "skipped", ExtArgs["result"]["promptResponse"]>
  export type PromptResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PromptResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PromptResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PromptResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromptResponse"
    objects: {
      prompt: Prisma.$PromptPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      promptId: string
      value: Prisma.JsonValue
      shownAt: Date
      respondedAt: Date
      skipped: boolean
    }, ExtArgs["result"]["promptResponse"]>
    composites: {}
  }

  type PromptResponseGetPayload<S extends boolean | null | undefined | PromptResponseDefaultArgs> = $Result.GetResult<Prisma.$PromptResponsePayload, S>

  type PromptResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromptResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromptResponseCountAggregateInputType | true
    }

  export interface PromptResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptResponse'], meta: { name: 'PromptResponse' } }
    /**
     * Find zero or one PromptResponse that matches the filter.
     * @param {PromptResponseFindUniqueArgs} args - Arguments to find a PromptResponse
     * @example
     * // Get one PromptResponse
     * const promptResponse = await prisma.promptResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptResponseFindUniqueArgs>(args: SelectSubset<T, PromptResponseFindUniqueArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromptResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromptResponseFindUniqueOrThrowArgs} args - Arguments to find a PromptResponse
     * @example
     * // Get one PromptResponse
     * const promptResponse = await prisma.promptResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseFindFirstArgs} args - Arguments to find a PromptResponse
     * @example
     * // Get one PromptResponse
     * const promptResponse = await prisma.promptResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptResponseFindFirstArgs>(args?: SelectSubset<T, PromptResponseFindFirstArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseFindFirstOrThrowArgs} args - Arguments to find a PromptResponse
     * @example
     * // Get one PromptResponse
     * const promptResponse = await prisma.promptResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromptResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptResponses
     * const promptResponses = await prisma.promptResponse.findMany()
     * 
     * // Get first 10 PromptResponses
     * const promptResponses = await prisma.promptResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptResponseWithIdOnly = await prisma.promptResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptResponseFindManyArgs>(args?: SelectSubset<T, PromptResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromptResponse.
     * @param {PromptResponseCreateArgs} args - Arguments to create a PromptResponse.
     * @example
     * // Create one PromptResponse
     * const PromptResponse = await prisma.promptResponse.create({
     *   data: {
     *     // ... data to create a PromptResponse
     *   }
     * })
     * 
     */
    create<T extends PromptResponseCreateArgs>(args: SelectSubset<T, PromptResponseCreateArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromptResponses.
     * @param {PromptResponseCreateManyArgs} args - Arguments to create many PromptResponses.
     * @example
     * // Create many PromptResponses
     * const promptResponse = await prisma.promptResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptResponseCreateManyArgs>(args?: SelectSubset<T, PromptResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromptResponses and returns the data saved in the database.
     * @param {PromptResponseCreateManyAndReturnArgs} args - Arguments to create many PromptResponses.
     * @example
     * // Create many PromptResponses
     * const promptResponse = await prisma.promptResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromptResponses and only return the `id`
     * const promptResponseWithIdOnly = await prisma.promptResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromptResponse.
     * @param {PromptResponseDeleteArgs} args - Arguments to delete one PromptResponse.
     * @example
     * // Delete one PromptResponse
     * const PromptResponse = await prisma.promptResponse.delete({
     *   where: {
     *     // ... filter to delete one PromptResponse
     *   }
     * })
     * 
     */
    delete<T extends PromptResponseDeleteArgs>(args: SelectSubset<T, PromptResponseDeleteArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromptResponse.
     * @param {PromptResponseUpdateArgs} args - Arguments to update one PromptResponse.
     * @example
     * // Update one PromptResponse
     * const promptResponse = await prisma.promptResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptResponseUpdateArgs>(args: SelectSubset<T, PromptResponseUpdateArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromptResponses.
     * @param {PromptResponseDeleteManyArgs} args - Arguments to filter PromptResponses to delete.
     * @example
     * // Delete a few PromptResponses
     * const { count } = await prisma.promptResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptResponseDeleteManyArgs>(args?: SelectSubset<T, PromptResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptResponses
     * const promptResponse = await prisma.promptResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptResponseUpdateManyArgs>(args: SelectSubset<T, PromptResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptResponses and returns the data updated in the database.
     * @param {PromptResponseUpdateManyAndReturnArgs} args - Arguments to update many PromptResponses.
     * @example
     * // Update many PromptResponses
     * const promptResponse = await prisma.promptResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromptResponses and only return the `id`
     * const promptResponseWithIdOnly = await prisma.promptResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromptResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, PromptResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromptResponse.
     * @param {PromptResponseUpsertArgs} args - Arguments to update or create a PromptResponse.
     * @example
     * // Update or create a PromptResponse
     * const promptResponse = await prisma.promptResponse.upsert({
     *   create: {
     *     // ... data to create a PromptResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptResponse we want to update
     *   }
     * })
     */
    upsert<T extends PromptResponseUpsertArgs>(args: SelectSubset<T, PromptResponseUpsertArgs<ExtArgs>>): Prisma__PromptResponseClient<$Result.GetResult<Prisma.$PromptResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromptResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseCountArgs} args - Arguments to filter PromptResponses to count.
     * @example
     * // Count the number of PromptResponses
     * const count = await prisma.promptResponse.count({
     *   where: {
     *     // ... the filter for the PromptResponses we want to count
     *   }
     * })
    **/
    count<T extends PromptResponseCountArgs>(
      args?: Subset<T, PromptResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptResponseAggregateArgs>(args: Subset<T, PromptResponseAggregateArgs>): Prisma.PrismaPromise<GetPromptResponseAggregateType<T>>

    /**
     * Group by PromptResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptResponseGroupByArgs['orderBy'] }
        : { orderBy?: PromptResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptResponse model
   */
  readonly fields: PromptResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromptResponse model
   */
  interface PromptResponseFieldRefs {
    readonly id: FieldRef<"PromptResponse", 'String'>
    readonly userId: FieldRef<"PromptResponse", 'String'>
    readonly promptId: FieldRef<"PromptResponse", 'String'>
    readonly value: FieldRef<"PromptResponse", 'Json'>
    readonly shownAt: FieldRef<"PromptResponse", 'DateTime'>
    readonly respondedAt: FieldRef<"PromptResponse", 'DateTime'>
    readonly skipped: FieldRef<"PromptResponse", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PromptResponse findUnique
   */
  export type PromptResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter, which PromptResponse to fetch.
     */
    where: PromptResponseWhereUniqueInput
  }

  /**
   * PromptResponse findUniqueOrThrow
   */
  export type PromptResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter, which PromptResponse to fetch.
     */
    where: PromptResponseWhereUniqueInput
  }

  /**
   * PromptResponse findFirst
   */
  export type PromptResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter, which PromptResponse to fetch.
     */
    where?: PromptResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptResponses to fetch.
     */
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptResponses.
     */
    cursor?: PromptResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptResponses.
     */
    distinct?: PromptResponseScalarFieldEnum | PromptResponseScalarFieldEnum[]
  }

  /**
   * PromptResponse findFirstOrThrow
   */
  export type PromptResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter, which PromptResponse to fetch.
     */
    where?: PromptResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptResponses to fetch.
     */
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptResponses.
     */
    cursor?: PromptResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptResponses.
     */
    distinct?: PromptResponseScalarFieldEnum | PromptResponseScalarFieldEnum[]
  }

  /**
   * PromptResponse findMany
   */
  export type PromptResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter, which PromptResponses to fetch.
     */
    where?: PromptResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptResponses to fetch.
     */
    orderBy?: PromptResponseOrderByWithRelationInput | PromptResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptResponses.
     */
    cursor?: PromptResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptResponses.
     */
    skip?: number
    distinct?: PromptResponseScalarFieldEnum | PromptResponseScalarFieldEnum[]
  }

  /**
   * PromptResponse create
   */
  export type PromptResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptResponse.
     */
    data: XOR<PromptResponseCreateInput, PromptResponseUncheckedCreateInput>
  }

  /**
   * PromptResponse createMany
   */
  export type PromptResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptResponses.
     */
    data: PromptResponseCreateManyInput | PromptResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromptResponse createManyAndReturn
   */
  export type PromptResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * The data used to create many PromptResponses.
     */
    data: PromptResponseCreateManyInput | PromptResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptResponse update
   */
  export type PromptResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptResponse.
     */
    data: XOR<PromptResponseUpdateInput, PromptResponseUncheckedUpdateInput>
    /**
     * Choose, which PromptResponse to update.
     */
    where: PromptResponseWhereUniqueInput
  }

  /**
   * PromptResponse updateMany
   */
  export type PromptResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptResponses.
     */
    data: XOR<PromptResponseUpdateManyMutationInput, PromptResponseUncheckedUpdateManyInput>
    /**
     * Filter which PromptResponses to update
     */
    where?: PromptResponseWhereInput
    /**
     * Limit how many PromptResponses to update.
     */
    limit?: number
  }

  /**
   * PromptResponse updateManyAndReturn
   */
  export type PromptResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * The data used to update PromptResponses.
     */
    data: XOR<PromptResponseUpdateManyMutationInput, PromptResponseUncheckedUpdateManyInput>
    /**
     * Filter which PromptResponses to update
     */
    where?: PromptResponseWhereInput
    /**
     * Limit how many PromptResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptResponse upsert
   */
  export type PromptResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptResponse to update in case it exists.
     */
    where: PromptResponseWhereUniqueInput
    /**
     * In case the PromptResponse found by the `where` argument doesn't exist, create a new PromptResponse with this data.
     */
    create: XOR<PromptResponseCreateInput, PromptResponseUncheckedCreateInput>
    /**
     * In case the PromptResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptResponseUpdateInput, PromptResponseUncheckedUpdateInput>
  }

  /**
   * PromptResponse delete
   */
  export type PromptResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
    /**
     * Filter which PromptResponse to delete.
     */
    where: PromptResponseWhereUniqueInput
  }

  /**
   * PromptResponse deleteMany
   */
  export type PromptResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptResponses to delete
     */
    where?: PromptResponseWhereInput
    /**
     * Limit how many PromptResponses to delete.
     */
    limit?: number
  }

  /**
   * PromptResponse without action
   */
  export type PromptResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptResponse
     */
    select?: PromptResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptResponse
     */
    omit?: PromptResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptResponseInclude<ExtArgs> | null
  }


  /**
   * Model Consent
   */

  export type AggregateConsent = {
    _count: ConsentCountAggregateOutputType | null
    _avg: ConsentAvgAggregateOutputType | null
    _sum: ConsentSumAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  export type ConsentAvgAggregateOutputType = {
    version: number | null
  }

  export type ConsentSumAggregateOutputType = {
    version: number | null
  }

  export type ConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scope: string | null
    version: number | null
    granted: boolean | null
    timestamp: Date | null
    receiptHash: string | null
    policyHash: string | null
    jurisdiction: string | null
    ipHash: string | null
  }

  export type ConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scope: string | null
    version: number | null
    granted: boolean | null
    timestamp: Date | null
    receiptHash: string | null
    policyHash: string | null
    jurisdiction: string | null
    ipHash: string | null
  }

  export type ConsentCountAggregateOutputType = {
    id: number
    userId: number
    scope: number
    version: number
    granted: number
    timestamp: number
    receiptHash: number
    policyHash: number
    jurisdiction: number
    ipHash: number
    _all: number
  }


  export type ConsentAvgAggregateInputType = {
    version?: true
  }

  export type ConsentSumAggregateInputType = {
    version?: true
  }

  export type ConsentMinAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    version?: true
    granted?: true
    timestamp?: true
    receiptHash?: true
    policyHash?: true
    jurisdiction?: true
    ipHash?: true
  }

  export type ConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    version?: true
    granted?: true
    timestamp?: true
    receiptHash?: true
    policyHash?: true
    jurisdiction?: true
    ipHash?: true
  }

  export type ConsentCountAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    version?: true
    granted?: true
    timestamp?: true
    receiptHash?: true
    policyHash?: true
    jurisdiction?: true
    ipHash?: true
    _all?: true
  }

  export type ConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consent to aggregate.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consents
    **/
    _count?: true | ConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentMaxAggregateInputType
  }

  export type GetConsentAggregateType<T extends ConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsent[P]>
      : GetScalarType<T[P], AggregateConsent[P]>
  }




  export type ConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentWhereInput
    orderBy?: ConsentOrderByWithAggregationInput | ConsentOrderByWithAggregationInput[]
    by: ConsentScalarFieldEnum[] | ConsentScalarFieldEnum
    having?: ConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentCountAggregateInputType | true
    _avg?: ConsentAvgAggregateInputType
    _sum?: ConsentSumAggregateInputType
    _min?: ConsentMinAggregateInputType
    _max?: ConsentMaxAggregateInputType
  }

  export type ConsentGroupByOutputType = {
    id: string
    userId: string
    scope: string
    version: number
    granted: boolean
    timestamp: Date
    receiptHash: string
    policyHash: string
    jurisdiction: string | null
    ipHash: string | null
    _count: ConsentCountAggregateOutputType | null
    _avg: ConsentAvgAggregateOutputType | null
    _sum: ConsentSumAggregateOutputType | null
    _min: ConsentMinAggregateOutputType | null
    _max: ConsentMaxAggregateOutputType | null
  }

  type GetConsentGroupByPayload<T extends ConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentGroupByOutputType[P]>
        }
      >
    >


  export type ConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    version?: boolean
    granted?: boolean
    timestamp?: boolean
    receiptHash?: boolean
    policyHash?: boolean
    jurisdiction?: boolean
    ipHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    version?: boolean
    granted?: boolean
    timestamp?: boolean
    receiptHash?: boolean
    policyHash?: boolean
    jurisdiction?: boolean
    ipHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    version?: boolean
    granted?: boolean
    timestamp?: boolean
    receiptHash?: boolean
    policyHash?: boolean
    jurisdiction?: boolean
    ipHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consent"]>

  export type ConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    scope?: boolean
    version?: boolean
    granted?: boolean
    timestamp?: boolean
    receiptHash?: boolean
    policyHash?: boolean
    jurisdiction?: boolean
    ipHash?: boolean
  }

  export type ConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "scope" | "version" | "granted" | "timestamp" | "receiptHash" | "policyHash" | "jurisdiction" | "ipHash", ExtArgs["result"]["consent"]>
  export type ConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scope: string
      version: number
      granted: boolean
      timestamp: Date
      receiptHash: string
      policyHash: string
      jurisdiction: string | null
      ipHash: string | null
    }, ExtArgs["result"]["consent"]>
    composites: {}
  }

  type ConsentGetPayload<S extends boolean | null | undefined | ConsentDefaultArgs> = $Result.GetResult<Prisma.$ConsentPayload, S>

  type ConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsentCountAggregateInputType | true
    }

  export interface ConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consent'], meta: { name: 'Consent' } }
    /**
     * Find zero or one Consent that matches the filter.
     * @param {ConsentFindUniqueArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentFindUniqueArgs>(args: SelectSubset<T, ConsentFindUniqueArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsentFindUniqueOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindFirstArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentFindFirstArgs>(args?: SelectSubset<T, ConsentFindFirstArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindFirstOrThrowArgs} args - Arguments to find a Consent
     * @example
     * // Get one Consent
     * const consent = await prisma.consent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consents
     * const consents = await prisma.consent.findMany()
     * 
     * // Get first 10 Consents
     * const consents = await prisma.consent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentWithIdOnly = await prisma.consent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentFindManyArgs>(args?: SelectSubset<T, ConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consent.
     * @param {ConsentCreateArgs} args - Arguments to create a Consent.
     * @example
     * // Create one Consent
     * const Consent = await prisma.consent.create({
     *   data: {
     *     // ... data to create a Consent
     *   }
     * })
     * 
     */
    create<T extends ConsentCreateArgs>(args: SelectSubset<T, ConsentCreateArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consents.
     * @param {ConsentCreateManyArgs} args - Arguments to create many Consents.
     * @example
     * // Create many Consents
     * const consent = await prisma.consent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentCreateManyArgs>(args?: SelectSubset<T, ConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consents and returns the data saved in the database.
     * @param {ConsentCreateManyAndReturnArgs} args - Arguments to create many Consents.
     * @example
     * // Create many Consents
     * const consent = await prisma.consent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consents and only return the `id`
     * const consentWithIdOnly = await prisma.consent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consent.
     * @param {ConsentDeleteArgs} args - Arguments to delete one Consent.
     * @example
     * // Delete one Consent
     * const Consent = await prisma.consent.delete({
     *   where: {
     *     // ... filter to delete one Consent
     *   }
     * })
     * 
     */
    delete<T extends ConsentDeleteArgs>(args: SelectSubset<T, ConsentDeleteArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consent.
     * @param {ConsentUpdateArgs} args - Arguments to update one Consent.
     * @example
     * // Update one Consent
     * const consent = await prisma.consent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentUpdateArgs>(args: SelectSubset<T, ConsentUpdateArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consents.
     * @param {ConsentDeleteManyArgs} args - Arguments to filter Consents to delete.
     * @example
     * // Delete a few Consents
     * const { count } = await prisma.consent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentDeleteManyArgs>(args?: SelectSubset<T, ConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consents
     * const consent = await prisma.consent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentUpdateManyArgs>(args: SelectSubset<T, ConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consents and returns the data updated in the database.
     * @param {ConsentUpdateManyAndReturnArgs} args - Arguments to update many Consents.
     * @example
     * // Update many Consents
     * const consent = await prisma.consent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consents and only return the `id`
     * const consentWithIdOnly = await prisma.consent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consent.
     * @param {ConsentUpsertArgs} args - Arguments to update or create a Consent.
     * @example
     * // Update or create a Consent
     * const consent = await prisma.consent.upsert({
     *   create: {
     *     // ... data to create a Consent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consent we want to update
     *   }
     * })
     */
    upsert<T extends ConsentUpsertArgs>(args: SelectSubset<T, ConsentUpsertArgs<ExtArgs>>): Prisma__ConsentClient<$Result.GetResult<Prisma.$ConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentCountArgs} args - Arguments to filter Consents to count.
     * @example
     * // Count the number of Consents
     * const count = await prisma.consent.count({
     *   where: {
     *     // ... the filter for the Consents we want to count
     *   }
     * })
    **/
    count<T extends ConsentCountArgs>(
      args?: Subset<T, ConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentAggregateArgs>(args: Subset<T, ConsentAggregateArgs>): Prisma.PrismaPromise<GetConsentAggregateType<T>>

    /**
     * Group by Consent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentGroupByArgs['orderBy'] }
        : { orderBy?: ConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consent model
   */
  readonly fields: ConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consent model
   */
  interface ConsentFieldRefs {
    readonly id: FieldRef<"Consent", 'String'>
    readonly userId: FieldRef<"Consent", 'String'>
    readonly scope: FieldRef<"Consent", 'String'>
    readonly version: FieldRef<"Consent", 'Int'>
    readonly granted: FieldRef<"Consent", 'Boolean'>
    readonly timestamp: FieldRef<"Consent", 'DateTime'>
    readonly receiptHash: FieldRef<"Consent", 'String'>
    readonly policyHash: FieldRef<"Consent", 'String'>
    readonly jurisdiction: FieldRef<"Consent", 'String'>
    readonly ipHash: FieldRef<"Consent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Consent findUnique
   */
  export type ConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent findUniqueOrThrow
   */
  export type ConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent findFirst
   */
  export type ConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent findFirstOrThrow
   */
  export type ConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consent to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consents.
     */
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent findMany
   */
  export type ConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter, which Consents to fetch.
     */
    where?: ConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consents to fetch.
     */
    orderBy?: ConsentOrderByWithRelationInput | ConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consents.
     */
    cursor?: ConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consents.
     */
    skip?: number
    distinct?: ConsentScalarFieldEnum | ConsentScalarFieldEnum[]
  }

  /**
   * Consent create
   */
  export type ConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a Consent.
     */
    data: XOR<ConsentCreateInput, ConsentUncheckedCreateInput>
  }

  /**
   * Consent createMany
   */
  export type ConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consents.
     */
    data: ConsentCreateManyInput | ConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consent createManyAndReturn
   */
  export type ConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * The data used to create many Consents.
     */
    data: ConsentCreateManyInput | ConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consent update
   */
  export type ConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a Consent.
     */
    data: XOR<ConsentUpdateInput, ConsentUncheckedUpdateInput>
    /**
     * Choose, which Consent to update.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent updateMany
   */
  export type ConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consents.
     */
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyInput>
    /**
     * Filter which Consents to update
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to update.
     */
    limit?: number
  }

  /**
   * Consent updateManyAndReturn
   */
  export type ConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * The data used to update Consents.
     */
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyInput>
    /**
     * Filter which Consents to update
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consent upsert
   */
  export type ConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the Consent to update in case it exists.
     */
    where: ConsentWhereUniqueInput
    /**
     * In case the Consent found by the `where` argument doesn't exist, create a new Consent with this data.
     */
    create: XOR<ConsentCreateInput, ConsentUncheckedCreateInput>
    /**
     * In case the Consent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentUpdateInput, ConsentUncheckedUpdateInput>
  }

  /**
   * Consent delete
   */
  export type ConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
    /**
     * Filter which Consent to delete.
     */
    where: ConsentWhereUniqueInput
  }

  /**
   * Consent deleteMany
   */
  export type ConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consents to delete
     */
    where?: ConsentWhereInput
    /**
     * Limit how many Consents to delete.
     */
    limit?: number
  }

  /**
   * Consent without action
   */
  export type ConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consent
     */
    select?: ConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consent
     */
    omit?: ConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentInclude<ExtArgs> | null
  }


  /**
   * Model WeatherAggregate
   */

  export type AggregateWeatherAggregate = {
    _count: WeatherAggregateCountAggregateOutputType | null
    _avg: WeatherAggregateAvgAggregateOutputType | null
    _sum: WeatherAggregateSumAggregateOutputType | null
    _min: WeatherAggregateMinAggregateOutputType | null
    _max: WeatherAggregateMaxAggregateOutputType | null
  }

  export type WeatherAggregateAvgAggregateOutputType = {
    sampleN: number | null
    dpEpsilon: number | null
    dpDelta: number | null
    minNThreshold: number | null
    methodVersion: number | null
  }

  export type WeatherAggregateSumAggregateOutputType = {
    sampleN: number | null
    dpEpsilon: number | null
    dpDelta: number | null
    minNThreshold: number | null
    methodVersion: number | null
  }

  export type WeatherAggregateMinAggregateOutputType = {
    id: string | null
    metric: string | null
    period: string | null
    periodStart: Date | null
    sampleN: number | null
    dpEpsilon: number | null
    dpDelta: number | null
    minNThreshold: number | null
    region: string | null
    methodVersion: number | null
    computedAt: Date | null
  }

  export type WeatherAggregateMaxAggregateOutputType = {
    id: string | null
    metric: string | null
    period: string | null
    periodStart: Date | null
    sampleN: number | null
    dpEpsilon: number | null
    dpDelta: number | null
    minNThreshold: number | null
    region: string | null
    methodVersion: number | null
    computedAt: Date | null
  }

  export type WeatherAggregateCountAggregateOutputType = {
    id: number
    metric: number
    period: number
    periodStart: number
    value: number
    sampleN: number
    dpEpsilon: number
    dpDelta: number
    minNThreshold: number
    region: number
    methodVersion: number
    computedAt: number
    _all: number
  }


  export type WeatherAggregateAvgAggregateInputType = {
    sampleN?: true
    dpEpsilon?: true
    dpDelta?: true
    minNThreshold?: true
    methodVersion?: true
  }

  export type WeatherAggregateSumAggregateInputType = {
    sampleN?: true
    dpEpsilon?: true
    dpDelta?: true
    minNThreshold?: true
    methodVersion?: true
  }

  export type WeatherAggregateMinAggregateInputType = {
    id?: true
    metric?: true
    period?: true
    periodStart?: true
    sampleN?: true
    dpEpsilon?: true
    dpDelta?: true
    minNThreshold?: true
    region?: true
    methodVersion?: true
    computedAt?: true
  }

  export type WeatherAggregateMaxAggregateInputType = {
    id?: true
    metric?: true
    period?: true
    periodStart?: true
    sampleN?: true
    dpEpsilon?: true
    dpDelta?: true
    minNThreshold?: true
    region?: true
    methodVersion?: true
    computedAt?: true
  }

  export type WeatherAggregateCountAggregateInputType = {
    id?: true
    metric?: true
    period?: true
    periodStart?: true
    value?: true
    sampleN?: true
    dpEpsilon?: true
    dpDelta?: true
    minNThreshold?: true
    region?: true
    methodVersion?: true
    computedAt?: true
    _all?: true
  }

  export type WeatherAggregateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherAggregate to aggregate.
     */
    where?: WeatherAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAggregates to fetch.
     */
    orderBy?: WeatherAggregateOrderByWithRelationInput | WeatherAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherAggregates
    **/
    _count?: true | WeatherAggregateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeatherAggregateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeatherAggregateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherAggregateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherAggregateMaxAggregateInputType
  }

  export type GetWeatherAggregateAggregateType<T extends WeatherAggregateAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherAggregate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherAggregate[P]>
      : GetScalarType<T[P], AggregateWeatherAggregate[P]>
  }




  export type WeatherAggregateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherAggregateWhereInput
    orderBy?: WeatherAggregateOrderByWithAggregationInput | WeatherAggregateOrderByWithAggregationInput[]
    by: WeatherAggregateScalarFieldEnum[] | WeatherAggregateScalarFieldEnum
    having?: WeatherAggregateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherAggregateCountAggregateInputType | true
    _avg?: WeatherAggregateAvgAggregateInputType
    _sum?: WeatherAggregateSumAggregateInputType
    _min?: WeatherAggregateMinAggregateInputType
    _max?: WeatherAggregateMaxAggregateInputType
  }

  export type WeatherAggregateGroupByOutputType = {
    id: string
    metric: string
    period: string
    periodStart: Date
    value: JsonValue
    sampleN: number
    dpEpsilon: number | null
    dpDelta: number | null
    minNThreshold: number
    region: string | null
    methodVersion: number
    computedAt: Date
    _count: WeatherAggregateCountAggregateOutputType | null
    _avg: WeatherAggregateAvgAggregateOutputType | null
    _sum: WeatherAggregateSumAggregateOutputType | null
    _min: WeatherAggregateMinAggregateOutputType | null
    _max: WeatherAggregateMaxAggregateOutputType | null
  }

  type GetWeatherAggregateGroupByPayload<T extends WeatherAggregateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherAggregateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherAggregateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherAggregateGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherAggregateGroupByOutputType[P]>
        }
      >
    >


  export type WeatherAggregateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metric?: boolean
    period?: boolean
    periodStart?: boolean
    value?: boolean
    sampleN?: boolean
    dpEpsilon?: boolean
    dpDelta?: boolean
    minNThreshold?: boolean
    region?: boolean
    methodVersion?: boolean
    computedAt?: boolean
  }, ExtArgs["result"]["weatherAggregate"]>

  export type WeatherAggregateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metric?: boolean
    period?: boolean
    periodStart?: boolean
    value?: boolean
    sampleN?: boolean
    dpEpsilon?: boolean
    dpDelta?: boolean
    minNThreshold?: boolean
    region?: boolean
    methodVersion?: boolean
    computedAt?: boolean
  }, ExtArgs["result"]["weatherAggregate"]>

  export type WeatherAggregateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metric?: boolean
    period?: boolean
    periodStart?: boolean
    value?: boolean
    sampleN?: boolean
    dpEpsilon?: boolean
    dpDelta?: boolean
    minNThreshold?: boolean
    region?: boolean
    methodVersion?: boolean
    computedAt?: boolean
  }, ExtArgs["result"]["weatherAggregate"]>

  export type WeatherAggregateSelectScalar = {
    id?: boolean
    metric?: boolean
    period?: boolean
    periodStart?: boolean
    value?: boolean
    sampleN?: boolean
    dpEpsilon?: boolean
    dpDelta?: boolean
    minNThreshold?: boolean
    region?: boolean
    methodVersion?: boolean
    computedAt?: boolean
  }

  export type WeatherAggregateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metric" | "period" | "periodStart" | "value" | "sampleN" | "dpEpsilon" | "dpDelta" | "minNThreshold" | "region" | "methodVersion" | "computedAt", ExtArgs["result"]["weatherAggregate"]>

  export type $WeatherAggregatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherAggregate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metric: string
      period: string
      periodStart: Date
      value: Prisma.JsonValue
      sampleN: number
      dpEpsilon: number | null
      dpDelta: number | null
      minNThreshold: number
      region: string | null
      methodVersion: number
      computedAt: Date
    }, ExtArgs["result"]["weatherAggregate"]>
    composites: {}
  }

  type WeatherAggregateGetPayload<S extends boolean | null | undefined | WeatherAggregateDefaultArgs> = $Result.GetResult<Prisma.$WeatherAggregatePayload, S>

  type WeatherAggregateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherAggregateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherAggregateCountAggregateInputType | true
    }

  export interface WeatherAggregateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherAggregate'], meta: { name: 'WeatherAggregate' } }
    /**
     * Find zero or one WeatherAggregate that matches the filter.
     * @param {WeatherAggregateFindUniqueArgs} args - Arguments to find a WeatherAggregate
     * @example
     * // Get one WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherAggregateFindUniqueArgs>(args: SelectSubset<T, WeatherAggregateFindUniqueArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeatherAggregate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherAggregateFindUniqueOrThrowArgs} args - Arguments to find a WeatherAggregate
     * @example
     * // Get one WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherAggregateFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherAggregateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeatherAggregate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateFindFirstArgs} args - Arguments to find a WeatherAggregate
     * @example
     * // Get one WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherAggregateFindFirstArgs>(args?: SelectSubset<T, WeatherAggregateFindFirstArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeatherAggregate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateFindFirstOrThrowArgs} args - Arguments to find a WeatherAggregate
     * @example
     * // Get one WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherAggregateFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherAggregateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeatherAggregates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherAggregates
     * const weatherAggregates = await prisma.weatherAggregate.findMany()
     * 
     * // Get first 10 WeatherAggregates
     * const weatherAggregates = await prisma.weatherAggregate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherAggregateWithIdOnly = await prisma.weatherAggregate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherAggregateFindManyArgs>(args?: SelectSubset<T, WeatherAggregateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeatherAggregate.
     * @param {WeatherAggregateCreateArgs} args - Arguments to create a WeatherAggregate.
     * @example
     * // Create one WeatherAggregate
     * const WeatherAggregate = await prisma.weatherAggregate.create({
     *   data: {
     *     // ... data to create a WeatherAggregate
     *   }
     * })
     * 
     */
    create<T extends WeatherAggregateCreateArgs>(args: SelectSubset<T, WeatherAggregateCreateArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeatherAggregates.
     * @param {WeatherAggregateCreateManyArgs} args - Arguments to create many WeatherAggregates.
     * @example
     * // Create many WeatherAggregates
     * const weatherAggregate = await prisma.weatherAggregate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherAggregateCreateManyArgs>(args?: SelectSubset<T, WeatherAggregateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeatherAggregates and returns the data saved in the database.
     * @param {WeatherAggregateCreateManyAndReturnArgs} args - Arguments to create many WeatherAggregates.
     * @example
     * // Create many WeatherAggregates
     * const weatherAggregate = await prisma.weatherAggregate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeatherAggregates and only return the `id`
     * const weatherAggregateWithIdOnly = await prisma.weatherAggregate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherAggregateCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherAggregateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeatherAggregate.
     * @param {WeatherAggregateDeleteArgs} args - Arguments to delete one WeatherAggregate.
     * @example
     * // Delete one WeatherAggregate
     * const WeatherAggregate = await prisma.weatherAggregate.delete({
     *   where: {
     *     // ... filter to delete one WeatherAggregate
     *   }
     * })
     * 
     */
    delete<T extends WeatherAggregateDeleteArgs>(args: SelectSubset<T, WeatherAggregateDeleteArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeatherAggregate.
     * @param {WeatherAggregateUpdateArgs} args - Arguments to update one WeatherAggregate.
     * @example
     * // Update one WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherAggregateUpdateArgs>(args: SelectSubset<T, WeatherAggregateUpdateArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeatherAggregates.
     * @param {WeatherAggregateDeleteManyArgs} args - Arguments to filter WeatherAggregates to delete.
     * @example
     * // Delete a few WeatherAggregates
     * const { count } = await prisma.weatherAggregate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherAggregateDeleteManyArgs>(args?: SelectSubset<T, WeatherAggregateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherAggregates
     * const weatherAggregate = await prisma.weatherAggregate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherAggregateUpdateManyArgs>(args: SelectSubset<T, WeatherAggregateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherAggregates and returns the data updated in the database.
     * @param {WeatherAggregateUpdateManyAndReturnArgs} args - Arguments to update many WeatherAggregates.
     * @example
     * // Update many WeatherAggregates
     * const weatherAggregate = await prisma.weatherAggregate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeatherAggregates and only return the `id`
     * const weatherAggregateWithIdOnly = await prisma.weatherAggregate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherAggregateUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherAggregateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeatherAggregate.
     * @param {WeatherAggregateUpsertArgs} args - Arguments to update or create a WeatherAggregate.
     * @example
     * // Update or create a WeatherAggregate
     * const weatherAggregate = await prisma.weatherAggregate.upsert({
     *   create: {
     *     // ... data to create a WeatherAggregate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherAggregate we want to update
     *   }
     * })
     */
    upsert<T extends WeatherAggregateUpsertArgs>(args: SelectSubset<T, WeatherAggregateUpsertArgs<ExtArgs>>): Prisma__WeatherAggregateClient<$Result.GetResult<Prisma.$WeatherAggregatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeatherAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateCountArgs} args - Arguments to filter WeatherAggregates to count.
     * @example
     * // Count the number of WeatherAggregates
     * const count = await prisma.weatherAggregate.count({
     *   where: {
     *     // ... the filter for the WeatherAggregates we want to count
     *   }
     * })
    **/
    count<T extends WeatherAggregateCountArgs>(
      args?: Subset<T, WeatherAggregateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherAggregateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateAggregateArgs>(args: Subset<T, WeatherAggregateAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateAggregateType<T>>

    /**
     * Group by WeatherAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherAggregateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherAggregateGroupByArgs['orderBy'] }
        : { orderBy?: WeatherAggregateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherAggregateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherAggregateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherAggregate model
   */
  readonly fields: WeatherAggregateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherAggregate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherAggregateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherAggregate model
   */
  interface WeatherAggregateFieldRefs {
    readonly id: FieldRef<"WeatherAggregate", 'String'>
    readonly metric: FieldRef<"WeatherAggregate", 'String'>
    readonly period: FieldRef<"WeatherAggregate", 'String'>
    readonly periodStart: FieldRef<"WeatherAggregate", 'DateTime'>
    readonly value: FieldRef<"WeatherAggregate", 'Json'>
    readonly sampleN: FieldRef<"WeatherAggregate", 'Int'>
    readonly dpEpsilon: FieldRef<"WeatherAggregate", 'Float'>
    readonly dpDelta: FieldRef<"WeatherAggregate", 'Float'>
    readonly minNThreshold: FieldRef<"WeatherAggregate", 'Int'>
    readonly region: FieldRef<"WeatherAggregate", 'String'>
    readonly methodVersion: FieldRef<"WeatherAggregate", 'Int'>
    readonly computedAt: FieldRef<"WeatherAggregate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeatherAggregate findUnique
   */
  export type WeatherAggregateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAggregate to fetch.
     */
    where: WeatherAggregateWhereUniqueInput
  }

  /**
   * WeatherAggregate findUniqueOrThrow
   */
  export type WeatherAggregateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAggregate to fetch.
     */
    where: WeatherAggregateWhereUniqueInput
  }

  /**
   * WeatherAggregate findFirst
   */
  export type WeatherAggregateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAggregate to fetch.
     */
    where?: WeatherAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAggregates to fetch.
     */
    orderBy?: WeatherAggregateOrderByWithRelationInput | WeatherAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherAggregates.
     */
    cursor?: WeatherAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherAggregates.
     */
    distinct?: WeatherAggregateScalarFieldEnum | WeatherAggregateScalarFieldEnum[]
  }

  /**
   * WeatherAggregate findFirstOrThrow
   */
  export type WeatherAggregateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAggregate to fetch.
     */
    where?: WeatherAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAggregates to fetch.
     */
    orderBy?: WeatherAggregateOrderByWithRelationInput | WeatherAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherAggregates.
     */
    cursor?: WeatherAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherAggregates.
     */
    distinct?: WeatherAggregateScalarFieldEnum | WeatherAggregateScalarFieldEnum[]
  }

  /**
   * WeatherAggregate findMany
   */
  export type WeatherAggregateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter, which WeatherAggregates to fetch.
     */
    where?: WeatherAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherAggregates to fetch.
     */
    orderBy?: WeatherAggregateOrderByWithRelationInput | WeatherAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherAggregates.
     */
    cursor?: WeatherAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherAggregates.
     */
    skip?: number
    distinct?: WeatherAggregateScalarFieldEnum | WeatherAggregateScalarFieldEnum[]
  }

  /**
   * WeatherAggregate create
   */
  export type WeatherAggregateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * The data needed to create a WeatherAggregate.
     */
    data: XOR<WeatherAggregateCreateInput, WeatherAggregateUncheckedCreateInput>
  }

  /**
   * WeatherAggregate createMany
   */
  export type WeatherAggregateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherAggregates.
     */
    data: WeatherAggregateCreateManyInput | WeatherAggregateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherAggregate createManyAndReturn
   */
  export type WeatherAggregateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * The data used to create many WeatherAggregates.
     */
    data: WeatherAggregateCreateManyInput | WeatherAggregateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherAggregate update
   */
  export type WeatherAggregateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * The data needed to update a WeatherAggregate.
     */
    data: XOR<WeatherAggregateUpdateInput, WeatherAggregateUncheckedUpdateInput>
    /**
     * Choose, which WeatherAggregate to update.
     */
    where: WeatherAggregateWhereUniqueInput
  }

  /**
   * WeatherAggregate updateMany
   */
  export type WeatherAggregateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherAggregates.
     */
    data: XOR<WeatherAggregateUpdateManyMutationInput, WeatherAggregateUncheckedUpdateManyInput>
    /**
     * Filter which WeatherAggregates to update
     */
    where?: WeatherAggregateWhereInput
    /**
     * Limit how many WeatherAggregates to update.
     */
    limit?: number
  }

  /**
   * WeatherAggregate updateManyAndReturn
   */
  export type WeatherAggregateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * The data used to update WeatherAggregates.
     */
    data: XOR<WeatherAggregateUpdateManyMutationInput, WeatherAggregateUncheckedUpdateManyInput>
    /**
     * Filter which WeatherAggregates to update
     */
    where?: WeatherAggregateWhereInput
    /**
     * Limit how many WeatherAggregates to update.
     */
    limit?: number
  }

  /**
   * WeatherAggregate upsert
   */
  export type WeatherAggregateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * The filter to search for the WeatherAggregate to update in case it exists.
     */
    where: WeatherAggregateWhereUniqueInput
    /**
     * In case the WeatherAggregate found by the `where` argument doesn't exist, create a new WeatherAggregate with this data.
     */
    create: XOR<WeatherAggregateCreateInput, WeatherAggregateUncheckedCreateInput>
    /**
     * In case the WeatherAggregate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherAggregateUpdateInput, WeatherAggregateUncheckedUpdateInput>
  }

  /**
   * WeatherAggregate delete
   */
  export type WeatherAggregateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
    /**
     * Filter which WeatherAggregate to delete.
     */
    where: WeatherAggregateWhereUniqueInput
  }

  /**
   * WeatherAggregate deleteMany
   */
  export type WeatherAggregateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherAggregates to delete
     */
    where?: WeatherAggregateWhereInput
    /**
     * Limit how many WeatherAggregates to delete.
     */
    limit?: number
  }

  /**
   * WeatherAggregate without action
   */
  export type WeatherAggregateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherAggregate
     */
    select?: WeatherAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeatherAggregate
     */
    omit?: WeatherAggregateOmit<ExtArgs> | null
  }


  /**
   * Model PersonalWeather
   */

  export type AggregatePersonalWeather = {
    _count: PersonalWeatherCountAggregateOutputType | null
    _min: PersonalWeatherMinAggregateOutputType | null
    _max: PersonalWeatherMaxAggregateOutputType | null
  }

  export type PersonalWeatherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lastComputedAt: Date | null
  }

  export type PersonalWeatherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lastComputedAt: Date | null
  }

  export type PersonalWeatherCountAggregateOutputType = {
    id: number
    userId: number
    weather: number
    streaks: number
    lastComputedAt: number
    _all: number
  }


  export type PersonalWeatherMinAggregateInputType = {
    id?: true
    userId?: true
    lastComputedAt?: true
  }

  export type PersonalWeatherMaxAggregateInputType = {
    id?: true
    userId?: true
    lastComputedAt?: true
  }

  export type PersonalWeatherCountAggregateInputType = {
    id?: true
    userId?: true
    weather?: true
    streaks?: true
    lastComputedAt?: true
    _all?: true
  }

  export type PersonalWeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalWeather to aggregate.
     */
    where?: PersonalWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalWeathers to fetch.
     */
    orderBy?: PersonalWeatherOrderByWithRelationInput | PersonalWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalWeathers
    **/
    _count?: true | PersonalWeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalWeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalWeatherMaxAggregateInputType
  }

  export type GetPersonalWeatherAggregateType<T extends PersonalWeatherAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalWeather[P]>
      : GetScalarType<T[P], AggregatePersonalWeather[P]>
  }




  export type PersonalWeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalWeatherWhereInput
    orderBy?: PersonalWeatherOrderByWithAggregationInput | PersonalWeatherOrderByWithAggregationInput[]
    by: PersonalWeatherScalarFieldEnum[] | PersonalWeatherScalarFieldEnum
    having?: PersonalWeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalWeatherCountAggregateInputType | true
    _min?: PersonalWeatherMinAggregateInputType
    _max?: PersonalWeatherMaxAggregateInputType
  }

  export type PersonalWeatherGroupByOutputType = {
    id: string
    userId: string
    weather: JsonValue
    streaks: JsonValue | null
    lastComputedAt: Date
    _count: PersonalWeatherCountAggregateOutputType | null
    _min: PersonalWeatherMinAggregateOutputType | null
    _max: PersonalWeatherMaxAggregateOutputType | null
  }

  type GetPersonalWeatherGroupByPayload<T extends PersonalWeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalWeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalWeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalWeatherGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalWeatherGroupByOutputType[P]>
        }
      >
    >


  export type PersonalWeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weather?: boolean
    streaks?: boolean
    lastComputedAt?: boolean
  }, ExtArgs["result"]["personalWeather"]>

  export type PersonalWeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weather?: boolean
    streaks?: boolean
    lastComputedAt?: boolean
  }, ExtArgs["result"]["personalWeather"]>

  export type PersonalWeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weather?: boolean
    streaks?: boolean
    lastComputedAt?: boolean
  }, ExtArgs["result"]["personalWeather"]>

  export type PersonalWeatherSelectScalar = {
    id?: boolean
    userId?: boolean
    weather?: boolean
    streaks?: boolean
    lastComputedAt?: boolean
  }

  export type PersonalWeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "weather" | "streaks" | "lastComputedAt", ExtArgs["result"]["personalWeather"]>

  export type $PersonalWeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalWeather"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      weather: Prisma.JsonValue
      streaks: Prisma.JsonValue | null
      lastComputedAt: Date
    }, ExtArgs["result"]["personalWeather"]>
    composites: {}
  }

  type PersonalWeatherGetPayload<S extends boolean | null | undefined | PersonalWeatherDefaultArgs> = $Result.GetResult<Prisma.$PersonalWeatherPayload, S>

  type PersonalWeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalWeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalWeatherCountAggregateInputType | true
    }

  export interface PersonalWeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalWeather'], meta: { name: 'PersonalWeather' } }
    /**
     * Find zero or one PersonalWeather that matches the filter.
     * @param {PersonalWeatherFindUniqueArgs} args - Arguments to find a PersonalWeather
     * @example
     * // Get one PersonalWeather
     * const personalWeather = await prisma.personalWeather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalWeatherFindUniqueArgs>(args: SelectSubset<T, PersonalWeatherFindUniqueArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalWeather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalWeatherFindUniqueOrThrowArgs} args - Arguments to find a PersonalWeather
     * @example
     * // Get one PersonalWeather
     * const personalWeather = await prisma.personalWeather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalWeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalWeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalWeather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherFindFirstArgs} args - Arguments to find a PersonalWeather
     * @example
     * // Get one PersonalWeather
     * const personalWeather = await prisma.personalWeather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalWeatherFindFirstArgs>(args?: SelectSubset<T, PersonalWeatherFindFirstArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalWeather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherFindFirstOrThrowArgs} args - Arguments to find a PersonalWeather
     * @example
     * // Get one PersonalWeather
     * const personalWeather = await prisma.personalWeather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalWeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalWeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalWeathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalWeathers
     * const personalWeathers = await prisma.personalWeather.findMany()
     * 
     * // Get first 10 PersonalWeathers
     * const personalWeathers = await prisma.personalWeather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalWeatherWithIdOnly = await prisma.personalWeather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalWeatherFindManyArgs>(args?: SelectSubset<T, PersonalWeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalWeather.
     * @param {PersonalWeatherCreateArgs} args - Arguments to create a PersonalWeather.
     * @example
     * // Create one PersonalWeather
     * const PersonalWeather = await prisma.personalWeather.create({
     *   data: {
     *     // ... data to create a PersonalWeather
     *   }
     * })
     * 
     */
    create<T extends PersonalWeatherCreateArgs>(args: SelectSubset<T, PersonalWeatherCreateArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalWeathers.
     * @param {PersonalWeatherCreateManyArgs} args - Arguments to create many PersonalWeathers.
     * @example
     * // Create many PersonalWeathers
     * const personalWeather = await prisma.personalWeather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalWeatherCreateManyArgs>(args?: SelectSubset<T, PersonalWeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalWeathers and returns the data saved in the database.
     * @param {PersonalWeatherCreateManyAndReturnArgs} args - Arguments to create many PersonalWeathers.
     * @example
     * // Create many PersonalWeathers
     * const personalWeather = await prisma.personalWeather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalWeathers and only return the `id`
     * const personalWeatherWithIdOnly = await prisma.personalWeather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalWeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalWeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalWeather.
     * @param {PersonalWeatherDeleteArgs} args - Arguments to delete one PersonalWeather.
     * @example
     * // Delete one PersonalWeather
     * const PersonalWeather = await prisma.personalWeather.delete({
     *   where: {
     *     // ... filter to delete one PersonalWeather
     *   }
     * })
     * 
     */
    delete<T extends PersonalWeatherDeleteArgs>(args: SelectSubset<T, PersonalWeatherDeleteArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalWeather.
     * @param {PersonalWeatherUpdateArgs} args - Arguments to update one PersonalWeather.
     * @example
     * // Update one PersonalWeather
     * const personalWeather = await prisma.personalWeather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalWeatherUpdateArgs>(args: SelectSubset<T, PersonalWeatherUpdateArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalWeathers.
     * @param {PersonalWeatherDeleteManyArgs} args - Arguments to filter PersonalWeathers to delete.
     * @example
     * // Delete a few PersonalWeathers
     * const { count } = await prisma.personalWeather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalWeatherDeleteManyArgs>(args?: SelectSubset<T, PersonalWeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalWeathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalWeathers
     * const personalWeather = await prisma.personalWeather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalWeatherUpdateManyArgs>(args: SelectSubset<T, PersonalWeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalWeathers and returns the data updated in the database.
     * @param {PersonalWeatherUpdateManyAndReturnArgs} args - Arguments to update many PersonalWeathers.
     * @example
     * // Update many PersonalWeathers
     * const personalWeather = await prisma.personalWeather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalWeathers and only return the `id`
     * const personalWeatherWithIdOnly = await prisma.personalWeather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalWeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalWeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalWeather.
     * @param {PersonalWeatherUpsertArgs} args - Arguments to update or create a PersonalWeather.
     * @example
     * // Update or create a PersonalWeather
     * const personalWeather = await prisma.personalWeather.upsert({
     *   create: {
     *     // ... data to create a PersonalWeather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalWeather we want to update
     *   }
     * })
     */
    upsert<T extends PersonalWeatherUpsertArgs>(args: SelectSubset<T, PersonalWeatherUpsertArgs<ExtArgs>>): Prisma__PersonalWeatherClient<$Result.GetResult<Prisma.$PersonalWeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalWeathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherCountArgs} args - Arguments to filter PersonalWeathers to count.
     * @example
     * // Count the number of PersonalWeathers
     * const count = await prisma.personalWeather.count({
     *   where: {
     *     // ... the filter for the PersonalWeathers we want to count
     *   }
     * })
    **/
    count<T extends PersonalWeatherCountArgs>(
      args?: Subset<T, PersonalWeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalWeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalWeather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalWeatherAggregateArgs>(args: Subset<T, PersonalWeatherAggregateArgs>): Prisma.PrismaPromise<GetPersonalWeatherAggregateType<T>>

    /**
     * Group by PersonalWeather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalWeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalWeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalWeatherGroupByArgs['orderBy'] }
        : { orderBy?: PersonalWeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalWeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalWeather model
   */
  readonly fields: PersonalWeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalWeather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalWeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalWeather model
   */
  interface PersonalWeatherFieldRefs {
    readonly id: FieldRef<"PersonalWeather", 'String'>
    readonly userId: FieldRef<"PersonalWeather", 'String'>
    readonly weather: FieldRef<"PersonalWeather", 'Json'>
    readonly streaks: FieldRef<"PersonalWeather", 'Json'>
    readonly lastComputedAt: FieldRef<"PersonalWeather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonalWeather findUnique
   */
  export type PersonalWeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter, which PersonalWeather to fetch.
     */
    where: PersonalWeatherWhereUniqueInput
  }

  /**
   * PersonalWeather findUniqueOrThrow
   */
  export type PersonalWeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter, which PersonalWeather to fetch.
     */
    where: PersonalWeatherWhereUniqueInput
  }

  /**
   * PersonalWeather findFirst
   */
  export type PersonalWeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter, which PersonalWeather to fetch.
     */
    where?: PersonalWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalWeathers to fetch.
     */
    orderBy?: PersonalWeatherOrderByWithRelationInput | PersonalWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalWeathers.
     */
    cursor?: PersonalWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalWeathers.
     */
    distinct?: PersonalWeatherScalarFieldEnum | PersonalWeatherScalarFieldEnum[]
  }

  /**
   * PersonalWeather findFirstOrThrow
   */
  export type PersonalWeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter, which PersonalWeather to fetch.
     */
    where?: PersonalWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalWeathers to fetch.
     */
    orderBy?: PersonalWeatherOrderByWithRelationInput | PersonalWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalWeathers.
     */
    cursor?: PersonalWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalWeathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalWeathers.
     */
    distinct?: PersonalWeatherScalarFieldEnum | PersonalWeatherScalarFieldEnum[]
  }

  /**
   * PersonalWeather findMany
   */
  export type PersonalWeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter, which PersonalWeathers to fetch.
     */
    where?: PersonalWeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalWeathers to fetch.
     */
    orderBy?: PersonalWeatherOrderByWithRelationInput | PersonalWeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalWeathers.
     */
    cursor?: PersonalWeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalWeathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalWeathers.
     */
    skip?: number
    distinct?: PersonalWeatherScalarFieldEnum | PersonalWeatherScalarFieldEnum[]
  }

  /**
   * PersonalWeather create
   */
  export type PersonalWeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * The data needed to create a PersonalWeather.
     */
    data: XOR<PersonalWeatherCreateInput, PersonalWeatherUncheckedCreateInput>
  }

  /**
   * PersonalWeather createMany
   */
  export type PersonalWeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalWeathers.
     */
    data: PersonalWeatherCreateManyInput | PersonalWeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalWeather createManyAndReturn
   */
  export type PersonalWeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalWeathers.
     */
    data: PersonalWeatherCreateManyInput | PersonalWeatherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalWeather update
   */
  export type PersonalWeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * The data needed to update a PersonalWeather.
     */
    data: XOR<PersonalWeatherUpdateInput, PersonalWeatherUncheckedUpdateInput>
    /**
     * Choose, which PersonalWeather to update.
     */
    where: PersonalWeatherWhereUniqueInput
  }

  /**
   * PersonalWeather updateMany
   */
  export type PersonalWeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalWeathers.
     */
    data: XOR<PersonalWeatherUpdateManyMutationInput, PersonalWeatherUncheckedUpdateManyInput>
    /**
     * Filter which PersonalWeathers to update
     */
    where?: PersonalWeatherWhereInput
    /**
     * Limit how many PersonalWeathers to update.
     */
    limit?: number
  }

  /**
   * PersonalWeather updateManyAndReturn
   */
  export type PersonalWeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * The data used to update PersonalWeathers.
     */
    data: XOR<PersonalWeatherUpdateManyMutationInput, PersonalWeatherUncheckedUpdateManyInput>
    /**
     * Filter which PersonalWeathers to update
     */
    where?: PersonalWeatherWhereInput
    /**
     * Limit how many PersonalWeathers to update.
     */
    limit?: number
  }

  /**
   * PersonalWeather upsert
   */
  export type PersonalWeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * The filter to search for the PersonalWeather to update in case it exists.
     */
    where: PersonalWeatherWhereUniqueInput
    /**
     * In case the PersonalWeather found by the `where` argument doesn't exist, create a new PersonalWeather with this data.
     */
    create: XOR<PersonalWeatherCreateInput, PersonalWeatherUncheckedCreateInput>
    /**
     * In case the PersonalWeather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalWeatherUpdateInput, PersonalWeatherUncheckedUpdateInput>
  }

  /**
   * PersonalWeather delete
   */
  export type PersonalWeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
    /**
     * Filter which PersonalWeather to delete.
     */
    where: PersonalWeatherWhereUniqueInput
  }

  /**
   * PersonalWeather deleteMany
   */
  export type PersonalWeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalWeathers to delete
     */
    where?: PersonalWeatherWhereInput
    /**
     * Limit how many PersonalWeathers to delete.
     */
    limit?: number
  }

  /**
   * PersonalWeather without action
   */
  export type PersonalWeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalWeather
     */
    select?: PersonalWeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalWeather
     */
    omit?: PersonalWeatherOmit<ExtArgs> | null
  }


  /**
   * Model Study
   */

  export type AggregateStudy = {
    _count: StudyCountAggregateOutputType | null
    _avg: StudyAvgAggregateOutputType | null
    _sum: StudySumAggregateOutputType | null
    _min: StudyMinAggregateOutputType | null
    _max: StudyMaxAggregateOutputType | null
  }

  export type StudyAvgAggregateOutputType = {
    consentVersion: number | null
    maxParticipants: number | null
  }

  export type StudySumAggregateOutputType = {
    consentVersion: number | null
    maxParticipants: number | null
  }

  export type StudyMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    institution: string | null
    duration: string | null
    consentText: string | null
    consentVersion: number | null
    status: string | null
    startsAt: Date | null
    endsAt: Date | null
    maxParticipants: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    institution: string | null
    duration: string | null
    consentText: string | null
    consentVersion: number | null
    status: string | null
    startsAt: Date | null
    endsAt: Date | null
    maxParticipants: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    institution: number
    dataScope: number
    duration: number
    consentText: number
    consentVersion: number
    status: number
    startsAt: number
    endsAt: number
    maxParticipants: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudyAvgAggregateInputType = {
    consentVersion?: true
    maxParticipants?: true
  }

  export type StudySumAggregateInputType = {
    consentVersion?: true
    maxParticipants?: true
  }

  export type StudyMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    institution?: true
    duration?: true
    consentText?: true
    consentVersion?: true
    status?: true
    startsAt?: true
    endsAt?: true
    maxParticipants?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    institution?: true
    duration?: true
    consentText?: true
    consentVersion?: true
    status?: true
    startsAt?: true
    endsAt?: true
    maxParticipants?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    institution?: true
    dataScope?: true
    duration?: true
    consentText?: true
    consentVersion?: true
    status?: true
    startsAt?: true
    endsAt?: true
    maxParticipants?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Study to aggregate.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Studies
    **/
    _count?: true | StudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyMaxAggregateInputType
  }

  export type GetStudyAggregateType<T extends StudyAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy[P]>
      : GetScalarType<T[P], AggregateStudy[P]>
  }




  export type StudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyWhereInput
    orderBy?: StudyOrderByWithAggregationInput | StudyOrderByWithAggregationInput[]
    by: StudyScalarFieldEnum[] | StudyScalarFieldEnum
    having?: StudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyCountAggregateInputType | true
    _avg?: StudyAvgAggregateInputType
    _sum?: StudySumAggregateInputType
    _min?: StudyMinAggregateInputType
    _max?: StudyMaxAggregateInputType
  }

  export type StudyGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string
    institution: string | null
    dataScope: JsonValue
    duration: string | null
    consentText: string
    consentVersion: number
    status: string
    startsAt: Date | null
    endsAt: Date | null
    maxParticipants: number | null
    createdAt: Date
    updatedAt: Date
    _count: StudyCountAggregateOutputType | null
    _avg: StudyAvgAggregateOutputType | null
    _sum: StudySumAggregateOutputType | null
    _min: StudyMinAggregateOutputType | null
    _max: StudyMaxAggregateOutputType | null
  }

  type GetStudyGroupByPayload<T extends StudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyGroupByOutputType[P]>
            : GetScalarType<T[P], StudyGroupByOutputType[P]>
        }
      >
    >


  export type StudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    institution?: boolean
    dataScope?: boolean
    duration?: boolean
    consentText?: boolean
    consentVersion?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxParticipants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prompts?: boolean | Study$promptsArgs<ExtArgs>
    participations?: boolean | Study$participationsArgs<ExtArgs>
    _count?: boolean | StudyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study"]>

  export type StudySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    institution?: boolean
    dataScope?: boolean
    duration?: boolean
    consentText?: boolean
    consentVersion?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxParticipants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["study"]>

  export type StudySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    institution?: boolean
    dataScope?: boolean
    duration?: boolean
    consentText?: boolean
    consentVersion?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxParticipants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["study"]>

  export type StudySelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    institution?: boolean
    dataScope?: boolean
    duration?: boolean
    consentText?: boolean
    consentVersion?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    maxParticipants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "description" | "institution" | "dataScope" | "duration" | "consentText" | "consentVersion" | "status" | "startsAt" | "endsAt" | "maxParticipants" | "createdAt" | "updatedAt", ExtArgs["result"]["study"]>
  export type StudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompts?: boolean | Study$promptsArgs<ExtArgs>
    participations?: boolean | Study$participationsArgs<ExtArgs>
    _count?: boolean | StudyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StudyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Study"
    objects: {
      prompts: Prisma.$PromptPayload<ExtArgs>[]
      participations: Prisma.$StudyParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string
      institution: string | null
      dataScope: Prisma.JsonValue
      duration: string | null
      consentText: string
      consentVersion: number
      status: string
      startsAt: Date | null
      endsAt: Date | null
      maxParticipants: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["study"]>
    composites: {}
  }

  type StudyGetPayload<S extends boolean | null | undefined | StudyDefaultArgs> = $Result.GetResult<Prisma.$StudyPayload, S>

  type StudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyCountAggregateInputType | true
    }

  export interface StudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Study'], meta: { name: 'Study' } }
    /**
     * Find zero or one Study that matches the filter.
     * @param {StudyFindUniqueArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyFindUniqueArgs>(args: SelectSubset<T, StudyFindUniqueArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyFindUniqueOrThrowArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindFirstArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyFindFirstArgs>(args?: SelectSubset<T, StudyFindFirstArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindFirstOrThrowArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Studies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Studies
     * const studies = await prisma.study.findMany()
     * 
     * // Get first 10 Studies
     * const studies = await prisma.study.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyWithIdOnly = await prisma.study.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyFindManyArgs>(args?: SelectSubset<T, StudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study.
     * @param {StudyCreateArgs} args - Arguments to create a Study.
     * @example
     * // Create one Study
     * const Study = await prisma.study.create({
     *   data: {
     *     // ... data to create a Study
     *   }
     * })
     * 
     */
    create<T extends StudyCreateArgs>(args: SelectSubset<T, StudyCreateArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Studies.
     * @param {StudyCreateManyArgs} args - Arguments to create many Studies.
     * @example
     * // Create many Studies
     * const study = await prisma.study.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyCreateManyArgs>(args?: SelectSubset<T, StudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Studies and returns the data saved in the database.
     * @param {StudyCreateManyAndReturnArgs} args - Arguments to create many Studies.
     * @example
     * // Create many Studies
     * const study = await prisma.study.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Studies and only return the `id`
     * const studyWithIdOnly = await prisma.study.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Study.
     * @param {StudyDeleteArgs} args - Arguments to delete one Study.
     * @example
     * // Delete one Study
     * const Study = await prisma.study.delete({
     *   where: {
     *     // ... filter to delete one Study
     *   }
     * })
     * 
     */
    delete<T extends StudyDeleteArgs>(args: SelectSubset<T, StudyDeleteArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study.
     * @param {StudyUpdateArgs} args - Arguments to update one Study.
     * @example
     * // Update one Study
     * const study = await prisma.study.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyUpdateArgs>(args: SelectSubset<T, StudyUpdateArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Studies.
     * @param {StudyDeleteManyArgs} args - Arguments to filter Studies to delete.
     * @example
     * // Delete a few Studies
     * const { count } = await prisma.study.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyDeleteManyArgs>(args?: SelectSubset<T, StudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Studies
     * const study = await prisma.study.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyUpdateManyArgs>(args: SelectSubset<T, StudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studies and returns the data updated in the database.
     * @param {StudyUpdateManyAndReturnArgs} args - Arguments to update many Studies.
     * @example
     * // Update many Studies
     * const study = await prisma.study.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Studies and only return the `id`
     * const studyWithIdOnly = await prisma.study.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Study.
     * @param {StudyUpsertArgs} args - Arguments to update or create a Study.
     * @example
     * // Update or create a Study
     * const study = await prisma.study.upsert({
     *   create: {
     *     // ... data to create a Study
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study we want to update
     *   }
     * })
     */
    upsert<T extends StudyUpsertArgs>(args: SelectSubset<T, StudyUpsertArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCountArgs} args - Arguments to filter Studies to count.
     * @example
     * // Count the number of Studies
     * const count = await prisma.study.count({
     *   where: {
     *     // ... the filter for the Studies we want to count
     *   }
     * })
    **/
    count<T extends StudyCountArgs>(
      args?: Subset<T, StudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyAggregateArgs>(args: Subset<T, StudyAggregateArgs>): Prisma.PrismaPromise<GetStudyAggregateType<T>>

    /**
     * Group by Study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyGroupByArgs['orderBy'] }
        : { orderBy?: StudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Study model
   */
  readonly fields: StudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Study.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompts<T extends Study$promptsArgs<ExtArgs> = {}>(args?: Subset<T, Study$promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participations<T extends Study$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Study$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Study model
   */
  interface StudyFieldRefs {
    readonly id: FieldRef<"Study", 'String'>
    readonly slug: FieldRef<"Study", 'String'>
    readonly title: FieldRef<"Study", 'String'>
    readonly description: FieldRef<"Study", 'String'>
    readonly institution: FieldRef<"Study", 'String'>
    readonly dataScope: FieldRef<"Study", 'Json'>
    readonly duration: FieldRef<"Study", 'String'>
    readonly consentText: FieldRef<"Study", 'String'>
    readonly consentVersion: FieldRef<"Study", 'Int'>
    readonly status: FieldRef<"Study", 'String'>
    readonly startsAt: FieldRef<"Study", 'DateTime'>
    readonly endsAt: FieldRef<"Study", 'DateTime'>
    readonly maxParticipants: FieldRef<"Study", 'Int'>
    readonly createdAt: FieldRef<"Study", 'DateTime'>
    readonly updatedAt: FieldRef<"Study", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Study findUnique
   */
  export type StudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study findUniqueOrThrow
   */
  export type StudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study findFirst
   */
  export type StudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studies.
     */
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study findFirstOrThrow
   */
  export type StudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studies.
     */
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study findMany
   */
  export type StudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Studies to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study create
   */
  export type StudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The data needed to create a Study.
     */
    data: XOR<StudyCreateInput, StudyUncheckedCreateInput>
  }

  /**
   * Study createMany
   */
  export type StudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Studies.
     */
    data: StudyCreateManyInput | StudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Study createManyAndReturn
   */
  export type StudyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * The data used to create many Studies.
     */
    data: StudyCreateManyInput | StudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Study update
   */
  export type StudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The data needed to update a Study.
     */
    data: XOR<StudyUpdateInput, StudyUncheckedUpdateInput>
    /**
     * Choose, which Study to update.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study updateMany
   */
  export type StudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Studies.
     */
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyInput>
    /**
     * Filter which Studies to update
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to update.
     */
    limit?: number
  }

  /**
   * Study updateManyAndReturn
   */
  export type StudyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * The data used to update Studies.
     */
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyInput>
    /**
     * Filter which Studies to update
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to update.
     */
    limit?: number
  }

  /**
   * Study upsert
   */
  export type StudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The filter to search for the Study to update in case it exists.
     */
    where: StudyWhereUniqueInput
    /**
     * In case the Study found by the `where` argument doesn't exist, create a new Study with this data.
     */
    create: XOR<StudyCreateInput, StudyUncheckedCreateInput>
    /**
     * In case the Study was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyUpdateInput, StudyUncheckedUpdateInput>
  }

  /**
   * Study delete
   */
  export type StudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter which Study to delete.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study deleteMany
   */
  export type StudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Studies to delete
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to delete.
     */
    limit?: number
  }

  /**
   * Study.prompts
   */
  export type Study$promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prompt
     */
    omit?: PromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Study.participations
   */
  export type Study$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    where?: StudyParticipationWhereInput
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    cursor?: StudyParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyParticipationScalarFieldEnum | StudyParticipationScalarFieldEnum[]
  }

  /**
   * Study without action
   */
  export type StudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
  }


  /**
   * Model StudyParticipation
   */

  export type AggregateStudyParticipation = {
    _count: StudyParticipationCountAggregateOutputType | null
    _avg: StudyParticipationAvgAggregateOutputType | null
    _sum: StudyParticipationSumAggregateOutputType | null
    _min: StudyParticipationMinAggregateOutputType | null
    _max: StudyParticipationMaxAggregateOutputType | null
  }

  export type StudyParticipationAvgAggregateOutputType = {
    consentVersion: number | null
  }

  export type StudyParticipationSumAggregateOutputType = {
    consentVersion: number | null
  }

  export type StudyParticipationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studyId: string | null
    consentedAt: Date | null
    consentVersion: number | null
    status: string | null
    withdrawnAt: Date | null
    withdrawalReason: string | null
    completedAt: Date | null
  }

  export type StudyParticipationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studyId: string | null
    consentedAt: Date | null
    consentVersion: number | null
    status: string | null
    withdrawnAt: Date | null
    withdrawalReason: string | null
    completedAt: Date | null
  }

  export type StudyParticipationCountAggregateOutputType = {
    id: number
    userId: number
    studyId: number
    consentedAt: number
    consentVersion: number
    status: number
    withdrawnAt: number
    withdrawalReason: number
    completedAt: number
    _all: number
  }


  export type StudyParticipationAvgAggregateInputType = {
    consentVersion?: true
  }

  export type StudyParticipationSumAggregateInputType = {
    consentVersion?: true
  }

  export type StudyParticipationMinAggregateInputType = {
    id?: true
    userId?: true
    studyId?: true
    consentedAt?: true
    consentVersion?: true
    status?: true
    withdrawnAt?: true
    withdrawalReason?: true
    completedAt?: true
  }

  export type StudyParticipationMaxAggregateInputType = {
    id?: true
    userId?: true
    studyId?: true
    consentedAt?: true
    consentVersion?: true
    status?: true
    withdrawnAt?: true
    withdrawalReason?: true
    completedAt?: true
  }

  export type StudyParticipationCountAggregateInputType = {
    id?: true
    userId?: true
    studyId?: true
    consentedAt?: true
    consentVersion?: true
    status?: true
    withdrawnAt?: true
    withdrawalReason?: true
    completedAt?: true
    _all?: true
  }

  export type StudyParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyParticipation to aggregate.
     */
    where?: StudyParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyParticipations to fetch.
     */
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyParticipations
    **/
    _count?: true | StudyParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyParticipationMaxAggregateInputType
  }

  export type GetStudyParticipationAggregateType<T extends StudyParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyParticipation[P]>
      : GetScalarType<T[P], AggregateStudyParticipation[P]>
  }




  export type StudyParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyParticipationWhereInput
    orderBy?: StudyParticipationOrderByWithAggregationInput | StudyParticipationOrderByWithAggregationInput[]
    by: StudyParticipationScalarFieldEnum[] | StudyParticipationScalarFieldEnum
    having?: StudyParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyParticipationCountAggregateInputType | true
    _avg?: StudyParticipationAvgAggregateInputType
    _sum?: StudyParticipationSumAggregateInputType
    _min?: StudyParticipationMinAggregateInputType
    _max?: StudyParticipationMaxAggregateInputType
  }

  export type StudyParticipationGroupByOutputType = {
    id: string
    userId: string
    studyId: string
    consentedAt: Date
    consentVersion: number
    status: string
    withdrawnAt: Date | null
    withdrawalReason: string | null
    completedAt: Date | null
    _count: StudyParticipationCountAggregateOutputType | null
    _avg: StudyParticipationAvgAggregateOutputType | null
    _sum: StudyParticipationSumAggregateOutputType | null
    _min: StudyParticipationMinAggregateOutputType | null
    _max: StudyParticipationMaxAggregateOutputType | null
  }

  type GetStudyParticipationGroupByPayload<T extends StudyParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], StudyParticipationGroupByOutputType[P]>
        }
      >
    >


  export type StudyParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studyId?: boolean
    consentedAt?: boolean
    consentVersion?: boolean
    status?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    completedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyParticipation"]>

  export type StudyParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studyId?: boolean
    consentedAt?: boolean
    consentVersion?: boolean
    status?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    completedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyParticipation"]>

  export type StudyParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studyId?: boolean
    consentedAt?: boolean
    consentVersion?: boolean
    status?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    completedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyParticipation"]>

  export type StudyParticipationSelectScalar = {
    id?: boolean
    userId?: boolean
    studyId?: boolean
    consentedAt?: boolean
    consentVersion?: boolean
    status?: boolean
    withdrawnAt?: boolean
    withdrawalReason?: boolean
    completedAt?: boolean
  }

  export type StudyParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studyId" | "consentedAt" | "consentVersion" | "status" | "withdrawnAt" | "withdrawalReason" | "completedAt", ExtArgs["result"]["studyParticipation"]>
  export type StudyParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyParticipation"
    objects: {
      study: Prisma.$StudyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studyId: string
      consentedAt: Date
      consentVersion: number
      status: string
      withdrawnAt: Date | null
      withdrawalReason: string | null
      completedAt: Date | null
    }, ExtArgs["result"]["studyParticipation"]>
    composites: {}
  }

  type StudyParticipationGetPayload<S extends boolean | null | undefined | StudyParticipationDefaultArgs> = $Result.GetResult<Prisma.$StudyParticipationPayload, S>

  type StudyParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyParticipationCountAggregateInputType | true
    }

  export interface StudyParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyParticipation'], meta: { name: 'StudyParticipation' } }
    /**
     * Find zero or one StudyParticipation that matches the filter.
     * @param {StudyParticipationFindUniqueArgs} args - Arguments to find a StudyParticipation
     * @example
     * // Get one StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyParticipationFindUniqueArgs>(args: SelectSubset<T, StudyParticipationFindUniqueArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudyParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyParticipationFindUniqueOrThrowArgs} args - Arguments to find a StudyParticipation
     * @example
     * // Get one StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationFindFirstArgs} args - Arguments to find a StudyParticipation
     * @example
     * // Get one StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyParticipationFindFirstArgs>(args?: SelectSubset<T, StudyParticipationFindFirstArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationFindFirstOrThrowArgs} args - Arguments to find a StudyParticipation
     * @example
     * // Get one StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudyParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyParticipations
     * const studyParticipations = await prisma.studyParticipation.findMany()
     * 
     * // Get first 10 StudyParticipations
     * const studyParticipations = await prisma.studyParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyParticipationWithIdOnly = await prisma.studyParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyParticipationFindManyArgs>(args?: SelectSubset<T, StudyParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudyParticipation.
     * @param {StudyParticipationCreateArgs} args - Arguments to create a StudyParticipation.
     * @example
     * // Create one StudyParticipation
     * const StudyParticipation = await prisma.studyParticipation.create({
     *   data: {
     *     // ... data to create a StudyParticipation
     *   }
     * })
     * 
     */
    create<T extends StudyParticipationCreateArgs>(args: SelectSubset<T, StudyParticipationCreateArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudyParticipations.
     * @param {StudyParticipationCreateManyArgs} args - Arguments to create many StudyParticipations.
     * @example
     * // Create many StudyParticipations
     * const studyParticipation = await prisma.studyParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyParticipationCreateManyArgs>(args?: SelectSubset<T, StudyParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyParticipations and returns the data saved in the database.
     * @param {StudyParticipationCreateManyAndReturnArgs} args - Arguments to create many StudyParticipations.
     * @example
     * // Create many StudyParticipations
     * const studyParticipation = await prisma.studyParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyParticipations and only return the `id`
     * const studyParticipationWithIdOnly = await prisma.studyParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudyParticipation.
     * @param {StudyParticipationDeleteArgs} args - Arguments to delete one StudyParticipation.
     * @example
     * // Delete one StudyParticipation
     * const StudyParticipation = await prisma.studyParticipation.delete({
     *   where: {
     *     // ... filter to delete one StudyParticipation
     *   }
     * })
     * 
     */
    delete<T extends StudyParticipationDeleteArgs>(args: SelectSubset<T, StudyParticipationDeleteArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudyParticipation.
     * @param {StudyParticipationUpdateArgs} args - Arguments to update one StudyParticipation.
     * @example
     * // Update one StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyParticipationUpdateArgs>(args: SelectSubset<T, StudyParticipationUpdateArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudyParticipations.
     * @param {StudyParticipationDeleteManyArgs} args - Arguments to filter StudyParticipations to delete.
     * @example
     * // Delete a few StudyParticipations
     * const { count } = await prisma.studyParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyParticipationDeleteManyArgs>(args?: SelectSubset<T, StudyParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyParticipations
     * const studyParticipation = await prisma.studyParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyParticipationUpdateManyArgs>(args: SelectSubset<T, StudyParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyParticipations and returns the data updated in the database.
     * @param {StudyParticipationUpdateManyAndReturnArgs} args - Arguments to update many StudyParticipations.
     * @example
     * // Update many StudyParticipations
     * const studyParticipation = await prisma.studyParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudyParticipations and only return the `id`
     * const studyParticipationWithIdOnly = await prisma.studyParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudyParticipation.
     * @param {StudyParticipationUpsertArgs} args - Arguments to update or create a StudyParticipation.
     * @example
     * // Update or create a StudyParticipation
     * const studyParticipation = await prisma.studyParticipation.upsert({
     *   create: {
     *     // ... data to create a StudyParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyParticipation we want to update
     *   }
     * })
     */
    upsert<T extends StudyParticipationUpsertArgs>(args: SelectSubset<T, StudyParticipationUpsertArgs<ExtArgs>>): Prisma__StudyParticipationClient<$Result.GetResult<Prisma.$StudyParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudyParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationCountArgs} args - Arguments to filter StudyParticipations to count.
     * @example
     * // Count the number of StudyParticipations
     * const count = await prisma.studyParticipation.count({
     *   where: {
     *     // ... the filter for the StudyParticipations we want to count
     *   }
     * })
    **/
    count<T extends StudyParticipationCountArgs>(
      args?: Subset<T, StudyParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyParticipationAggregateArgs>(args: Subset<T, StudyParticipationAggregateArgs>): Prisma.PrismaPromise<GetStudyParticipationAggregateType<T>>

    /**
     * Group by StudyParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyParticipationGroupByArgs['orderBy'] }
        : { orderBy?: StudyParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyParticipation model
   */
  readonly fields: StudyParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    study<T extends StudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyDefaultArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyParticipation model
   */
  interface StudyParticipationFieldRefs {
    readonly id: FieldRef<"StudyParticipation", 'String'>
    readonly userId: FieldRef<"StudyParticipation", 'String'>
    readonly studyId: FieldRef<"StudyParticipation", 'String'>
    readonly consentedAt: FieldRef<"StudyParticipation", 'DateTime'>
    readonly consentVersion: FieldRef<"StudyParticipation", 'Int'>
    readonly status: FieldRef<"StudyParticipation", 'String'>
    readonly withdrawnAt: FieldRef<"StudyParticipation", 'DateTime'>
    readonly withdrawalReason: FieldRef<"StudyParticipation", 'String'>
    readonly completedAt: FieldRef<"StudyParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyParticipation findUnique
   */
  export type StudyParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter, which StudyParticipation to fetch.
     */
    where: StudyParticipationWhereUniqueInput
  }

  /**
   * StudyParticipation findUniqueOrThrow
   */
  export type StudyParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter, which StudyParticipation to fetch.
     */
    where: StudyParticipationWhereUniqueInput
  }

  /**
   * StudyParticipation findFirst
   */
  export type StudyParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter, which StudyParticipation to fetch.
     */
    where?: StudyParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyParticipations to fetch.
     */
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyParticipations.
     */
    cursor?: StudyParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyParticipations.
     */
    distinct?: StudyParticipationScalarFieldEnum | StudyParticipationScalarFieldEnum[]
  }

  /**
   * StudyParticipation findFirstOrThrow
   */
  export type StudyParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter, which StudyParticipation to fetch.
     */
    where?: StudyParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyParticipations to fetch.
     */
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyParticipations.
     */
    cursor?: StudyParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyParticipations.
     */
    distinct?: StudyParticipationScalarFieldEnum | StudyParticipationScalarFieldEnum[]
  }

  /**
   * StudyParticipation findMany
   */
  export type StudyParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter, which StudyParticipations to fetch.
     */
    where?: StudyParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyParticipations to fetch.
     */
    orderBy?: StudyParticipationOrderByWithRelationInput | StudyParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyParticipations.
     */
    cursor?: StudyParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyParticipations.
     */
    skip?: number
    distinct?: StudyParticipationScalarFieldEnum | StudyParticipationScalarFieldEnum[]
  }

  /**
   * StudyParticipation create
   */
  export type StudyParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyParticipation.
     */
    data: XOR<StudyParticipationCreateInput, StudyParticipationUncheckedCreateInput>
  }

  /**
   * StudyParticipation createMany
   */
  export type StudyParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyParticipations.
     */
    data: StudyParticipationCreateManyInput | StudyParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyParticipation createManyAndReturn
   */
  export type StudyParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many StudyParticipations.
     */
    data: StudyParticipationCreateManyInput | StudyParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyParticipation update
   */
  export type StudyParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyParticipation.
     */
    data: XOR<StudyParticipationUpdateInput, StudyParticipationUncheckedUpdateInput>
    /**
     * Choose, which StudyParticipation to update.
     */
    where: StudyParticipationWhereUniqueInput
  }

  /**
   * StudyParticipation updateMany
   */
  export type StudyParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyParticipations.
     */
    data: XOR<StudyParticipationUpdateManyMutationInput, StudyParticipationUncheckedUpdateManyInput>
    /**
     * Filter which StudyParticipations to update
     */
    where?: StudyParticipationWhereInput
    /**
     * Limit how many StudyParticipations to update.
     */
    limit?: number
  }

  /**
   * StudyParticipation updateManyAndReturn
   */
  export type StudyParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * The data used to update StudyParticipations.
     */
    data: XOR<StudyParticipationUpdateManyMutationInput, StudyParticipationUncheckedUpdateManyInput>
    /**
     * Filter which StudyParticipations to update
     */
    where?: StudyParticipationWhereInput
    /**
     * Limit how many StudyParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyParticipation upsert
   */
  export type StudyParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyParticipation to update in case it exists.
     */
    where: StudyParticipationWhereUniqueInput
    /**
     * In case the StudyParticipation found by the `where` argument doesn't exist, create a new StudyParticipation with this data.
     */
    create: XOR<StudyParticipationCreateInput, StudyParticipationUncheckedCreateInput>
    /**
     * In case the StudyParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyParticipationUpdateInput, StudyParticipationUncheckedUpdateInput>
  }

  /**
   * StudyParticipation delete
   */
  export type StudyParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
    /**
     * Filter which StudyParticipation to delete.
     */
    where: StudyParticipationWhereUniqueInput
  }

  /**
   * StudyParticipation deleteMany
   */
  export type StudyParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyParticipations to delete
     */
    where?: StudyParticipationWhereInput
    /**
     * Limit how many StudyParticipations to delete.
     */
    limit?: number
  }

  /**
   * StudyParticipation without action
   */
  export type StudyParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyParticipation
     */
    select?: StudyParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyParticipation
     */
    omit?: StudyParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyParticipationInclude<ExtArgs> | null
  }


  /**
   * Model Emotion
   */

  export type AggregateEmotion = {
    _count: EmotionCountAggregateOutputType | null
    _avg: EmotionAvgAggregateOutputType | null
    _sum: EmotionSumAggregateOutputType | null
    _min: EmotionMinAggregateOutputType | null
    _max: EmotionMaxAggregateOutputType | null
  }

  export type EmotionAvgAggregateOutputType = {
    valence: number | null
    arousal: number | null
    version: number | null
  }

  export type EmotionSumAggregateOutputType = {
    valence: number | null
    arousal: number | null
    version: number | null
  }

  export type EmotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    valence: number | null
    arousal: number | null
    parentId: string | null
    version: number | null
  }

  export type EmotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    valence: number | null
    arousal: number | null
    parentId: string | null
    version: number | null
  }

  export type EmotionCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    valence: number
    arousal: number
    parentId: number
    translations: number
    version: number
    _all: number
  }


  export type EmotionAvgAggregateInputType = {
    valence?: true
    arousal?: true
    version?: true
  }

  export type EmotionSumAggregateInputType = {
    valence?: true
    arousal?: true
    version?: true
  }

  export type EmotionMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    valence?: true
    arousal?: true
    parentId?: true
    version?: true
  }

  export type EmotionMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    valence?: true
    arousal?: true
    parentId?: true
    version?: true
  }

  export type EmotionCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    valence?: true
    arousal?: true
    parentId?: true
    translations?: true
    version?: true
    _all?: true
  }

  export type EmotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emotion to aggregate.
     */
    where?: EmotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emotions to fetch.
     */
    orderBy?: EmotionOrderByWithRelationInput | EmotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emotions
    **/
    _count?: true | EmotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmotionMaxAggregateInputType
  }

  export type GetEmotionAggregateType<T extends EmotionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmotion[P]>
      : GetScalarType<T[P], AggregateEmotion[P]>
  }




  export type EmotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmotionWhereInput
    orderBy?: EmotionOrderByWithAggregationInput | EmotionOrderByWithAggregationInput[]
    by: EmotionScalarFieldEnum[] | EmotionScalarFieldEnum
    having?: EmotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmotionCountAggregateInputType | true
    _avg?: EmotionAvgAggregateInputType
    _sum?: EmotionSumAggregateInputType
    _min?: EmotionMinAggregateInputType
    _max?: EmotionMaxAggregateInputType
  }

  export type EmotionGroupByOutputType = {
    id: string
    name: string
    slug: string
    valence: number
    arousal: number
    parentId: string | null
    translations: JsonValue | null
    version: number
    _count: EmotionCountAggregateOutputType | null
    _avg: EmotionAvgAggregateOutputType | null
    _sum: EmotionSumAggregateOutputType | null
    _min: EmotionMinAggregateOutputType | null
    _max: EmotionMaxAggregateOutputType | null
  }

  type GetEmotionGroupByPayload<T extends EmotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmotionGroupByOutputType[P]>
            : GetScalarType<T[P], EmotionGroupByOutputType[P]>
        }
      >
    >


  export type EmotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    valence?: boolean
    arousal?: boolean
    parentId?: boolean
    translations?: boolean
    version?: boolean
    parent?: boolean | Emotion$parentArgs<ExtArgs>
    children?: boolean | Emotion$childrenArgs<ExtArgs>
    _count?: boolean | EmotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emotion"]>

  export type EmotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    valence?: boolean
    arousal?: boolean
    parentId?: boolean
    translations?: boolean
    version?: boolean
    parent?: boolean | Emotion$parentArgs<ExtArgs>
  }, ExtArgs["result"]["emotion"]>

  export type EmotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    valence?: boolean
    arousal?: boolean
    parentId?: boolean
    translations?: boolean
    version?: boolean
    parent?: boolean | Emotion$parentArgs<ExtArgs>
  }, ExtArgs["result"]["emotion"]>

  export type EmotionSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    valence?: boolean
    arousal?: boolean
    parentId?: boolean
    translations?: boolean
    version?: boolean
  }

  export type EmotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "valence" | "arousal" | "parentId" | "translations" | "version", ExtArgs["result"]["emotion"]>
  export type EmotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Emotion$parentArgs<ExtArgs>
    children?: boolean | Emotion$childrenArgs<ExtArgs>
    _count?: boolean | EmotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Emotion$parentArgs<ExtArgs>
  }
  export type EmotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Emotion$parentArgs<ExtArgs>
  }

  export type $EmotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emotion"
    objects: {
      parent: Prisma.$EmotionPayload<ExtArgs> | null
      children: Prisma.$EmotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      valence: number
      arousal: number
      parentId: string | null
      translations: Prisma.JsonValue | null
      version: number
    }, ExtArgs["result"]["emotion"]>
    composites: {}
  }

  type EmotionGetPayload<S extends boolean | null | undefined | EmotionDefaultArgs> = $Result.GetResult<Prisma.$EmotionPayload, S>

  type EmotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmotionCountAggregateInputType | true
    }

  export interface EmotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emotion'], meta: { name: 'Emotion' } }
    /**
     * Find zero or one Emotion that matches the filter.
     * @param {EmotionFindUniqueArgs} args - Arguments to find a Emotion
     * @example
     * // Get one Emotion
     * const emotion = await prisma.emotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmotionFindUniqueArgs>(args: SelectSubset<T, EmotionFindUniqueArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmotionFindUniqueOrThrowArgs} args - Arguments to find a Emotion
     * @example
     * // Get one Emotion
     * const emotion = await prisma.emotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmotionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionFindFirstArgs} args - Arguments to find a Emotion
     * @example
     * // Get one Emotion
     * const emotion = await prisma.emotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmotionFindFirstArgs>(args?: SelectSubset<T, EmotionFindFirstArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionFindFirstOrThrowArgs} args - Arguments to find a Emotion
     * @example
     * // Get one Emotion
     * const emotion = await prisma.emotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmotionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emotions
     * const emotions = await prisma.emotion.findMany()
     * 
     * // Get first 10 Emotions
     * const emotions = await prisma.emotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emotionWithIdOnly = await prisma.emotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmotionFindManyArgs>(args?: SelectSubset<T, EmotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emotion.
     * @param {EmotionCreateArgs} args - Arguments to create a Emotion.
     * @example
     * // Create one Emotion
     * const Emotion = await prisma.emotion.create({
     *   data: {
     *     // ... data to create a Emotion
     *   }
     * })
     * 
     */
    create<T extends EmotionCreateArgs>(args: SelectSubset<T, EmotionCreateArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emotions.
     * @param {EmotionCreateManyArgs} args - Arguments to create many Emotions.
     * @example
     * // Create many Emotions
     * const emotion = await prisma.emotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmotionCreateManyArgs>(args?: SelectSubset<T, EmotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emotions and returns the data saved in the database.
     * @param {EmotionCreateManyAndReturnArgs} args - Arguments to create many Emotions.
     * @example
     * // Create many Emotions
     * const emotion = await prisma.emotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emotions and only return the `id`
     * const emotionWithIdOnly = await prisma.emotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmotionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Emotion.
     * @param {EmotionDeleteArgs} args - Arguments to delete one Emotion.
     * @example
     * // Delete one Emotion
     * const Emotion = await prisma.emotion.delete({
     *   where: {
     *     // ... filter to delete one Emotion
     *   }
     * })
     * 
     */
    delete<T extends EmotionDeleteArgs>(args: SelectSubset<T, EmotionDeleteArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emotion.
     * @param {EmotionUpdateArgs} args - Arguments to update one Emotion.
     * @example
     * // Update one Emotion
     * const emotion = await prisma.emotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmotionUpdateArgs>(args: SelectSubset<T, EmotionUpdateArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emotions.
     * @param {EmotionDeleteManyArgs} args - Arguments to filter Emotions to delete.
     * @example
     * // Delete a few Emotions
     * const { count } = await prisma.emotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmotionDeleteManyArgs>(args?: SelectSubset<T, EmotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emotions
     * const emotion = await prisma.emotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmotionUpdateManyArgs>(args: SelectSubset<T, EmotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emotions and returns the data updated in the database.
     * @param {EmotionUpdateManyAndReturnArgs} args - Arguments to update many Emotions.
     * @example
     * // Update many Emotions
     * const emotion = await prisma.emotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emotions and only return the `id`
     * const emotionWithIdOnly = await prisma.emotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmotionUpdateManyAndReturnArgs>(args: SelectSubset<T, EmotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Emotion.
     * @param {EmotionUpsertArgs} args - Arguments to update or create a Emotion.
     * @example
     * // Update or create a Emotion
     * const emotion = await prisma.emotion.upsert({
     *   create: {
     *     // ... data to create a Emotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emotion we want to update
     *   }
     * })
     */
    upsert<T extends EmotionUpsertArgs>(args: SelectSubset<T, EmotionUpsertArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionCountArgs} args - Arguments to filter Emotions to count.
     * @example
     * // Count the number of Emotions
     * const count = await prisma.emotion.count({
     *   where: {
     *     // ... the filter for the Emotions we want to count
     *   }
     * })
    **/
    count<T extends EmotionCountArgs>(
      args?: Subset<T, EmotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmotionAggregateArgs>(args: Subset<T, EmotionAggregateArgs>): Prisma.PrismaPromise<GetEmotionAggregateType<T>>

    /**
     * Group by Emotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmotionGroupByArgs['orderBy'] }
        : { orderBy?: EmotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emotion model
   */
  readonly fields: EmotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Emotion$parentArgs<ExtArgs> = {}>(args?: Subset<T, Emotion$parentArgs<ExtArgs>>): Prisma__EmotionClient<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Emotion$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Emotion$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emotion model
   */
  interface EmotionFieldRefs {
    readonly id: FieldRef<"Emotion", 'String'>
    readonly name: FieldRef<"Emotion", 'String'>
    readonly slug: FieldRef<"Emotion", 'String'>
    readonly valence: FieldRef<"Emotion", 'Float'>
    readonly arousal: FieldRef<"Emotion", 'Float'>
    readonly parentId: FieldRef<"Emotion", 'String'>
    readonly translations: FieldRef<"Emotion", 'Json'>
    readonly version: FieldRef<"Emotion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Emotion findUnique
   */
  export type EmotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter, which Emotion to fetch.
     */
    where: EmotionWhereUniqueInput
  }

  /**
   * Emotion findUniqueOrThrow
   */
  export type EmotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter, which Emotion to fetch.
     */
    where: EmotionWhereUniqueInput
  }

  /**
   * Emotion findFirst
   */
  export type EmotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter, which Emotion to fetch.
     */
    where?: EmotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emotions to fetch.
     */
    orderBy?: EmotionOrderByWithRelationInput | EmotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emotions.
     */
    cursor?: EmotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emotions.
     */
    distinct?: EmotionScalarFieldEnum | EmotionScalarFieldEnum[]
  }

  /**
   * Emotion findFirstOrThrow
   */
  export type EmotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter, which Emotion to fetch.
     */
    where?: EmotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emotions to fetch.
     */
    orderBy?: EmotionOrderByWithRelationInput | EmotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emotions.
     */
    cursor?: EmotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emotions.
     */
    distinct?: EmotionScalarFieldEnum | EmotionScalarFieldEnum[]
  }

  /**
   * Emotion findMany
   */
  export type EmotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter, which Emotions to fetch.
     */
    where?: EmotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emotions to fetch.
     */
    orderBy?: EmotionOrderByWithRelationInput | EmotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emotions.
     */
    cursor?: EmotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emotions.
     */
    skip?: number
    distinct?: EmotionScalarFieldEnum | EmotionScalarFieldEnum[]
  }

  /**
   * Emotion create
   */
  export type EmotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Emotion.
     */
    data: XOR<EmotionCreateInput, EmotionUncheckedCreateInput>
  }

  /**
   * Emotion createMany
   */
  export type EmotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emotions.
     */
    data: EmotionCreateManyInput | EmotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emotion createManyAndReturn
   */
  export type EmotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * The data used to create many Emotions.
     */
    data: EmotionCreateManyInput | EmotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emotion update
   */
  export type EmotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Emotion.
     */
    data: XOR<EmotionUpdateInput, EmotionUncheckedUpdateInput>
    /**
     * Choose, which Emotion to update.
     */
    where: EmotionWhereUniqueInput
  }

  /**
   * Emotion updateMany
   */
  export type EmotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emotions.
     */
    data: XOR<EmotionUpdateManyMutationInput, EmotionUncheckedUpdateManyInput>
    /**
     * Filter which Emotions to update
     */
    where?: EmotionWhereInput
    /**
     * Limit how many Emotions to update.
     */
    limit?: number
  }

  /**
   * Emotion updateManyAndReturn
   */
  export type EmotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * The data used to update Emotions.
     */
    data: XOR<EmotionUpdateManyMutationInput, EmotionUncheckedUpdateManyInput>
    /**
     * Filter which Emotions to update
     */
    where?: EmotionWhereInput
    /**
     * Limit how many Emotions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emotion upsert
   */
  export type EmotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Emotion to update in case it exists.
     */
    where: EmotionWhereUniqueInput
    /**
     * In case the Emotion found by the `where` argument doesn't exist, create a new Emotion with this data.
     */
    create: XOR<EmotionCreateInput, EmotionUncheckedCreateInput>
    /**
     * In case the Emotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmotionUpdateInput, EmotionUncheckedUpdateInput>
  }

  /**
   * Emotion delete
   */
  export type EmotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    /**
     * Filter which Emotion to delete.
     */
    where: EmotionWhereUniqueInput
  }

  /**
   * Emotion deleteMany
   */
  export type EmotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emotions to delete
     */
    where?: EmotionWhereInput
    /**
     * Limit how many Emotions to delete.
     */
    limit?: number
  }

  /**
   * Emotion.parent
   */
  export type Emotion$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    where?: EmotionWhereInput
  }

  /**
   * Emotion.children
   */
  export type Emotion$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
    where?: EmotionWhereInput
    orderBy?: EmotionOrderByWithRelationInput | EmotionOrderByWithRelationInput[]
    cursor?: EmotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmotionScalarFieldEnum | EmotionScalarFieldEnum[]
  }

  /**
   * Emotion without action
   */
  export type EmotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emotion
     */
    select?: EmotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emotion
     */
    omit?: EmotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionInclude<ExtArgs> | null
  }


  /**
   * Model Symbol
   */

  export type AggregateSymbol = {
    _count: SymbolCountAggregateOutputType | null
    _avg: SymbolAvgAggregateOutputType | null
    _sum: SymbolSumAggregateOutputType | null
    _min: SymbolMinAggregateOutputType | null
    _max: SymbolMaxAggregateOutputType | null
  }

  export type SymbolAvgAggregateOutputType = {
    version: number | null
  }

  export type SymbolSumAggregateOutputType = {
    version: number | null
  }

  export type SymbolMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    description: string | null
    version: number | null
  }

  export type SymbolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    category: string | null
    description: string | null
    version: number | null
  }

  export type SymbolCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    category: number
    description: number
    interpretations: number
    translations: number
    version: number
    _all: number
  }


  export type SymbolAvgAggregateInputType = {
    version?: true
  }

  export type SymbolSumAggregateInputType = {
    version?: true
  }

  export type SymbolMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    description?: true
    version?: true
  }

  export type SymbolMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    description?: true
    version?: true
  }

  export type SymbolCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    category?: true
    description?: true
    interpretations?: true
    translations?: true
    version?: true
    _all?: true
  }

  export type SymbolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symbol to aggregate.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Symbols
    **/
    _count?: true | SymbolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymbolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymbolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymbolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymbolMaxAggregateInputType
  }

  export type GetSymbolAggregateType<T extends SymbolAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbol[P]>
      : GetScalarType<T[P], AggregateSymbol[P]>
  }




  export type SymbolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymbolWhereInput
    orderBy?: SymbolOrderByWithAggregationInput | SymbolOrderByWithAggregationInput[]
    by: SymbolScalarFieldEnum[] | SymbolScalarFieldEnum
    having?: SymbolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymbolCountAggregateInputType | true
    _avg?: SymbolAvgAggregateInputType
    _sum?: SymbolSumAggregateInputType
    _min?: SymbolMinAggregateInputType
    _max?: SymbolMaxAggregateInputType
  }

  export type SymbolGroupByOutputType = {
    id: string
    name: string
    slug: string
    category: string
    description: string | null
    interpretations: JsonValue | null
    translations: JsonValue | null
    version: number
    _count: SymbolCountAggregateOutputType | null
    _avg: SymbolAvgAggregateOutputType | null
    _sum: SymbolSumAggregateOutputType | null
    _min: SymbolMinAggregateOutputType | null
    _max: SymbolMaxAggregateOutputType | null
  }

  type GetSymbolGroupByPayload<T extends SymbolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymbolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymbolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolGroupByOutputType[P]>
        }
      >
    >


  export type SymbolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    description?: boolean
    interpretations?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["symbol"]>

  export type SymbolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    description?: boolean
    interpretations?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["symbol"]>

  export type SymbolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    description?: boolean
    interpretations?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["symbol"]>

  export type SymbolSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    category?: boolean
    description?: boolean
    interpretations?: boolean
    translations?: boolean
    version?: boolean
  }

  export type SymbolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "category" | "description" | "interpretations" | "translations" | "version", ExtArgs["result"]["symbol"]>

  export type $SymbolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Symbol"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      category: string
      description: string | null
      interpretations: Prisma.JsonValue | null
      translations: Prisma.JsonValue | null
      version: number
    }, ExtArgs["result"]["symbol"]>
    composites: {}
  }

  type SymbolGetPayload<S extends boolean | null | undefined | SymbolDefaultArgs> = $Result.GetResult<Prisma.$SymbolPayload, S>

  type SymbolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SymbolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SymbolCountAggregateInputType | true
    }

  export interface SymbolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Symbol'], meta: { name: 'Symbol' } }
    /**
     * Find zero or one Symbol that matches the filter.
     * @param {SymbolFindUniqueArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymbolFindUniqueArgs>(args: SelectSubset<T, SymbolFindUniqueArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Symbol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SymbolFindUniqueOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymbolFindUniqueOrThrowArgs>(args: SelectSubset<T, SymbolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindFirstArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymbolFindFirstArgs>(args?: SelectSubset<T, SymbolFindFirstArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindFirstOrThrowArgs} args - Arguments to find a Symbol
     * @example
     * // Get one Symbol
     * const symbol = await prisma.symbol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymbolFindFirstOrThrowArgs>(args?: SelectSubset<T, SymbolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbol.findMany()
     * 
     * // Get first 10 Symbols
     * const symbols = await prisma.symbol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbolWithIdOnly = await prisma.symbol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymbolFindManyArgs>(args?: SelectSubset<T, SymbolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Symbol.
     * @param {SymbolCreateArgs} args - Arguments to create a Symbol.
     * @example
     * // Create one Symbol
     * const Symbol = await prisma.symbol.create({
     *   data: {
     *     // ... data to create a Symbol
     *   }
     * })
     * 
     */
    create<T extends SymbolCreateArgs>(args: SelectSubset<T, SymbolCreateArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Symbols.
     * @param {SymbolCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymbolCreateManyArgs>(args?: SelectSubset<T, SymbolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {SymbolCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbol = await prisma.symbol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symbols and only return the `id`
     * const symbolWithIdOnly = await prisma.symbol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymbolCreateManyAndReturnArgs>(args?: SelectSubset<T, SymbolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Symbol.
     * @param {SymbolDeleteArgs} args - Arguments to delete one Symbol.
     * @example
     * // Delete one Symbol
     * const Symbol = await prisma.symbol.delete({
     *   where: {
     *     // ... filter to delete one Symbol
     *   }
     * })
     * 
     */
    delete<T extends SymbolDeleteArgs>(args: SelectSubset<T, SymbolDeleteArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Symbol.
     * @param {SymbolUpdateArgs} args - Arguments to update one Symbol.
     * @example
     * // Update one Symbol
     * const symbol = await prisma.symbol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymbolUpdateArgs>(args: SelectSubset<T, SymbolUpdateArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Symbols.
     * @param {SymbolDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymbolDeleteManyArgs>(args?: SelectSubset<T, SymbolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbol = await prisma.symbol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymbolUpdateManyArgs>(args: SelectSubset<T, SymbolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols and returns the data updated in the database.
     * @param {SymbolUpdateManyAndReturnArgs} args - Arguments to update many Symbols.
     * @example
     * // Update many Symbols
     * const symbol = await prisma.symbol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Symbols and only return the `id`
     * const symbolWithIdOnly = await prisma.symbol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SymbolUpdateManyAndReturnArgs>(args: SelectSubset<T, SymbolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Symbol.
     * @param {SymbolUpsertArgs} args - Arguments to update or create a Symbol.
     * @example
     * // Update or create a Symbol
     * const symbol = await prisma.symbol.upsert({
     *   create: {
     *     // ... data to create a Symbol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbol we want to update
     *   }
     * })
     */
    upsert<T extends SymbolUpsertArgs>(args: SelectSubset<T, SymbolUpsertArgs<ExtArgs>>): Prisma__SymbolClient<$Result.GetResult<Prisma.$SymbolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbol.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
    **/
    count<T extends SymbolCountArgs>(
      args?: Subset<T, SymbolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymbolAggregateArgs>(args: Subset<T, SymbolAggregateArgs>): Prisma.PrismaPromise<GetSymbolAggregateType<T>>

    /**
     * Group by Symbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymbolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymbolGroupByArgs['orderBy'] }
        : { orderBy?: SymbolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymbolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Symbol model
   */
  readonly fields: SymbolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Symbol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymbolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Symbol model
   */
  interface SymbolFieldRefs {
    readonly id: FieldRef<"Symbol", 'String'>
    readonly name: FieldRef<"Symbol", 'String'>
    readonly slug: FieldRef<"Symbol", 'String'>
    readonly category: FieldRef<"Symbol", 'String'>
    readonly description: FieldRef<"Symbol", 'String'>
    readonly interpretations: FieldRef<"Symbol", 'Json'>
    readonly translations: FieldRef<"Symbol", 'Json'>
    readonly version: FieldRef<"Symbol", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Symbol findUnique
   */
  export type SymbolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol findUniqueOrThrow
   */
  export type SymbolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol findFirst
   */
  export type SymbolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol findFirstOrThrow
   */
  export type SymbolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter, which Symbol to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symbols.
     */
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol findMany
   */
  export type SymbolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter, which Symbols to fetch.
     */
    where?: SymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symbols to fetch.
     */
    orderBy?: SymbolOrderByWithRelationInput | SymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Symbols.
     */
    cursor?: SymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symbols.
     */
    skip?: number
    distinct?: SymbolScalarFieldEnum | SymbolScalarFieldEnum[]
  }

  /**
   * Symbol create
   */
  export type SymbolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * The data needed to create a Symbol.
     */
    data: XOR<SymbolCreateInput, SymbolUncheckedCreateInput>
  }

  /**
   * Symbol createMany
   */
  export type SymbolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Symbols.
     */
    data: SymbolCreateManyInput | SymbolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Symbol createManyAndReturn
   */
  export type SymbolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * The data used to create many Symbols.
     */
    data: SymbolCreateManyInput | SymbolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Symbol update
   */
  export type SymbolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * The data needed to update a Symbol.
     */
    data: XOR<SymbolUpdateInput, SymbolUncheckedUpdateInput>
    /**
     * Choose, which Symbol to update.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol updateMany
   */
  export type SymbolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Symbols.
     */
    data: XOR<SymbolUpdateManyMutationInput, SymbolUncheckedUpdateManyInput>
    /**
     * Filter which Symbols to update
     */
    where?: SymbolWhereInput
    /**
     * Limit how many Symbols to update.
     */
    limit?: number
  }

  /**
   * Symbol updateManyAndReturn
   */
  export type SymbolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * The data used to update Symbols.
     */
    data: XOR<SymbolUpdateManyMutationInput, SymbolUncheckedUpdateManyInput>
    /**
     * Filter which Symbols to update
     */
    where?: SymbolWhereInput
    /**
     * Limit how many Symbols to update.
     */
    limit?: number
  }

  /**
   * Symbol upsert
   */
  export type SymbolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * The filter to search for the Symbol to update in case it exists.
     */
    where: SymbolWhereUniqueInput
    /**
     * In case the Symbol found by the `where` argument doesn't exist, create a new Symbol with this data.
     */
    create: XOR<SymbolCreateInput, SymbolUncheckedCreateInput>
    /**
     * In case the Symbol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymbolUpdateInput, SymbolUncheckedUpdateInput>
  }

  /**
   * Symbol delete
   */
  export type SymbolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
    /**
     * Filter which Symbol to delete.
     */
    where: SymbolWhereUniqueInput
  }

  /**
   * Symbol deleteMany
   */
  export type SymbolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symbols to delete
     */
    where?: SymbolWhereInput
    /**
     * Limit how many Symbols to delete.
     */
    limit?: number
  }

  /**
   * Symbol without action
   */
  export type SymbolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symbol
     */
    select?: SymbolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Symbol
     */
    omit?: SymbolOmit<ExtArgs> | null
  }


  /**
   * Model Theme
   */

  export type AggregateTheme = {
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  export type ThemeAvgAggregateOutputType = {
    version: number | null
  }

  export type ThemeSumAggregateOutputType = {
    version: number | null
  }

  export type ThemeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    version: number | null
  }

  export type ThemeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    version: number | null
  }

  export type ThemeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    relatedSlugs: number
    translations: number
    version: number
    _all: number
  }


  export type ThemeAvgAggregateInputType = {
    version?: true
  }

  export type ThemeSumAggregateInputType = {
    version?: true
  }

  export type ThemeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    version?: true
  }

  export type ThemeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    version?: true
  }

  export type ThemeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    relatedSlugs?: true
    translations?: true
    version?: true
    _all?: true
  }

  export type ThemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theme to aggregate.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themes
    **/
    _count?: true | ThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThemeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThemeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMaxAggregateInputType
  }

  export type GetThemeAggregateType<T extends ThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheme[P]>
      : GetScalarType<T[P], AggregateTheme[P]>
  }




  export type ThemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithAggregationInput | ThemeOrderByWithAggregationInput[]
    by: ThemeScalarFieldEnum[] | ThemeScalarFieldEnum
    having?: ThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeCountAggregateInputType | true
    _avg?: ThemeAvgAggregateInputType
    _sum?: ThemeSumAggregateInputType
    _min?: ThemeMinAggregateInputType
    _max?: ThemeMaxAggregateInputType
  }

  export type ThemeGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    relatedSlugs: string[]
    translations: JsonValue | null
    version: number
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  type GetThemeGroupByPayload<T extends ThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    relatedSlugs?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    relatedSlugs?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    relatedSlugs?: boolean
    translations?: boolean
    version?: boolean
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    relatedSlugs?: boolean
    translations?: boolean
    version?: boolean
  }

  export type ThemeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "relatedSlugs" | "translations" | "version", ExtArgs["result"]["theme"]>

  export type $ThemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Theme"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      relatedSlugs: string[]
      translations: Prisma.JsonValue | null
      version: number
    }, ExtArgs["result"]["theme"]>
    composites: {}
  }

  type ThemeGetPayload<S extends boolean | null | undefined | ThemeDefaultArgs> = $Result.GetResult<Prisma.$ThemePayload, S>

  type ThemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeCountAggregateInputType | true
    }

  export interface ThemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theme'], meta: { name: 'Theme' } }
    /**
     * Find zero or one Theme that matches the filter.
     * @param {ThemeFindUniqueArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeFindUniqueArgs>(args: SelectSubset<T, ThemeFindUniqueArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Theme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeFindUniqueOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeFindFirstArgs>(args?: SelectSubset<T, ThemeFindFirstArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Themes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themes
     * const themes = await prisma.theme.findMany()
     * 
     * // Get first 10 Themes
     * const themes = await prisma.theme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeWithIdOnly = await prisma.theme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThemeFindManyArgs>(args?: SelectSubset<T, ThemeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Theme.
     * @param {ThemeCreateArgs} args - Arguments to create a Theme.
     * @example
     * // Create one Theme
     * const Theme = await prisma.theme.create({
     *   data: {
     *     // ... data to create a Theme
     *   }
     * })
     * 
     */
    create<T extends ThemeCreateArgs>(args: SelectSubset<T, ThemeCreateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Themes.
     * @param {ThemeCreateManyArgs} args - Arguments to create many Themes.
     * @example
     * // Create many Themes
     * const theme = await prisma.theme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeCreateManyArgs>(args?: SelectSubset<T, ThemeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Themes and returns the data saved in the database.
     * @param {ThemeCreateManyAndReturnArgs} args - Arguments to create many Themes.
     * @example
     * // Create many Themes
     * const theme = await prisma.theme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Themes and only return the `id`
     * const themeWithIdOnly = await prisma.theme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemeCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Theme.
     * @param {ThemeDeleteArgs} args - Arguments to delete one Theme.
     * @example
     * // Delete one Theme
     * const Theme = await prisma.theme.delete({
     *   where: {
     *     // ... filter to delete one Theme
     *   }
     * })
     * 
     */
    delete<T extends ThemeDeleteArgs>(args: SelectSubset<T, ThemeDeleteArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Theme.
     * @param {ThemeUpdateArgs} args - Arguments to update one Theme.
     * @example
     * // Update one Theme
     * const theme = await prisma.theme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeUpdateArgs>(args: SelectSubset<T, ThemeUpdateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Themes.
     * @param {ThemeDeleteManyArgs} args - Arguments to filter Themes to delete.
     * @example
     * // Delete a few Themes
     * const { count } = await prisma.theme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeDeleteManyArgs>(args?: SelectSubset<T, ThemeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeUpdateManyArgs>(args: SelectSubset<T, ThemeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes and returns the data updated in the database.
     * @param {ThemeUpdateManyAndReturnArgs} args - Arguments to update many Themes.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Themes and only return the `id`
     * const themeWithIdOnly = await prisma.theme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemeUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Theme.
     * @param {ThemeUpsertArgs} args - Arguments to update or create a Theme.
     * @example
     * // Update or create a Theme
     * const theme = await prisma.theme.upsert({
     *   create: {
     *     // ... data to create a Theme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theme we want to update
     *   }
     * })
     */
    upsert<T extends ThemeUpsertArgs>(args: SelectSubset<T, ThemeUpsertArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeCountArgs} args - Arguments to filter Themes to count.
     * @example
     * // Count the number of Themes
     * const count = await prisma.theme.count({
     *   where: {
     *     // ... the filter for the Themes we want to count
     *   }
     * })
    **/
    count<T extends ThemeCountArgs>(
      args?: Subset<T, ThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeAggregateArgs>(args: Subset<T, ThemeAggregateArgs>): Prisma.PrismaPromise<GetThemeAggregateType<T>>

    /**
     * Group by Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theme model
   */
  readonly fields: ThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Theme model
   */
  interface ThemeFieldRefs {
    readonly id: FieldRef<"Theme", 'String'>
    readonly name: FieldRef<"Theme", 'String'>
    readonly slug: FieldRef<"Theme", 'String'>
    readonly description: FieldRef<"Theme", 'String'>
    readonly relatedSlugs: FieldRef<"Theme", 'String[]'>
    readonly translations: FieldRef<"Theme", 'Json'>
    readonly version: FieldRef<"Theme", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Theme findUnique
   */
  export type ThemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findUniqueOrThrow
   */
  export type ThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findFirst
   */
  export type ThemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findFirstOrThrow
   */
  export type ThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findMany
   */
  export type ThemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter, which Themes to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme create
   */
  export type ThemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data needed to create a Theme.
     */
    data: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
  }

  /**
   * Theme createMany
   */
  export type ThemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Theme createManyAndReturn
   */
  export type ThemeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Theme update
   */
  export type ThemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data needed to update a Theme.
     */
    data: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
    /**
     * Choose, which Theme to update.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme updateMany
   */
  export type ThemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to update.
     */
    limit?: number
  }

  /**
   * Theme updateManyAndReturn
   */
  export type ThemeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to update.
     */
    limit?: number
  }

  /**
   * Theme upsert
   */
  export type ThemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The filter to search for the Theme to update in case it exists.
     */
    where: ThemeWhereUniqueInput
    /**
     * In case the Theme found by the `where` argument doesn't exist, create a new Theme with this data.
     */
    create: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
    /**
     * In case the Theme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
  }

  /**
   * Theme delete
   */
  export type ThemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Filter which Theme to delete.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme deleteMany
   */
  export type ThemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themes to delete
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to delete.
     */
    limit?: number
  }

  /**
   * Theme without action
   */
  export type ThemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
  }


  /**
   * Model NightCheckIn
   */

  export type AggregateNightCheckIn = {
    _count: NightCheckInCountAggregateOutputType | null
    _min: NightCheckInMinAggregateOutputType | null
    _max: NightCheckInMaxAggregateOutputType | null
  }

  export type NightCheckInMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    mood: string | null
    dayNotes: string | null
    intention: string | null
    plannedWakeTime: string | null
    reminderEnabled: boolean | null
    createdAt: Date | null
  }

  export type NightCheckInMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: string | null
    mood: string | null
    dayNotes: string | null
    intention: string | null
    plannedWakeTime: string | null
    reminderEnabled: boolean | null
    createdAt: Date | null
  }

  export type NightCheckInCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    mood: number
    dayNotes: number
    intention: number
    plannedWakeTime: number
    reminderEnabled: number
    createdAt: number
    _all: number
  }


  export type NightCheckInMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    dayNotes?: true
    intention?: true
    plannedWakeTime?: true
    reminderEnabled?: true
    createdAt?: true
  }

  export type NightCheckInMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    dayNotes?: true
    intention?: true
    plannedWakeTime?: true
    reminderEnabled?: true
    createdAt?: true
  }

  export type NightCheckInCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    dayNotes?: true
    intention?: true
    plannedWakeTime?: true
    reminderEnabled?: true
    createdAt?: true
    _all?: true
  }

  export type NightCheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NightCheckIn to aggregate.
     */
    where?: NightCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NightCheckIns to fetch.
     */
    orderBy?: NightCheckInOrderByWithRelationInput | NightCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NightCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NightCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NightCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NightCheckIns
    **/
    _count?: true | NightCheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NightCheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NightCheckInMaxAggregateInputType
  }

  export type GetNightCheckInAggregateType<T extends NightCheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateNightCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNightCheckIn[P]>
      : GetScalarType<T[P], AggregateNightCheckIn[P]>
  }




  export type NightCheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NightCheckInWhereInput
    orderBy?: NightCheckInOrderByWithAggregationInput | NightCheckInOrderByWithAggregationInput[]
    by: NightCheckInScalarFieldEnum[] | NightCheckInScalarFieldEnum
    having?: NightCheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NightCheckInCountAggregateInputType | true
    _min?: NightCheckInMinAggregateInputType
    _max?: NightCheckInMaxAggregateInputType
  }

  export type NightCheckInGroupByOutputType = {
    id: string
    userId: string
    date: string
    mood: string | null
    dayNotes: string | null
    intention: string | null
    plannedWakeTime: string | null
    reminderEnabled: boolean
    createdAt: Date
    _count: NightCheckInCountAggregateOutputType | null
    _min: NightCheckInMinAggregateOutputType | null
    _max: NightCheckInMaxAggregateOutputType | null
  }

  type GetNightCheckInGroupByPayload<T extends NightCheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NightCheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NightCheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NightCheckInGroupByOutputType[P]>
            : GetScalarType<T[P], NightCheckInGroupByOutputType[P]>
        }
      >
    >


  export type NightCheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    dayNotes?: boolean
    intention?: boolean
    plannedWakeTime?: boolean
    reminderEnabled?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nightCheckIn"]>

  export type NightCheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    dayNotes?: boolean
    intention?: boolean
    plannedWakeTime?: boolean
    reminderEnabled?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nightCheckIn"]>

  export type NightCheckInSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    dayNotes?: boolean
    intention?: boolean
    plannedWakeTime?: boolean
    reminderEnabled?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nightCheckIn"]>

  export type NightCheckInSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    dayNotes?: boolean
    intention?: boolean
    plannedWakeTime?: boolean
    reminderEnabled?: boolean
    createdAt?: boolean
  }

  export type NightCheckInOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "mood" | "dayNotes" | "intention" | "plannedWakeTime" | "reminderEnabled" | "createdAt", ExtArgs["result"]["nightCheckIn"]>
  export type NightCheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NightCheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NightCheckInIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NightCheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NightCheckIn"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: string
      mood: string | null
      dayNotes: string | null
      intention: string | null
      plannedWakeTime: string | null
      reminderEnabled: boolean
      createdAt: Date
    }, ExtArgs["result"]["nightCheckIn"]>
    composites: {}
  }

  type NightCheckInGetPayload<S extends boolean | null | undefined | NightCheckInDefaultArgs> = $Result.GetResult<Prisma.$NightCheckInPayload, S>

  type NightCheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NightCheckInFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NightCheckInCountAggregateInputType | true
    }

  export interface NightCheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NightCheckIn'], meta: { name: 'NightCheckIn' } }
    /**
     * Find zero or one NightCheckIn that matches the filter.
     * @param {NightCheckInFindUniqueArgs} args - Arguments to find a NightCheckIn
     * @example
     * // Get one NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NightCheckInFindUniqueArgs>(args: SelectSubset<T, NightCheckInFindUniqueArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NightCheckIn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NightCheckInFindUniqueOrThrowArgs} args - Arguments to find a NightCheckIn
     * @example
     * // Get one NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NightCheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, NightCheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NightCheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInFindFirstArgs} args - Arguments to find a NightCheckIn
     * @example
     * // Get one NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NightCheckInFindFirstArgs>(args?: SelectSubset<T, NightCheckInFindFirstArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NightCheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInFindFirstOrThrowArgs} args - Arguments to find a NightCheckIn
     * @example
     * // Get one NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NightCheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, NightCheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NightCheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NightCheckIns
     * const nightCheckIns = await prisma.nightCheckIn.findMany()
     * 
     * // Get first 10 NightCheckIns
     * const nightCheckIns = await prisma.nightCheckIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nightCheckInWithIdOnly = await prisma.nightCheckIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NightCheckInFindManyArgs>(args?: SelectSubset<T, NightCheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NightCheckIn.
     * @param {NightCheckInCreateArgs} args - Arguments to create a NightCheckIn.
     * @example
     * // Create one NightCheckIn
     * const NightCheckIn = await prisma.nightCheckIn.create({
     *   data: {
     *     // ... data to create a NightCheckIn
     *   }
     * })
     * 
     */
    create<T extends NightCheckInCreateArgs>(args: SelectSubset<T, NightCheckInCreateArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NightCheckIns.
     * @param {NightCheckInCreateManyArgs} args - Arguments to create many NightCheckIns.
     * @example
     * // Create many NightCheckIns
     * const nightCheckIn = await prisma.nightCheckIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NightCheckInCreateManyArgs>(args?: SelectSubset<T, NightCheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NightCheckIns and returns the data saved in the database.
     * @param {NightCheckInCreateManyAndReturnArgs} args - Arguments to create many NightCheckIns.
     * @example
     * // Create many NightCheckIns
     * const nightCheckIn = await prisma.nightCheckIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NightCheckIns and only return the `id`
     * const nightCheckInWithIdOnly = await prisma.nightCheckIn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NightCheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, NightCheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NightCheckIn.
     * @param {NightCheckInDeleteArgs} args - Arguments to delete one NightCheckIn.
     * @example
     * // Delete one NightCheckIn
     * const NightCheckIn = await prisma.nightCheckIn.delete({
     *   where: {
     *     // ... filter to delete one NightCheckIn
     *   }
     * })
     * 
     */
    delete<T extends NightCheckInDeleteArgs>(args: SelectSubset<T, NightCheckInDeleteArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NightCheckIn.
     * @param {NightCheckInUpdateArgs} args - Arguments to update one NightCheckIn.
     * @example
     * // Update one NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NightCheckInUpdateArgs>(args: SelectSubset<T, NightCheckInUpdateArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NightCheckIns.
     * @param {NightCheckInDeleteManyArgs} args - Arguments to filter NightCheckIns to delete.
     * @example
     * // Delete a few NightCheckIns
     * const { count } = await prisma.nightCheckIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NightCheckInDeleteManyArgs>(args?: SelectSubset<T, NightCheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NightCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NightCheckIns
     * const nightCheckIn = await prisma.nightCheckIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NightCheckInUpdateManyArgs>(args: SelectSubset<T, NightCheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NightCheckIns and returns the data updated in the database.
     * @param {NightCheckInUpdateManyAndReturnArgs} args - Arguments to update many NightCheckIns.
     * @example
     * // Update many NightCheckIns
     * const nightCheckIn = await prisma.nightCheckIn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NightCheckIns and only return the `id`
     * const nightCheckInWithIdOnly = await prisma.nightCheckIn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NightCheckInUpdateManyAndReturnArgs>(args: SelectSubset<T, NightCheckInUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NightCheckIn.
     * @param {NightCheckInUpsertArgs} args - Arguments to update or create a NightCheckIn.
     * @example
     * // Update or create a NightCheckIn
     * const nightCheckIn = await prisma.nightCheckIn.upsert({
     *   create: {
     *     // ... data to create a NightCheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NightCheckIn we want to update
     *   }
     * })
     */
    upsert<T extends NightCheckInUpsertArgs>(args: SelectSubset<T, NightCheckInUpsertArgs<ExtArgs>>): Prisma__NightCheckInClient<$Result.GetResult<Prisma.$NightCheckInPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NightCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInCountArgs} args - Arguments to filter NightCheckIns to count.
     * @example
     * // Count the number of NightCheckIns
     * const count = await prisma.nightCheckIn.count({
     *   where: {
     *     // ... the filter for the NightCheckIns we want to count
     *   }
     * })
    **/
    count<T extends NightCheckInCountArgs>(
      args?: Subset<T, NightCheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NightCheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NightCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NightCheckInAggregateArgs>(args: Subset<T, NightCheckInAggregateArgs>): Prisma.PrismaPromise<GetNightCheckInAggregateType<T>>

    /**
     * Group by NightCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightCheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NightCheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NightCheckInGroupByArgs['orderBy'] }
        : { orderBy?: NightCheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NightCheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNightCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NightCheckIn model
   */
  readonly fields: NightCheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NightCheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NightCheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NightCheckIn model
   */
  interface NightCheckInFieldRefs {
    readonly id: FieldRef<"NightCheckIn", 'String'>
    readonly userId: FieldRef<"NightCheckIn", 'String'>
    readonly date: FieldRef<"NightCheckIn", 'String'>
    readonly mood: FieldRef<"NightCheckIn", 'String'>
    readonly dayNotes: FieldRef<"NightCheckIn", 'String'>
    readonly intention: FieldRef<"NightCheckIn", 'String'>
    readonly plannedWakeTime: FieldRef<"NightCheckIn", 'String'>
    readonly reminderEnabled: FieldRef<"NightCheckIn", 'Boolean'>
    readonly createdAt: FieldRef<"NightCheckIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NightCheckIn findUnique
   */
  export type NightCheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NightCheckIn to fetch.
     */
    where: NightCheckInWhereUniqueInput
  }

  /**
   * NightCheckIn findUniqueOrThrow
   */
  export type NightCheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NightCheckIn to fetch.
     */
    where: NightCheckInWhereUniqueInput
  }

  /**
   * NightCheckIn findFirst
   */
  export type NightCheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NightCheckIn to fetch.
     */
    where?: NightCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NightCheckIns to fetch.
     */
    orderBy?: NightCheckInOrderByWithRelationInput | NightCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NightCheckIns.
     */
    cursor?: NightCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NightCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NightCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NightCheckIns.
     */
    distinct?: NightCheckInScalarFieldEnum | NightCheckInScalarFieldEnum[]
  }

  /**
   * NightCheckIn findFirstOrThrow
   */
  export type NightCheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NightCheckIn to fetch.
     */
    where?: NightCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NightCheckIns to fetch.
     */
    orderBy?: NightCheckInOrderByWithRelationInput | NightCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NightCheckIns.
     */
    cursor?: NightCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NightCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NightCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NightCheckIns.
     */
    distinct?: NightCheckInScalarFieldEnum | NightCheckInScalarFieldEnum[]
  }

  /**
   * NightCheckIn findMany
   */
  export type NightCheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter, which NightCheckIns to fetch.
     */
    where?: NightCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NightCheckIns to fetch.
     */
    orderBy?: NightCheckInOrderByWithRelationInput | NightCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NightCheckIns.
     */
    cursor?: NightCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NightCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NightCheckIns.
     */
    skip?: number
    distinct?: NightCheckInScalarFieldEnum | NightCheckInScalarFieldEnum[]
  }

  /**
   * NightCheckIn create
   */
  export type NightCheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a NightCheckIn.
     */
    data: XOR<NightCheckInCreateInput, NightCheckInUncheckedCreateInput>
  }

  /**
   * NightCheckIn createMany
   */
  export type NightCheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NightCheckIns.
     */
    data: NightCheckInCreateManyInput | NightCheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NightCheckIn createManyAndReturn
   */
  export type NightCheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * The data used to create many NightCheckIns.
     */
    data: NightCheckInCreateManyInput | NightCheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NightCheckIn update
   */
  export type NightCheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a NightCheckIn.
     */
    data: XOR<NightCheckInUpdateInput, NightCheckInUncheckedUpdateInput>
    /**
     * Choose, which NightCheckIn to update.
     */
    where: NightCheckInWhereUniqueInput
  }

  /**
   * NightCheckIn updateMany
   */
  export type NightCheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NightCheckIns.
     */
    data: XOR<NightCheckInUpdateManyMutationInput, NightCheckInUncheckedUpdateManyInput>
    /**
     * Filter which NightCheckIns to update
     */
    where?: NightCheckInWhereInput
    /**
     * Limit how many NightCheckIns to update.
     */
    limit?: number
  }

  /**
   * NightCheckIn updateManyAndReturn
   */
  export type NightCheckInUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * The data used to update NightCheckIns.
     */
    data: XOR<NightCheckInUpdateManyMutationInput, NightCheckInUncheckedUpdateManyInput>
    /**
     * Filter which NightCheckIns to update
     */
    where?: NightCheckInWhereInput
    /**
     * Limit how many NightCheckIns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NightCheckIn upsert
   */
  export type NightCheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the NightCheckIn to update in case it exists.
     */
    where: NightCheckInWhereUniqueInput
    /**
     * In case the NightCheckIn found by the `where` argument doesn't exist, create a new NightCheckIn with this data.
     */
    create: XOR<NightCheckInCreateInput, NightCheckInUncheckedCreateInput>
    /**
     * In case the NightCheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NightCheckInUpdateInput, NightCheckInUncheckedUpdateInput>
  }

  /**
   * NightCheckIn delete
   */
  export type NightCheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
    /**
     * Filter which NightCheckIn to delete.
     */
    where: NightCheckInWhereUniqueInput
  }

  /**
   * NightCheckIn deleteMany
   */
  export type NightCheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NightCheckIns to delete
     */
    where?: NightCheckInWhereInput
    /**
     * Limit how many NightCheckIns to delete.
     */
    limit?: number
  }

  /**
   * NightCheckIn without action
   */
  export type NightCheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightCheckIn
     */
    select?: NightCheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NightCheckIn
     */
    omit?: NightCheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightCheckInInclude<ExtArgs> | null
  }


  /**
   * Model SyncQueueItem
   */

  export type AggregateSyncQueueItem = {
    _count: SyncQueueItemCountAggregateOutputType | null
    _avg: SyncQueueItemAvgAggregateOutputType | null
    _sum: SyncQueueItemSumAggregateOutputType | null
    _min: SyncQueueItemMinAggregateOutputType | null
    _max: SyncQueueItemMaxAggregateOutputType | null
  }

  export type SyncQueueItemAvgAggregateOutputType = {
    attempts: number | null
  }

  export type SyncQueueItemSumAggregateOutputType = {
    attempts: number | null
  }

  export type SyncQueueItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    operation: string | null
    resource: string | null
    status: string | null
    attempts: number | null
    lastError: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type SyncQueueItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    operation: string | null
    resource: string | null
    status: string | null
    attempts: number | null
    lastError: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type SyncQueueItemCountAggregateOutputType = {
    id: number
    userId: number
    operation: number
    resource: number
    payload: number
    status: number
    attempts: number
    lastError: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type SyncQueueItemAvgAggregateInputType = {
    attempts?: true
  }

  export type SyncQueueItemSumAggregateInputType = {
    attempts?: true
  }

  export type SyncQueueItemMinAggregateInputType = {
    id?: true
    userId?: true
    operation?: true
    resource?: true
    status?: true
    attempts?: true
    lastError?: true
    createdAt?: true
    processedAt?: true
  }

  export type SyncQueueItemMaxAggregateInputType = {
    id?: true
    userId?: true
    operation?: true
    resource?: true
    status?: true
    attempts?: true
    lastError?: true
    createdAt?: true
    processedAt?: true
  }

  export type SyncQueueItemCountAggregateInputType = {
    id?: true
    userId?: true
    operation?: true
    resource?: true
    payload?: true
    status?: true
    attempts?: true
    lastError?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type SyncQueueItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueueItem to aggregate.
     */
    where?: SyncQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueueItems to fetch.
     */
    orderBy?: SyncQueueItemOrderByWithRelationInput | SyncQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncQueueItems
    **/
    _count?: true | SyncQueueItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncQueueItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncQueueItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncQueueItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncQueueItemMaxAggregateInputType
  }

  export type GetSyncQueueItemAggregateType<T extends SyncQueueItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncQueueItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncQueueItem[P]>
      : GetScalarType<T[P], AggregateSyncQueueItem[P]>
  }




  export type SyncQueueItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncQueueItemWhereInput
    orderBy?: SyncQueueItemOrderByWithAggregationInput | SyncQueueItemOrderByWithAggregationInput[]
    by: SyncQueueItemScalarFieldEnum[] | SyncQueueItemScalarFieldEnum
    having?: SyncQueueItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncQueueItemCountAggregateInputType | true
    _avg?: SyncQueueItemAvgAggregateInputType
    _sum?: SyncQueueItemSumAggregateInputType
    _min?: SyncQueueItemMinAggregateInputType
    _max?: SyncQueueItemMaxAggregateInputType
  }

  export type SyncQueueItemGroupByOutputType = {
    id: string
    userId: string
    operation: string
    resource: string
    payload: JsonValue
    status: string
    attempts: number
    lastError: string | null
    createdAt: Date
    processedAt: Date | null
    _count: SyncQueueItemCountAggregateOutputType | null
    _avg: SyncQueueItemAvgAggregateOutputType | null
    _sum: SyncQueueItemSumAggregateOutputType | null
    _min: SyncQueueItemMinAggregateOutputType | null
    _max: SyncQueueItemMaxAggregateOutputType | null
  }

  type GetSyncQueueItemGroupByPayload<T extends SyncQueueItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncQueueItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncQueueItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncQueueItemGroupByOutputType[P]>
            : GetScalarType<T[P], SyncQueueItemGroupByOutputType[P]>
        }
      >
    >


  export type SyncQueueItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operation?: boolean
    resource?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["syncQueueItem"]>

  export type SyncQueueItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operation?: boolean
    resource?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["syncQueueItem"]>

  export type SyncQueueItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operation?: boolean
    resource?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["syncQueueItem"]>

  export type SyncQueueItemSelectScalar = {
    id?: boolean
    userId?: boolean
    operation?: boolean
    resource?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type SyncQueueItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "operation" | "resource" | "payload" | "status" | "attempts" | "lastError" | "createdAt" | "processedAt", ExtArgs["result"]["syncQueueItem"]>

  export type $SyncQueueItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncQueueItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      operation: string
      resource: string
      payload: Prisma.JsonValue
      status: string
      attempts: number
      lastError: string | null
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["syncQueueItem"]>
    composites: {}
  }

  type SyncQueueItemGetPayload<S extends boolean | null | undefined | SyncQueueItemDefaultArgs> = $Result.GetResult<Prisma.$SyncQueueItemPayload, S>

  type SyncQueueItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncQueueItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncQueueItemCountAggregateInputType | true
    }

  export interface SyncQueueItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncQueueItem'], meta: { name: 'SyncQueueItem' } }
    /**
     * Find zero or one SyncQueueItem that matches the filter.
     * @param {SyncQueueItemFindUniqueArgs} args - Arguments to find a SyncQueueItem
     * @example
     * // Get one SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncQueueItemFindUniqueArgs>(args: SelectSubset<T, SyncQueueItemFindUniqueArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncQueueItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncQueueItemFindUniqueOrThrowArgs} args - Arguments to find a SyncQueueItem
     * @example
     * // Get one SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncQueueItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncQueueItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncQueueItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemFindFirstArgs} args - Arguments to find a SyncQueueItem
     * @example
     * // Get one SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncQueueItemFindFirstArgs>(args?: SelectSubset<T, SyncQueueItemFindFirstArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncQueueItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemFindFirstOrThrowArgs} args - Arguments to find a SyncQueueItem
     * @example
     * // Get one SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncQueueItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncQueueItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncQueueItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncQueueItems
     * const syncQueueItems = await prisma.syncQueueItem.findMany()
     * 
     * // Get first 10 SyncQueueItems
     * const syncQueueItems = await prisma.syncQueueItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncQueueItemWithIdOnly = await prisma.syncQueueItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncQueueItemFindManyArgs>(args?: SelectSubset<T, SyncQueueItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncQueueItem.
     * @param {SyncQueueItemCreateArgs} args - Arguments to create a SyncQueueItem.
     * @example
     * // Create one SyncQueueItem
     * const SyncQueueItem = await prisma.syncQueueItem.create({
     *   data: {
     *     // ... data to create a SyncQueueItem
     *   }
     * })
     * 
     */
    create<T extends SyncQueueItemCreateArgs>(args: SelectSubset<T, SyncQueueItemCreateArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncQueueItems.
     * @param {SyncQueueItemCreateManyArgs} args - Arguments to create many SyncQueueItems.
     * @example
     * // Create many SyncQueueItems
     * const syncQueueItem = await prisma.syncQueueItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncQueueItemCreateManyArgs>(args?: SelectSubset<T, SyncQueueItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncQueueItems and returns the data saved in the database.
     * @param {SyncQueueItemCreateManyAndReturnArgs} args - Arguments to create many SyncQueueItems.
     * @example
     * // Create many SyncQueueItems
     * const syncQueueItem = await prisma.syncQueueItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncQueueItems and only return the `id`
     * const syncQueueItemWithIdOnly = await prisma.syncQueueItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncQueueItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncQueueItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncQueueItem.
     * @param {SyncQueueItemDeleteArgs} args - Arguments to delete one SyncQueueItem.
     * @example
     * // Delete one SyncQueueItem
     * const SyncQueueItem = await prisma.syncQueueItem.delete({
     *   where: {
     *     // ... filter to delete one SyncQueueItem
     *   }
     * })
     * 
     */
    delete<T extends SyncQueueItemDeleteArgs>(args: SelectSubset<T, SyncQueueItemDeleteArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncQueueItem.
     * @param {SyncQueueItemUpdateArgs} args - Arguments to update one SyncQueueItem.
     * @example
     * // Update one SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncQueueItemUpdateArgs>(args: SelectSubset<T, SyncQueueItemUpdateArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncQueueItems.
     * @param {SyncQueueItemDeleteManyArgs} args - Arguments to filter SyncQueueItems to delete.
     * @example
     * // Delete a few SyncQueueItems
     * const { count } = await prisma.syncQueueItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncQueueItemDeleteManyArgs>(args?: SelectSubset<T, SyncQueueItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncQueueItems
     * const syncQueueItem = await prisma.syncQueueItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncQueueItemUpdateManyArgs>(args: SelectSubset<T, SyncQueueItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncQueueItems and returns the data updated in the database.
     * @param {SyncQueueItemUpdateManyAndReturnArgs} args - Arguments to update many SyncQueueItems.
     * @example
     * // Update many SyncQueueItems
     * const syncQueueItem = await prisma.syncQueueItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncQueueItems and only return the `id`
     * const syncQueueItemWithIdOnly = await prisma.syncQueueItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncQueueItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncQueueItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncQueueItem.
     * @param {SyncQueueItemUpsertArgs} args - Arguments to update or create a SyncQueueItem.
     * @example
     * // Update or create a SyncQueueItem
     * const syncQueueItem = await prisma.syncQueueItem.upsert({
     *   create: {
     *     // ... data to create a SyncQueueItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncQueueItem we want to update
     *   }
     * })
     */
    upsert<T extends SyncQueueItemUpsertArgs>(args: SelectSubset<T, SyncQueueItemUpsertArgs<ExtArgs>>): Prisma__SyncQueueItemClient<$Result.GetResult<Prisma.$SyncQueueItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemCountArgs} args - Arguments to filter SyncQueueItems to count.
     * @example
     * // Count the number of SyncQueueItems
     * const count = await prisma.syncQueueItem.count({
     *   where: {
     *     // ... the filter for the SyncQueueItems we want to count
     *   }
     * })
    **/
    count<T extends SyncQueueItemCountArgs>(
      args?: Subset<T, SyncQueueItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncQueueItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncQueueItemAggregateArgs>(args: Subset<T, SyncQueueItemAggregateArgs>): Prisma.PrismaPromise<GetSyncQueueItemAggregateType<T>>

    /**
     * Group by SyncQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncQueueItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncQueueItemGroupByArgs['orderBy'] }
        : { orderBy?: SyncQueueItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncQueueItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncQueueItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncQueueItem model
   */
  readonly fields: SyncQueueItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncQueueItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncQueueItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncQueueItem model
   */
  interface SyncQueueItemFieldRefs {
    readonly id: FieldRef<"SyncQueueItem", 'String'>
    readonly userId: FieldRef<"SyncQueueItem", 'String'>
    readonly operation: FieldRef<"SyncQueueItem", 'String'>
    readonly resource: FieldRef<"SyncQueueItem", 'String'>
    readonly payload: FieldRef<"SyncQueueItem", 'Json'>
    readonly status: FieldRef<"SyncQueueItem", 'String'>
    readonly attempts: FieldRef<"SyncQueueItem", 'Int'>
    readonly lastError: FieldRef<"SyncQueueItem", 'String'>
    readonly createdAt: FieldRef<"SyncQueueItem", 'DateTime'>
    readonly processedAt: FieldRef<"SyncQueueItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncQueueItem findUnique
   */
  export type SyncQueueItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueueItem to fetch.
     */
    where: SyncQueueItemWhereUniqueInput
  }

  /**
   * SyncQueueItem findUniqueOrThrow
   */
  export type SyncQueueItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueueItem to fetch.
     */
    where: SyncQueueItemWhereUniqueInput
  }

  /**
   * SyncQueueItem findFirst
   */
  export type SyncQueueItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueueItem to fetch.
     */
    where?: SyncQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueueItems to fetch.
     */
    orderBy?: SyncQueueItemOrderByWithRelationInput | SyncQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueueItems.
     */
    cursor?: SyncQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueueItems.
     */
    distinct?: SyncQueueItemScalarFieldEnum | SyncQueueItemScalarFieldEnum[]
  }

  /**
   * SyncQueueItem findFirstOrThrow
   */
  export type SyncQueueItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueueItem to fetch.
     */
    where?: SyncQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueueItems to fetch.
     */
    orderBy?: SyncQueueItemOrderByWithRelationInput | SyncQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueueItems.
     */
    cursor?: SyncQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueueItems.
     */
    distinct?: SyncQueueItemScalarFieldEnum | SyncQueueItemScalarFieldEnum[]
  }

  /**
   * SyncQueueItem findMany
   */
  export type SyncQueueItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueueItems to fetch.
     */
    where?: SyncQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueueItems to fetch.
     */
    orderBy?: SyncQueueItemOrderByWithRelationInput | SyncQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncQueueItems.
     */
    cursor?: SyncQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueueItems.
     */
    skip?: number
    distinct?: SyncQueueItemScalarFieldEnum | SyncQueueItemScalarFieldEnum[]
  }

  /**
   * SyncQueueItem create
   */
  export type SyncQueueItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncQueueItem.
     */
    data: XOR<SyncQueueItemCreateInput, SyncQueueItemUncheckedCreateInput>
  }

  /**
   * SyncQueueItem createMany
   */
  export type SyncQueueItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncQueueItems.
     */
    data: SyncQueueItemCreateManyInput | SyncQueueItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncQueueItem createManyAndReturn
   */
  export type SyncQueueItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * The data used to create many SyncQueueItems.
     */
    data: SyncQueueItemCreateManyInput | SyncQueueItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncQueueItem update
   */
  export type SyncQueueItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncQueueItem.
     */
    data: XOR<SyncQueueItemUpdateInput, SyncQueueItemUncheckedUpdateInput>
    /**
     * Choose, which SyncQueueItem to update.
     */
    where: SyncQueueItemWhereUniqueInput
  }

  /**
   * SyncQueueItem updateMany
   */
  export type SyncQueueItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncQueueItems.
     */
    data: XOR<SyncQueueItemUpdateManyMutationInput, SyncQueueItemUncheckedUpdateManyInput>
    /**
     * Filter which SyncQueueItems to update
     */
    where?: SyncQueueItemWhereInput
    /**
     * Limit how many SyncQueueItems to update.
     */
    limit?: number
  }

  /**
   * SyncQueueItem updateManyAndReturn
   */
  export type SyncQueueItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * The data used to update SyncQueueItems.
     */
    data: XOR<SyncQueueItemUpdateManyMutationInput, SyncQueueItemUncheckedUpdateManyInput>
    /**
     * Filter which SyncQueueItems to update
     */
    where?: SyncQueueItemWhereInput
    /**
     * Limit how many SyncQueueItems to update.
     */
    limit?: number
  }

  /**
   * SyncQueueItem upsert
   */
  export type SyncQueueItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncQueueItem to update in case it exists.
     */
    where: SyncQueueItemWhereUniqueInput
    /**
     * In case the SyncQueueItem found by the `where` argument doesn't exist, create a new SyncQueueItem with this data.
     */
    create: XOR<SyncQueueItemCreateInput, SyncQueueItemUncheckedCreateInput>
    /**
     * In case the SyncQueueItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncQueueItemUpdateInput, SyncQueueItemUncheckedUpdateInput>
  }

  /**
   * SyncQueueItem delete
   */
  export type SyncQueueItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
    /**
     * Filter which SyncQueueItem to delete.
     */
    where: SyncQueueItemWhereUniqueInput
  }

  /**
   * SyncQueueItem deleteMany
   */
  export type SyncQueueItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueueItems to delete
     */
    where?: SyncQueueItemWhereInput
    /**
     * Limit how many SyncQueueItems to delete.
     */
    limit?: number
  }

  /**
   * SyncQueueItem without action
   */
  export type SyncQueueItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueueItem
     */
    select?: SyncQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueueItem
     */
    omit?: SyncQueueItemOmit<ExtArgs> | null
  }


  /**
   * Model AlarmSettings
   */

  export type AggregateAlarmSettings = {
    _count: AlarmSettingsCountAggregateOutputType | null
    _avg: AlarmSettingsAvgAggregateOutputType | null
    _sum: AlarmSettingsSumAggregateOutputType | null
    _min: AlarmSettingsMinAggregateOutputType | null
    _max: AlarmSettingsMaxAggregateOutputType | null
  }

  export type AlarmSettingsAvgAggregateOutputType = {
    volume: number | null
    snoozeMinutes: number | null
    maxSnoozes: number | null
  }

  export type AlarmSettingsSumAggregateOutputType = {
    volume: number | null
    snoozeMinutes: number | null
    maxSnoozes: number | null
  }

  export type AlarmSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isArmed: boolean | null
    soundId: string | null
    volume: number | null
    snoozeMinutes: number | null
    maxSnoozes: number | null
    lastSetTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlarmSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isArmed: boolean | null
    soundId: string | null
    volume: number | null
    snoozeMinutes: number | null
    maxSnoozes: number | null
    lastSetTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlarmSettingsCountAggregateOutputType = {
    id: number
    userId: number
    isArmed: number
    schedule: number
    soundId: number
    volume: number
    snoozeMinutes: number
    maxSnoozes: number
    lastSetTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlarmSettingsAvgAggregateInputType = {
    volume?: true
    snoozeMinutes?: true
    maxSnoozes?: true
  }

  export type AlarmSettingsSumAggregateInputType = {
    volume?: true
    snoozeMinutes?: true
    maxSnoozes?: true
  }

  export type AlarmSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    isArmed?: true
    soundId?: true
    volume?: true
    snoozeMinutes?: true
    maxSnoozes?: true
    lastSetTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlarmSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    isArmed?: true
    soundId?: true
    volume?: true
    snoozeMinutes?: true
    maxSnoozes?: true
    lastSetTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlarmSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    isArmed?: true
    schedule?: true
    soundId?: true
    volume?: true
    snoozeMinutes?: true
    maxSnoozes?: true
    lastSetTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlarmSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmSettings to aggregate.
     */
    where?: AlarmSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmSettings to fetch.
     */
    orderBy?: AlarmSettingsOrderByWithRelationInput | AlarmSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlarmSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlarmSettings
    **/
    _count?: true | AlarmSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlarmSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlarmSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlarmSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlarmSettingsMaxAggregateInputType
  }

  export type GetAlarmSettingsAggregateType<T extends AlarmSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateAlarmSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlarmSettings[P]>
      : GetScalarType<T[P], AggregateAlarmSettings[P]>
  }




  export type AlarmSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmSettingsWhereInput
    orderBy?: AlarmSettingsOrderByWithAggregationInput | AlarmSettingsOrderByWithAggregationInput[]
    by: AlarmSettingsScalarFieldEnum[] | AlarmSettingsScalarFieldEnum
    having?: AlarmSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlarmSettingsCountAggregateInputType | true
    _avg?: AlarmSettingsAvgAggregateInputType
    _sum?: AlarmSettingsSumAggregateInputType
    _min?: AlarmSettingsMinAggregateInputType
    _max?: AlarmSettingsMaxAggregateInputType
  }

  export type AlarmSettingsGroupByOutputType = {
    id: string
    userId: string
    isArmed: boolean
    schedule: JsonValue
    soundId: string
    volume: number
    snoozeMinutes: number
    maxSnoozes: number
    lastSetTime: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlarmSettingsCountAggregateOutputType | null
    _avg: AlarmSettingsAvgAggregateOutputType | null
    _sum: AlarmSettingsSumAggregateOutputType | null
    _min: AlarmSettingsMinAggregateOutputType | null
    _max: AlarmSettingsMaxAggregateOutputType | null
  }

  type GetAlarmSettingsGroupByPayload<T extends AlarmSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlarmSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlarmSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlarmSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AlarmSettingsGroupByOutputType[P]>
        }
      >
    >


  export type AlarmSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isArmed?: boolean
    schedule?: boolean
    soundId?: boolean
    volume?: boolean
    snoozeMinutes?: boolean
    maxSnoozes?: boolean
    lastSetTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarmSettings"]>

  export type AlarmSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isArmed?: boolean
    schedule?: boolean
    soundId?: boolean
    volume?: boolean
    snoozeMinutes?: boolean
    maxSnoozes?: boolean
    lastSetTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarmSettings"]>

  export type AlarmSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isArmed?: boolean
    schedule?: boolean
    soundId?: boolean
    volume?: boolean
    snoozeMinutes?: boolean
    maxSnoozes?: boolean
    lastSetTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarmSettings"]>

  export type AlarmSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    isArmed?: boolean
    schedule?: boolean
    soundId?: boolean
    volume?: boolean
    snoozeMinutes?: boolean
    maxSnoozes?: boolean
    lastSetTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlarmSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "isArmed" | "schedule" | "soundId" | "volume" | "snoozeMinutes" | "maxSnoozes" | "lastSetTime" | "createdAt" | "updatedAt", ExtArgs["result"]["alarmSettings"]>
  export type AlarmSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlarmSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlarmSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AlarmSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlarmSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      isArmed: boolean
      schedule: Prisma.JsonValue
      soundId: string
      volume: number
      snoozeMinutes: number
      maxSnoozes: number
      lastSetTime: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alarmSettings"]>
    composites: {}
  }

  type AlarmSettingsGetPayload<S extends boolean | null | undefined | AlarmSettingsDefaultArgs> = $Result.GetResult<Prisma.$AlarmSettingsPayload, S>

  type AlarmSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlarmSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlarmSettingsCountAggregateInputType | true
    }

  export interface AlarmSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlarmSettings'], meta: { name: 'AlarmSettings' } }
    /**
     * Find zero or one AlarmSettings that matches the filter.
     * @param {AlarmSettingsFindUniqueArgs} args - Arguments to find a AlarmSettings
     * @example
     * // Get one AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlarmSettingsFindUniqueArgs>(args: SelectSubset<T, AlarmSettingsFindUniqueArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlarmSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlarmSettingsFindUniqueOrThrowArgs} args - Arguments to find a AlarmSettings
     * @example
     * // Get one AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlarmSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, AlarmSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlarmSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsFindFirstArgs} args - Arguments to find a AlarmSettings
     * @example
     * // Get one AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlarmSettingsFindFirstArgs>(args?: SelectSubset<T, AlarmSettingsFindFirstArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlarmSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsFindFirstOrThrowArgs} args - Arguments to find a AlarmSettings
     * @example
     * // Get one AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlarmSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, AlarmSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlarmSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findMany()
     * 
     * // Get first 10 AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alarmSettingsWithIdOnly = await prisma.alarmSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlarmSettingsFindManyArgs>(args?: SelectSubset<T, AlarmSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlarmSettings.
     * @param {AlarmSettingsCreateArgs} args - Arguments to create a AlarmSettings.
     * @example
     * // Create one AlarmSettings
     * const AlarmSettings = await prisma.alarmSettings.create({
     *   data: {
     *     // ... data to create a AlarmSettings
     *   }
     * })
     * 
     */
    create<T extends AlarmSettingsCreateArgs>(args: SelectSubset<T, AlarmSettingsCreateArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlarmSettings.
     * @param {AlarmSettingsCreateManyArgs} args - Arguments to create many AlarmSettings.
     * @example
     * // Create many AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlarmSettingsCreateManyArgs>(args?: SelectSubset<T, AlarmSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlarmSettings and returns the data saved in the database.
     * @param {AlarmSettingsCreateManyAndReturnArgs} args - Arguments to create many AlarmSettings.
     * @example
     * // Create many AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlarmSettings and only return the `id`
     * const alarmSettingsWithIdOnly = await prisma.alarmSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlarmSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, AlarmSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlarmSettings.
     * @param {AlarmSettingsDeleteArgs} args - Arguments to delete one AlarmSettings.
     * @example
     * // Delete one AlarmSettings
     * const AlarmSettings = await prisma.alarmSettings.delete({
     *   where: {
     *     // ... filter to delete one AlarmSettings
     *   }
     * })
     * 
     */
    delete<T extends AlarmSettingsDeleteArgs>(args: SelectSubset<T, AlarmSettingsDeleteArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlarmSettings.
     * @param {AlarmSettingsUpdateArgs} args - Arguments to update one AlarmSettings.
     * @example
     * // Update one AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlarmSettingsUpdateArgs>(args: SelectSubset<T, AlarmSettingsUpdateArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlarmSettings.
     * @param {AlarmSettingsDeleteManyArgs} args - Arguments to filter AlarmSettings to delete.
     * @example
     * // Delete a few AlarmSettings
     * const { count } = await prisma.alarmSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlarmSettingsDeleteManyArgs>(args?: SelectSubset<T, AlarmSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlarmSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlarmSettingsUpdateManyArgs>(args: SelectSubset<T, AlarmSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlarmSettings and returns the data updated in the database.
     * @param {AlarmSettingsUpdateManyAndReturnArgs} args - Arguments to update many AlarmSettings.
     * @example
     * // Update many AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlarmSettings and only return the `id`
     * const alarmSettingsWithIdOnly = await prisma.alarmSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlarmSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, AlarmSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlarmSettings.
     * @param {AlarmSettingsUpsertArgs} args - Arguments to update or create a AlarmSettings.
     * @example
     * // Update or create a AlarmSettings
     * const alarmSettings = await prisma.alarmSettings.upsert({
     *   create: {
     *     // ... data to create a AlarmSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlarmSettings we want to update
     *   }
     * })
     */
    upsert<T extends AlarmSettingsUpsertArgs>(args: SelectSubset<T, AlarmSettingsUpsertArgs<ExtArgs>>): Prisma__AlarmSettingsClient<$Result.GetResult<Prisma.$AlarmSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlarmSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsCountArgs} args - Arguments to filter AlarmSettings to count.
     * @example
     * // Count the number of AlarmSettings
     * const count = await prisma.alarmSettings.count({
     *   where: {
     *     // ... the filter for the AlarmSettings we want to count
     *   }
     * })
    **/
    count<T extends AlarmSettingsCountArgs>(
      args?: Subset<T, AlarmSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlarmSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlarmSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlarmSettingsAggregateArgs>(args: Subset<T, AlarmSettingsAggregateArgs>): Prisma.PrismaPromise<GetAlarmSettingsAggregateType<T>>

    /**
     * Group by AlarmSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlarmSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlarmSettingsGroupByArgs['orderBy'] }
        : { orderBy?: AlarmSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlarmSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlarmSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlarmSettings model
   */
  readonly fields: AlarmSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlarmSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlarmSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlarmSettings model
   */
  interface AlarmSettingsFieldRefs {
    readonly id: FieldRef<"AlarmSettings", 'String'>
    readonly userId: FieldRef<"AlarmSettings", 'String'>
    readonly isArmed: FieldRef<"AlarmSettings", 'Boolean'>
    readonly schedule: FieldRef<"AlarmSettings", 'Json'>
    readonly soundId: FieldRef<"AlarmSettings", 'String'>
    readonly volume: FieldRef<"AlarmSettings", 'Int'>
    readonly snoozeMinutes: FieldRef<"AlarmSettings", 'Int'>
    readonly maxSnoozes: FieldRef<"AlarmSettings", 'Int'>
    readonly lastSetTime: FieldRef<"AlarmSettings", 'String'>
    readonly createdAt: FieldRef<"AlarmSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"AlarmSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlarmSettings findUnique
   */
  export type AlarmSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AlarmSettings to fetch.
     */
    where: AlarmSettingsWhereUniqueInput
  }

  /**
   * AlarmSettings findUniqueOrThrow
   */
  export type AlarmSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AlarmSettings to fetch.
     */
    where: AlarmSettingsWhereUniqueInput
  }

  /**
   * AlarmSettings findFirst
   */
  export type AlarmSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AlarmSettings to fetch.
     */
    where?: AlarmSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmSettings to fetch.
     */
    orderBy?: AlarmSettingsOrderByWithRelationInput | AlarmSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmSettings.
     */
    cursor?: AlarmSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmSettings.
     */
    distinct?: AlarmSettingsScalarFieldEnum | AlarmSettingsScalarFieldEnum[]
  }

  /**
   * AlarmSettings findFirstOrThrow
   */
  export type AlarmSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AlarmSettings to fetch.
     */
    where?: AlarmSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmSettings to fetch.
     */
    orderBy?: AlarmSettingsOrderByWithRelationInput | AlarmSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmSettings.
     */
    cursor?: AlarmSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmSettings.
     */
    distinct?: AlarmSettingsScalarFieldEnum | AlarmSettingsScalarFieldEnum[]
  }

  /**
   * AlarmSettings findMany
   */
  export type AlarmSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter, which AlarmSettings to fetch.
     */
    where?: AlarmSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmSettings to fetch.
     */
    orderBy?: AlarmSettingsOrderByWithRelationInput | AlarmSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlarmSettings.
     */
    cursor?: AlarmSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmSettings.
     */
    skip?: number
    distinct?: AlarmSettingsScalarFieldEnum | AlarmSettingsScalarFieldEnum[]
  }

  /**
   * AlarmSettings create
   */
  export type AlarmSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a AlarmSettings.
     */
    data: XOR<AlarmSettingsCreateInput, AlarmSettingsUncheckedCreateInput>
  }

  /**
   * AlarmSettings createMany
   */
  export type AlarmSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlarmSettings.
     */
    data: AlarmSettingsCreateManyInput | AlarmSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlarmSettings createManyAndReturn
   */
  export type AlarmSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many AlarmSettings.
     */
    data: AlarmSettingsCreateManyInput | AlarmSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlarmSettings update
   */
  export type AlarmSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a AlarmSettings.
     */
    data: XOR<AlarmSettingsUpdateInput, AlarmSettingsUncheckedUpdateInput>
    /**
     * Choose, which AlarmSettings to update.
     */
    where: AlarmSettingsWhereUniqueInput
  }

  /**
   * AlarmSettings updateMany
   */
  export type AlarmSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlarmSettings.
     */
    data: XOR<AlarmSettingsUpdateManyMutationInput, AlarmSettingsUncheckedUpdateManyInput>
    /**
     * Filter which AlarmSettings to update
     */
    where?: AlarmSettingsWhereInput
    /**
     * Limit how many AlarmSettings to update.
     */
    limit?: number
  }

  /**
   * AlarmSettings updateManyAndReturn
   */
  export type AlarmSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * The data used to update AlarmSettings.
     */
    data: XOR<AlarmSettingsUpdateManyMutationInput, AlarmSettingsUncheckedUpdateManyInput>
    /**
     * Filter which AlarmSettings to update
     */
    where?: AlarmSettingsWhereInput
    /**
     * Limit how many AlarmSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlarmSettings upsert
   */
  export type AlarmSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the AlarmSettings to update in case it exists.
     */
    where: AlarmSettingsWhereUniqueInput
    /**
     * In case the AlarmSettings found by the `where` argument doesn't exist, create a new AlarmSettings with this data.
     */
    create: XOR<AlarmSettingsCreateInput, AlarmSettingsUncheckedCreateInput>
    /**
     * In case the AlarmSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlarmSettingsUpdateInput, AlarmSettingsUncheckedUpdateInput>
  }

  /**
   * AlarmSettings delete
   */
  export type AlarmSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
    /**
     * Filter which AlarmSettings to delete.
     */
    where: AlarmSettingsWhereUniqueInput
  }

  /**
   * AlarmSettings deleteMany
   */
  export type AlarmSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmSettings to delete
     */
    where?: AlarmSettingsWhereInput
    /**
     * Limit how many AlarmSettings to delete.
     */
    limit?: number
  }

  /**
   * AlarmSettings without action
   */
  export type AlarmSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmSettings
     */
    select?: AlarmSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlarmSettings
     */
    omit?: AlarmSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmSettingsInclude<ExtArgs> | null
  }


  /**
   * Model DreamerProfile
   */

  export type AggregateDreamerProfile = {
    _count: DreamerProfileCountAggregateOutputType | null
    _avg: DreamerProfileAvgAggregateOutputType | null
    _sum: DreamerProfileSumAggregateOutputType | null
    _min: DreamerProfileMinAggregateOutputType | null
    _max: DreamerProfileMaxAggregateOutputType | null
  }

  export type DreamerProfileAvgAggregateOutputType = {
    boundaryScore: number | null
    lucidityScore: number | null
    emotionScore: number | null
    meaningScore: number | null
    engagementScore: number | null
    boundaryConfidence: number | null
    lucidityConfidence: number | null
    emotionConfidence: number | null
    meaningConfidence: number | null
    engagementConfidence: number | null
    archetypeConfidence: number | null
    unlockPoints: number | null
    unlockLevel: number | null
    journalDreamCount: number | null
    journalLucidPercent: number | null
    journalAvgVividness: number | null
    journalWakingLinkRate: number | null
    scoringVersion: number | null
  }

  export type DreamerProfileSumAggregateOutputType = {
    boundaryScore: number | null
    lucidityScore: number | null
    emotionScore: number | null
    meaningScore: number | null
    engagementScore: number | null
    boundaryConfidence: number | null
    lucidityConfidence: number | null
    emotionConfidence: number | null
    meaningConfidence: number | null
    engagementConfidence: number | null
    archetypeConfidence: number | null
    unlockPoints: number | null
    unlockLevel: number | null
    journalDreamCount: number | null
    journalLucidPercent: number | null
    journalAvgVividness: number | null
    journalWakingLinkRate: number | null
    scoringVersion: number | null
  }

  export type DreamerProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    boundaryScore: number | null
    lucidityScore: number | null
    emotionScore: number | null
    meaningScore: number | null
    engagementScore: number | null
    boundaryConfidence: number | null
    lucidityConfidence: number | null
    emotionConfidence: number | null
    meaningConfidence: number | null
    engagementConfidence: number | null
    primaryArchetype: string | null
    secondaryArchetype: string | null
    archetypeConfidence: number | null
    unlockPoints: number | null
    unlockLevel: number | null
    journalDreamCount: number | null
    journalLucidPercent: number | null
    journalAvgVividness: number | null
    journalWakingLinkRate: number | null
    scoringVersion: number | null
    isStale: boolean | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DreamerProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    boundaryScore: number | null
    lucidityScore: number | null
    emotionScore: number | null
    meaningScore: number | null
    engagementScore: number | null
    boundaryConfidence: number | null
    lucidityConfidence: number | null
    emotionConfidence: number | null
    meaningConfidence: number | null
    engagementConfidence: number | null
    primaryArchetype: string | null
    secondaryArchetype: string | null
    archetypeConfidence: number | null
    unlockPoints: number | null
    unlockLevel: number | null
    journalDreamCount: number | null
    journalLucidPercent: number | null
    journalAvgVividness: number | null
    journalWakingLinkRate: number | null
    scoringVersion: number | null
    isStale: boolean | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DreamerProfileCountAggregateOutputType = {
    id: number
    userId: number
    boundaryScore: number
    lucidityScore: number
    emotionScore: number
    meaningScore: number
    engagementScore: number
    boundaryConfidence: number
    lucidityConfidence: number
    emotionConfidence: number
    meaningConfidence: number
    engagementConfidence: number
    primaryArchetype: number
    secondaryArchetype: number
    archetypeConfidence: number
    unlockPoints: number
    unlockLevel: number
    journalDreamCount: number
    journalLucidPercent: number
    journalAvgVividness: number
    journalTopEmotions: number
    journalTopTags: number
    journalWakingLinkRate: number
    scoringVersion: number
    isStale: number
    lastCalculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DreamerProfileAvgAggregateInputType = {
    boundaryScore?: true
    lucidityScore?: true
    emotionScore?: true
    meaningScore?: true
    engagementScore?: true
    boundaryConfidence?: true
    lucidityConfidence?: true
    emotionConfidence?: true
    meaningConfidence?: true
    engagementConfidence?: true
    archetypeConfidence?: true
    unlockPoints?: true
    unlockLevel?: true
    journalDreamCount?: true
    journalLucidPercent?: true
    journalAvgVividness?: true
    journalWakingLinkRate?: true
    scoringVersion?: true
  }

  export type DreamerProfileSumAggregateInputType = {
    boundaryScore?: true
    lucidityScore?: true
    emotionScore?: true
    meaningScore?: true
    engagementScore?: true
    boundaryConfidence?: true
    lucidityConfidence?: true
    emotionConfidence?: true
    meaningConfidence?: true
    engagementConfidence?: true
    archetypeConfidence?: true
    unlockPoints?: true
    unlockLevel?: true
    journalDreamCount?: true
    journalLucidPercent?: true
    journalAvgVividness?: true
    journalWakingLinkRate?: true
    scoringVersion?: true
  }

  export type DreamerProfileMinAggregateInputType = {
    id?: true
    userId?: true
    boundaryScore?: true
    lucidityScore?: true
    emotionScore?: true
    meaningScore?: true
    engagementScore?: true
    boundaryConfidence?: true
    lucidityConfidence?: true
    emotionConfidence?: true
    meaningConfidence?: true
    engagementConfidence?: true
    primaryArchetype?: true
    secondaryArchetype?: true
    archetypeConfidence?: true
    unlockPoints?: true
    unlockLevel?: true
    journalDreamCount?: true
    journalLucidPercent?: true
    journalAvgVividness?: true
    journalWakingLinkRate?: true
    scoringVersion?: true
    isStale?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DreamerProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    boundaryScore?: true
    lucidityScore?: true
    emotionScore?: true
    meaningScore?: true
    engagementScore?: true
    boundaryConfidence?: true
    lucidityConfidence?: true
    emotionConfidence?: true
    meaningConfidence?: true
    engagementConfidence?: true
    primaryArchetype?: true
    secondaryArchetype?: true
    archetypeConfidence?: true
    unlockPoints?: true
    unlockLevel?: true
    journalDreamCount?: true
    journalLucidPercent?: true
    journalAvgVividness?: true
    journalWakingLinkRate?: true
    scoringVersion?: true
    isStale?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DreamerProfileCountAggregateInputType = {
    id?: true
    userId?: true
    boundaryScore?: true
    lucidityScore?: true
    emotionScore?: true
    meaningScore?: true
    engagementScore?: true
    boundaryConfidence?: true
    lucidityConfidence?: true
    emotionConfidence?: true
    meaningConfidence?: true
    engagementConfidence?: true
    primaryArchetype?: true
    secondaryArchetype?: true
    archetypeConfidence?: true
    unlockPoints?: true
    unlockLevel?: true
    journalDreamCount?: true
    journalLucidPercent?: true
    journalAvgVividness?: true
    journalTopEmotions?: true
    journalTopTags?: true
    journalWakingLinkRate?: true
    scoringVersion?: true
    isStale?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DreamerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamerProfile to aggregate.
     */
    where?: DreamerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamerProfiles to fetch.
     */
    orderBy?: DreamerProfileOrderByWithRelationInput | DreamerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DreamerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DreamerProfiles
    **/
    _count?: true | DreamerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DreamerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DreamerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DreamerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DreamerProfileMaxAggregateInputType
  }

  export type GetDreamerProfileAggregateType<T extends DreamerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateDreamerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDreamerProfile[P]>
      : GetScalarType<T[P], AggregateDreamerProfile[P]>
  }




  export type DreamerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DreamerProfileWhereInput
    orderBy?: DreamerProfileOrderByWithAggregationInput | DreamerProfileOrderByWithAggregationInput[]
    by: DreamerProfileScalarFieldEnum[] | DreamerProfileScalarFieldEnum
    having?: DreamerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DreamerProfileCountAggregateInputType | true
    _avg?: DreamerProfileAvgAggregateInputType
    _sum?: DreamerProfileSumAggregateInputType
    _min?: DreamerProfileMinAggregateInputType
    _max?: DreamerProfileMaxAggregateInputType
  }

  export type DreamerProfileGroupByOutputType = {
    id: string
    userId: string
    boundaryScore: number | null
    lucidityScore: number | null
    emotionScore: number | null
    meaningScore: number | null
    engagementScore: number | null
    boundaryConfidence: number | null
    lucidityConfidence: number | null
    emotionConfidence: number | null
    meaningConfidence: number | null
    engagementConfidence: number | null
    primaryArchetype: string | null
    secondaryArchetype: string | null
    archetypeConfidence: number | null
    unlockPoints: number
    unlockLevel: number
    journalDreamCount: number
    journalLucidPercent: number | null
    journalAvgVividness: number | null
    journalTopEmotions: string[]
    journalTopTags: string[]
    journalWakingLinkRate: number | null
    scoringVersion: number
    isStale: boolean
    lastCalculatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DreamerProfileCountAggregateOutputType | null
    _avg: DreamerProfileAvgAggregateOutputType | null
    _sum: DreamerProfileSumAggregateOutputType | null
    _min: DreamerProfileMinAggregateOutputType | null
    _max: DreamerProfileMaxAggregateOutputType | null
  }

  type GetDreamerProfileGroupByPayload<T extends DreamerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DreamerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DreamerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DreamerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], DreamerProfileGroupByOutputType[P]>
        }
      >
    >


  export type DreamerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    boundaryScore?: boolean
    lucidityScore?: boolean
    emotionScore?: boolean
    meaningScore?: boolean
    engagementScore?: boolean
    boundaryConfidence?: boolean
    lucidityConfidence?: boolean
    emotionConfidence?: boolean
    meaningConfidence?: boolean
    engagementConfidence?: boolean
    primaryArchetype?: boolean
    secondaryArchetype?: boolean
    archetypeConfidence?: boolean
    unlockPoints?: boolean
    unlockLevel?: boolean
    journalDreamCount?: boolean
    journalLucidPercent?: boolean
    journalAvgVividness?: boolean
    journalTopEmotions?: boolean
    journalTopTags?: boolean
    journalWakingLinkRate?: boolean
    scoringVersion?: boolean
    isStale?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamerProfile"]>

  export type DreamerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    boundaryScore?: boolean
    lucidityScore?: boolean
    emotionScore?: boolean
    meaningScore?: boolean
    engagementScore?: boolean
    boundaryConfidence?: boolean
    lucidityConfidence?: boolean
    emotionConfidence?: boolean
    meaningConfidence?: boolean
    engagementConfidence?: boolean
    primaryArchetype?: boolean
    secondaryArchetype?: boolean
    archetypeConfidence?: boolean
    unlockPoints?: boolean
    unlockLevel?: boolean
    journalDreamCount?: boolean
    journalLucidPercent?: boolean
    journalAvgVividness?: boolean
    journalTopEmotions?: boolean
    journalTopTags?: boolean
    journalWakingLinkRate?: boolean
    scoringVersion?: boolean
    isStale?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamerProfile"]>

  export type DreamerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    boundaryScore?: boolean
    lucidityScore?: boolean
    emotionScore?: boolean
    meaningScore?: boolean
    engagementScore?: boolean
    boundaryConfidence?: boolean
    lucidityConfidence?: boolean
    emotionConfidence?: boolean
    meaningConfidence?: boolean
    engagementConfidence?: boolean
    primaryArchetype?: boolean
    secondaryArchetype?: boolean
    archetypeConfidence?: boolean
    unlockPoints?: boolean
    unlockLevel?: boolean
    journalDreamCount?: boolean
    journalLucidPercent?: boolean
    journalAvgVividness?: boolean
    journalTopEmotions?: boolean
    journalTopTags?: boolean
    journalWakingLinkRate?: boolean
    scoringVersion?: boolean
    isStale?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dreamerProfile"]>

  export type DreamerProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    boundaryScore?: boolean
    lucidityScore?: boolean
    emotionScore?: boolean
    meaningScore?: boolean
    engagementScore?: boolean
    boundaryConfidence?: boolean
    lucidityConfidence?: boolean
    emotionConfidence?: boolean
    meaningConfidence?: boolean
    engagementConfidence?: boolean
    primaryArchetype?: boolean
    secondaryArchetype?: boolean
    archetypeConfidence?: boolean
    unlockPoints?: boolean
    unlockLevel?: boolean
    journalDreamCount?: boolean
    journalLucidPercent?: boolean
    journalAvgVividness?: boolean
    journalTopEmotions?: boolean
    journalTopTags?: boolean
    journalWakingLinkRate?: boolean
    scoringVersion?: boolean
    isStale?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DreamerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "boundaryScore" | "lucidityScore" | "emotionScore" | "meaningScore" | "engagementScore" | "boundaryConfidence" | "lucidityConfidence" | "emotionConfidence" | "meaningConfidence" | "engagementConfidence" | "primaryArchetype" | "secondaryArchetype" | "archetypeConfidence" | "unlockPoints" | "unlockLevel" | "journalDreamCount" | "journalLucidPercent" | "journalAvgVividness" | "journalTopEmotions" | "journalTopTags" | "journalWakingLinkRate" | "scoringVersion" | "isStale" | "lastCalculatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["dreamerProfile"]>
  export type DreamerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DreamerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DreamerProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DreamerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DreamerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      boundaryScore: number | null
      lucidityScore: number | null
      emotionScore: number | null
      meaningScore: number | null
      engagementScore: number | null
      boundaryConfidence: number | null
      lucidityConfidence: number | null
      emotionConfidence: number | null
      meaningConfidence: number | null
      engagementConfidence: number | null
      primaryArchetype: string | null
      secondaryArchetype: string | null
      archetypeConfidence: number | null
      unlockPoints: number
      unlockLevel: number
      journalDreamCount: number
      journalLucidPercent: number | null
      journalAvgVividness: number | null
      journalTopEmotions: string[]
      journalTopTags: string[]
      journalWakingLinkRate: number | null
      scoringVersion: number
      isStale: boolean
      lastCalculatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dreamerProfile"]>
    composites: {}
  }

  type DreamerProfileGetPayload<S extends boolean | null | undefined | DreamerProfileDefaultArgs> = $Result.GetResult<Prisma.$DreamerProfilePayload, S>

  type DreamerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DreamerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DreamerProfileCountAggregateInputType | true
    }

  export interface DreamerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DreamerProfile'], meta: { name: 'DreamerProfile' } }
    /**
     * Find zero or one DreamerProfile that matches the filter.
     * @param {DreamerProfileFindUniqueArgs} args - Arguments to find a DreamerProfile
     * @example
     * // Get one DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DreamerProfileFindUniqueArgs>(args: SelectSubset<T, DreamerProfileFindUniqueArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DreamerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DreamerProfileFindUniqueOrThrowArgs} args - Arguments to find a DreamerProfile
     * @example
     * // Get one DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DreamerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, DreamerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileFindFirstArgs} args - Arguments to find a DreamerProfile
     * @example
     * // Get one DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DreamerProfileFindFirstArgs>(args?: SelectSubset<T, DreamerProfileFindFirstArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DreamerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileFindFirstOrThrowArgs} args - Arguments to find a DreamerProfile
     * @example
     * // Get one DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DreamerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, DreamerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DreamerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DreamerProfiles
     * const dreamerProfiles = await prisma.dreamerProfile.findMany()
     * 
     * // Get first 10 DreamerProfiles
     * const dreamerProfiles = await prisma.dreamerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dreamerProfileWithIdOnly = await prisma.dreamerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DreamerProfileFindManyArgs>(args?: SelectSubset<T, DreamerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DreamerProfile.
     * @param {DreamerProfileCreateArgs} args - Arguments to create a DreamerProfile.
     * @example
     * // Create one DreamerProfile
     * const DreamerProfile = await prisma.dreamerProfile.create({
     *   data: {
     *     // ... data to create a DreamerProfile
     *   }
     * })
     * 
     */
    create<T extends DreamerProfileCreateArgs>(args: SelectSubset<T, DreamerProfileCreateArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DreamerProfiles.
     * @param {DreamerProfileCreateManyArgs} args - Arguments to create many DreamerProfiles.
     * @example
     * // Create many DreamerProfiles
     * const dreamerProfile = await prisma.dreamerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DreamerProfileCreateManyArgs>(args?: SelectSubset<T, DreamerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DreamerProfiles and returns the data saved in the database.
     * @param {DreamerProfileCreateManyAndReturnArgs} args - Arguments to create many DreamerProfiles.
     * @example
     * // Create many DreamerProfiles
     * const dreamerProfile = await prisma.dreamerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DreamerProfiles and only return the `id`
     * const dreamerProfileWithIdOnly = await prisma.dreamerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DreamerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, DreamerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DreamerProfile.
     * @param {DreamerProfileDeleteArgs} args - Arguments to delete one DreamerProfile.
     * @example
     * // Delete one DreamerProfile
     * const DreamerProfile = await prisma.dreamerProfile.delete({
     *   where: {
     *     // ... filter to delete one DreamerProfile
     *   }
     * })
     * 
     */
    delete<T extends DreamerProfileDeleteArgs>(args: SelectSubset<T, DreamerProfileDeleteArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DreamerProfile.
     * @param {DreamerProfileUpdateArgs} args - Arguments to update one DreamerProfile.
     * @example
     * // Update one DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DreamerProfileUpdateArgs>(args: SelectSubset<T, DreamerProfileUpdateArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DreamerProfiles.
     * @param {DreamerProfileDeleteManyArgs} args - Arguments to filter DreamerProfiles to delete.
     * @example
     * // Delete a few DreamerProfiles
     * const { count } = await prisma.dreamerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DreamerProfileDeleteManyArgs>(args?: SelectSubset<T, DreamerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DreamerProfiles
     * const dreamerProfile = await prisma.dreamerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DreamerProfileUpdateManyArgs>(args: SelectSubset<T, DreamerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DreamerProfiles and returns the data updated in the database.
     * @param {DreamerProfileUpdateManyAndReturnArgs} args - Arguments to update many DreamerProfiles.
     * @example
     * // Update many DreamerProfiles
     * const dreamerProfile = await prisma.dreamerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DreamerProfiles and only return the `id`
     * const dreamerProfileWithIdOnly = await prisma.dreamerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DreamerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, DreamerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DreamerProfile.
     * @param {DreamerProfileUpsertArgs} args - Arguments to update or create a DreamerProfile.
     * @example
     * // Update or create a DreamerProfile
     * const dreamerProfile = await prisma.dreamerProfile.upsert({
     *   create: {
     *     // ... data to create a DreamerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DreamerProfile we want to update
     *   }
     * })
     */
    upsert<T extends DreamerProfileUpsertArgs>(args: SelectSubset<T, DreamerProfileUpsertArgs<ExtArgs>>): Prisma__DreamerProfileClient<$Result.GetResult<Prisma.$DreamerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DreamerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileCountArgs} args - Arguments to filter DreamerProfiles to count.
     * @example
     * // Count the number of DreamerProfiles
     * const count = await prisma.dreamerProfile.count({
     *   where: {
     *     // ... the filter for the DreamerProfiles we want to count
     *   }
     * })
    **/
    count<T extends DreamerProfileCountArgs>(
      args?: Subset<T, DreamerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DreamerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DreamerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DreamerProfileAggregateArgs>(args: Subset<T, DreamerProfileAggregateArgs>): Prisma.PrismaPromise<GetDreamerProfileAggregateType<T>>

    /**
     * Group by DreamerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DreamerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DreamerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DreamerProfileGroupByArgs['orderBy'] }
        : { orderBy?: DreamerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DreamerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDreamerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DreamerProfile model
   */
  readonly fields: DreamerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DreamerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DreamerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DreamerProfile model
   */
  interface DreamerProfileFieldRefs {
    readonly id: FieldRef<"DreamerProfile", 'String'>
    readonly userId: FieldRef<"DreamerProfile", 'String'>
    readonly boundaryScore: FieldRef<"DreamerProfile", 'Int'>
    readonly lucidityScore: FieldRef<"DreamerProfile", 'Int'>
    readonly emotionScore: FieldRef<"DreamerProfile", 'Int'>
    readonly meaningScore: FieldRef<"DreamerProfile", 'Int'>
    readonly engagementScore: FieldRef<"DreamerProfile", 'Int'>
    readonly boundaryConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly lucidityConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly emotionConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly meaningConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly engagementConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly primaryArchetype: FieldRef<"DreamerProfile", 'String'>
    readonly secondaryArchetype: FieldRef<"DreamerProfile", 'String'>
    readonly archetypeConfidence: FieldRef<"DreamerProfile", 'Int'>
    readonly unlockPoints: FieldRef<"DreamerProfile", 'Int'>
    readonly unlockLevel: FieldRef<"DreamerProfile", 'Int'>
    readonly journalDreamCount: FieldRef<"DreamerProfile", 'Int'>
    readonly journalLucidPercent: FieldRef<"DreamerProfile", 'Int'>
    readonly journalAvgVividness: FieldRef<"DreamerProfile", 'Int'>
    readonly journalTopEmotions: FieldRef<"DreamerProfile", 'String[]'>
    readonly journalTopTags: FieldRef<"DreamerProfile", 'String[]'>
    readonly journalWakingLinkRate: FieldRef<"DreamerProfile", 'Int'>
    readonly scoringVersion: FieldRef<"DreamerProfile", 'Int'>
    readonly isStale: FieldRef<"DreamerProfile", 'Boolean'>
    readonly lastCalculatedAt: FieldRef<"DreamerProfile", 'DateTime'>
    readonly createdAt: FieldRef<"DreamerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"DreamerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DreamerProfile findUnique
   */
  export type DreamerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DreamerProfile to fetch.
     */
    where: DreamerProfileWhereUniqueInput
  }

  /**
   * DreamerProfile findUniqueOrThrow
   */
  export type DreamerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DreamerProfile to fetch.
     */
    where: DreamerProfileWhereUniqueInput
  }

  /**
   * DreamerProfile findFirst
   */
  export type DreamerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DreamerProfile to fetch.
     */
    where?: DreamerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamerProfiles to fetch.
     */
    orderBy?: DreamerProfileOrderByWithRelationInput | DreamerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamerProfiles.
     */
    cursor?: DreamerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamerProfiles.
     */
    distinct?: DreamerProfileScalarFieldEnum | DreamerProfileScalarFieldEnum[]
  }

  /**
   * DreamerProfile findFirstOrThrow
   */
  export type DreamerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DreamerProfile to fetch.
     */
    where?: DreamerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamerProfiles to fetch.
     */
    orderBy?: DreamerProfileOrderByWithRelationInput | DreamerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DreamerProfiles.
     */
    cursor?: DreamerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DreamerProfiles.
     */
    distinct?: DreamerProfileScalarFieldEnum | DreamerProfileScalarFieldEnum[]
  }

  /**
   * DreamerProfile findMany
   */
  export type DreamerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter, which DreamerProfiles to fetch.
     */
    where?: DreamerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DreamerProfiles to fetch.
     */
    orderBy?: DreamerProfileOrderByWithRelationInput | DreamerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DreamerProfiles.
     */
    cursor?: DreamerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DreamerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DreamerProfiles.
     */
    skip?: number
    distinct?: DreamerProfileScalarFieldEnum | DreamerProfileScalarFieldEnum[]
  }

  /**
   * DreamerProfile create
   */
  export type DreamerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a DreamerProfile.
     */
    data: XOR<DreamerProfileCreateInput, DreamerProfileUncheckedCreateInput>
  }

  /**
   * DreamerProfile createMany
   */
  export type DreamerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DreamerProfiles.
     */
    data: DreamerProfileCreateManyInput | DreamerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DreamerProfile createManyAndReturn
   */
  export type DreamerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many DreamerProfiles.
     */
    data: DreamerProfileCreateManyInput | DreamerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamerProfile update
   */
  export type DreamerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a DreamerProfile.
     */
    data: XOR<DreamerProfileUpdateInput, DreamerProfileUncheckedUpdateInput>
    /**
     * Choose, which DreamerProfile to update.
     */
    where: DreamerProfileWhereUniqueInput
  }

  /**
   * DreamerProfile updateMany
   */
  export type DreamerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DreamerProfiles.
     */
    data: XOR<DreamerProfileUpdateManyMutationInput, DreamerProfileUncheckedUpdateManyInput>
    /**
     * Filter which DreamerProfiles to update
     */
    where?: DreamerProfileWhereInput
    /**
     * Limit how many DreamerProfiles to update.
     */
    limit?: number
  }

  /**
   * DreamerProfile updateManyAndReturn
   */
  export type DreamerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * The data used to update DreamerProfiles.
     */
    data: XOR<DreamerProfileUpdateManyMutationInput, DreamerProfileUncheckedUpdateManyInput>
    /**
     * Filter which DreamerProfiles to update
     */
    where?: DreamerProfileWhereInput
    /**
     * Limit how many DreamerProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DreamerProfile upsert
   */
  export type DreamerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the DreamerProfile to update in case it exists.
     */
    where: DreamerProfileWhereUniqueInput
    /**
     * In case the DreamerProfile found by the `where` argument doesn't exist, create a new DreamerProfile with this data.
     */
    create: XOR<DreamerProfileCreateInput, DreamerProfileUncheckedCreateInput>
    /**
     * In case the DreamerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DreamerProfileUpdateInput, DreamerProfileUncheckedUpdateInput>
  }

  /**
   * DreamerProfile delete
   */
  export type DreamerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
    /**
     * Filter which DreamerProfile to delete.
     */
    where: DreamerProfileWhereUniqueInput
  }

  /**
   * DreamerProfile deleteMany
   */
  export type DreamerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DreamerProfiles to delete
     */
    where?: DreamerProfileWhereInput
    /**
     * Limit how many DreamerProfiles to delete.
     */
    limit?: number
  }

  /**
   * DreamerProfile without action
   */
  export type DreamerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DreamerProfile
     */
    select?: DreamerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DreamerProfile
     */
    omit?: DreamerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DreamerProfileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    displayName: 'displayName',
    avatarEmoji: 'avatarEmoji',
    avatarBgColor: 'avatarBgColor',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    timezone: 'timezone',
    locale: 'locale',
    encryptionKeyVersion: 'encryptionKeyVersion',
    keyRecoveryMethod: 'keyRecoveryMethod',
    keySalt: 'keySalt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    deviceId: 'deviceId',
    deviceName: 'deviceName',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    payload: 'payload',
    timestamp: 'timestamp',
    sequence: 'sequence',
    aggregateId: 'aggregateId',
    aggregateType: 'aggregateType'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const DreamEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ciphertext: 'ciphertext',
    iv: 'iv',
    keyVersion: 'keyVersion',
    audioUrl: 'audioUrl',
    title: 'title',
    emotions: 'emotions',
    vividness: 'vividness',
    lucidity: 'lucidity',
    dreamTypes: 'dreamTypes',
    sleepQuality: 'sleepQuality',
    hoursSlept: 'hoursSlept',
    wakeTime: 'wakeTime',
    wakingLifeLink: 'wakingLifeLink',
    capturedAt: 'capturedAt',
    updatedAt: 'updatedAt'
  };

  export type DreamEntryScalarFieldEnum = (typeof DreamEntryScalarFieldEnum)[keyof typeof DreamEntryScalarFieldEnum]


  export const JournalFactScalarFieldEnum: {
    id: 'id',
    dreamEntryId: 'dreamEntryId',
    factType: 'factType',
    value: 'value',
    confidence: 'confidence',
    ontologyVersion: 'ontologyVersion',
    modelVersion: 'modelVersion',
    promptVersion: 'promptVersion',
    startIndex: 'startIndex',
    endIndex: 'endIndex',
    extractedAt: 'extractedAt'
  };

  export type JournalFactScalarFieldEnum = (typeof JournalFactScalarFieldEnum)[keyof typeof JournalFactScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    category: 'category',
    taxonomyId: 'taxonomyId',
    taxonomyVersion: 'taxonomyVersion',
    usageCount: 'usageCount'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const DreamTagScalarFieldEnum: {
    id: 'id',
    dreamEntryId: 'dreamEntryId',
    tagId: 'tagId',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type DreamTagScalarFieldEnum = (typeof DreamTagScalarFieldEnum)[keyof typeof DreamTagScalarFieldEnum]


  export const CensusInstrumentScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    version: 'version',
    isActive: 'isActive',
    isRequired: 'isRequired',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CensusInstrumentScalarFieldEnum = (typeof CensusInstrumentScalarFieldEnum)[keyof typeof CensusInstrumentScalarFieldEnum]


  export const CensusSectionScalarFieldEnum: {
    id: 'id',
    instrumentId: 'instrumentId',
    slug: 'slug',
    name: 'name',
    description: 'description',
    icon: 'icon',
    sortOrder: 'sortOrder',
    estimatedTime: 'estimatedTime'
  };

  export type CensusSectionScalarFieldEnum = (typeof CensusSectionScalarFieldEnum)[keyof typeof CensusSectionScalarFieldEnum]


  export const CensusQuestionScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    slug: 'slug',
    text: 'text',
    helpText: 'helpText',
    type: 'type',
    props: 'props',
    isRequired: 'isRequired',
    validation: 'validation',
    sortOrder: 'sortOrder',
    irtParams: 'irtParams',
    groupId: 'groupId',
    groupLabel: 'groupLabel',
    showWhen: 'showWhen'
  };

  export type CensusQuestionScalarFieldEnum = (typeof CensusQuestionScalarFieldEnum)[keyof typeof CensusQuestionScalarFieldEnum]


  export const CensusAnswerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionId: 'questionId',
    value: 'value',
    instrumentVersion: 'instrumentVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CensusAnswerScalarFieldEnum = (typeof CensusAnswerScalarFieldEnum)[keyof typeof CensusAnswerScalarFieldEnum]


  export const CensusProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sectionProgress: 'sectionProgress',
    totalCompleted: 'totalCompleted',
    totalQuestions: 'totalQuestions',
    scores: 'scores',
    lastActivityAt: 'lastActivityAt',
    completedAt: 'completedAt'
  };

  export type CensusProgressScalarFieldEnum = (typeof CensusProgressScalarFieldEnum)[keyof typeof CensusProgressScalarFieldEnum]


  export const PromptScalarFieldEnum: {
    id: 'id',
    text: 'text',
    type: 'type',
    responseType: 'responseType',
    responseProps: 'responseProps',
    isActive: 'isActive',
    frequency: 'frequency',
    targetingRules: 'targetingRules',
    studyId: 'studyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromptScalarFieldEnum = (typeof PromptScalarFieldEnum)[keyof typeof PromptScalarFieldEnum]


  export const PromptResponseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    promptId: 'promptId',
    value: 'value',
    shownAt: 'shownAt',
    respondedAt: 'respondedAt',
    skipped: 'skipped'
  };

  export type PromptResponseScalarFieldEnum = (typeof PromptResponseScalarFieldEnum)[keyof typeof PromptResponseScalarFieldEnum]


  export const ConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scope: 'scope',
    version: 'version',
    granted: 'granted',
    timestamp: 'timestamp',
    receiptHash: 'receiptHash',
    policyHash: 'policyHash',
    jurisdiction: 'jurisdiction',
    ipHash: 'ipHash'
  };

  export type ConsentScalarFieldEnum = (typeof ConsentScalarFieldEnum)[keyof typeof ConsentScalarFieldEnum]


  export const WeatherAggregateScalarFieldEnum: {
    id: 'id',
    metric: 'metric',
    period: 'period',
    periodStart: 'periodStart',
    value: 'value',
    sampleN: 'sampleN',
    dpEpsilon: 'dpEpsilon',
    dpDelta: 'dpDelta',
    minNThreshold: 'minNThreshold',
    region: 'region',
    methodVersion: 'methodVersion',
    computedAt: 'computedAt'
  };

  export type WeatherAggregateScalarFieldEnum = (typeof WeatherAggregateScalarFieldEnum)[keyof typeof WeatherAggregateScalarFieldEnum]


  export const PersonalWeatherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    weather: 'weather',
    streaks: 'streaks',
    lastComputedAt: 'lastComputedAt'
  };

  export type PersonalWeatherScalarFieldEnum = (typeof PersonalWeatherScalarFieldEnum)[keyof typeof PersonalWeatherScalarFieldEnum]


  export const StudyScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    institution: 'institution',
    dataScope: 'dataScope',
    duration: 'duration',
    consentText: 'consentText',
    consentVersion: 'consentVersion',
    status: 'status',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    maxParticipants: 'maxParticipants',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudyScalarFieldEnum = (typeof StudyScalarFieldEnum)[keyof typeof StudyScalarFieldEnum]


  export const StudyParticipationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studyId: 'studyId',
    consentedAt: 'consentedAt',
    consentVersion: 'consentVersion',
    status: 'status',
    withdrawnAt: 'withdrawnAt',
    withdrawalReason: 'withdrawalReason',
    completedAt: 'completedAt'
  };

  export type StudyParticipationScalarFieldEnum = (typeof StudyParticipationScalarFieldEnum)[keyof typeof StudyParticipationScalarFieldEnum]


  export const EmotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    valence: 'valence',
    arousal: 'arousal',
    parentId: 'parentId',
    translations: 'translations',
    version: 'version'
  };

  export type EmotionScalarFieldEnum = (typeof EmotionScalarFieldEnum)[keyof typeof EmotionScalarFieldEnum]


  export const SymbolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    category: 'category',
    description: 'description',
    interpretations: 'interpretations',
    translations: 'translations',
    version: 'version'
  };

  export type SymbolScalarFieldEnum = (typeof SymbolScalarFieldEnum)[keyof typeof SymbolScalarFieldEnum]


  export const ThemeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    relatedSlugs: 'relatedSlugs',
    translations: 'translations',
    version: 'version'
  };

  export type ThemeScalarFieldEnum = (typeof ThemeScalarFieldEnum)[keyof typeof ThemeScalarFieldEnum]


  export const NightCheckInScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    mood: 'mood',
    dayNotes: 'dayNotes',
    intention: 'intention',
    plannedWakeTime: 'plannedWakeTime',
    reminderEnabled: 'reminderEnabled',
    createdAt: 'createdAt'
  };

  export type NightCheckInScalarFieldEnum = (typeof NightCheckInScalarFieldEnum)[keyof typeof NightCheckInScalarFieldEnum]


  export const SyncQueueItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    operation: 'operation',
    resource: 'resource',
    payload: 'payload',
    status: 'status',
    attempts: 'attempts',
    lastError: 'lastError',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type SyncQueueItemScalarFieldEnum = (typeof SyncQueueItemScalarFieldEnum)[keyof typeof SyncQueueItemScalarFieldEnum]


  export const AlarmSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    isArmed: 'isArmed',
    schedule: 'schedule',
    soundId: 'soundId',
    volume: 'volume',
    snoozeMinutes: 'snoozeMinutes',
    maxSnoozes: 'maxSnoozes',
    lastSetTime: 'lastSetTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlarmSettingsScalarFieldEnum = (typeof AlarmSettingsScalarFieldEnum)[keyof typeof AlarmSettingsScalarFieldEnum]


  export const DreamerProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    boundaryScore: 'boundaryScore',
    lucidityScore: 'lucidityScore',
    emotionScore: 'emotionScore',
    meaningScore: 'meaningScore',
    engagementScore: 'engagementScore',
    boundaryConfidence: 'boundaryConfidence',
    lucidityConfidence: 'lucidityConfidence',
    emotionConfidence: 'emotionConfidence',
    meaningConfidence: 'meaningConfidence',
    engagementConfidence: 'engagementConfidence',
    primaryArchetype: 'primaryArchetype',
    secondaryArchetype: 'secondaryArchetype',
    archetypeConfidence: 'archetypeConfidence',
    unlockPoints: 'unlockPoints',
    unlockLevel: 'unlockLevel',
    journalDreamCount: 'journalDreamCount',
    journalLucidPercent: 'journalLucidPercent',
    journalAvgVividness: 'journalAvgVividness',
    journalTopEmotions: 'journalTopEmotions',
    journalTopTags: 'journalTopTags',
    journalWakingLinkRate: 'journalWakingLinkRate',
    scoringVersion: 'scoringVersion',
    isStale: 'isStale',
    lastCalculatedAt: 'lastCalculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DreamerProfileScalarFieldEnum = (typeof DreamerProfileScalarFieldEnum)[keyof typeof DreamerProfileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatarEmoji?: StringFilter<"User"> | string
    avatarBgColor?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    timezone?: StringFilter<"User"> | string
    locale?: StringFilter<"User"> | string
    encryptionKeyVersion?: IntFilter<"User"> | number
    keyRecoveryMethod?: StringNullableFilter<"User"> | string | null
    keySalt?: BytesNullableFilter<"User"> | Bytes | null
    alarmSettings?: XOR<AlarmSettingsNullableScalarRelationFilter, AlarmSettingsWhereInput> | null
    censusAnswers?: CensusAnswerListRelationFilter
    consents?: ConsentListRelationFilter
    dreamEntries?: DreamEntryListRelationFilter
    dreamerProfile?: XOR<DreamerProfileNullableScalarRelationFilter, DreamerProfileWhereInput> | null
    events?: EventListRelationFilter
    nightCheckIns?: NightCheckInListRelationFilter
    promptResponses?: PromptResponseListRelationFilter
    sessions?: SessionListRelationFilter
    studyParticipations?: StudyParticipationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarEmoji?: SortOrder
    avatarBgColor?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    encryptionKeyVersion?: SortOrder
    keyRecoveryMethod?: SortOrderInput | SortOrder
    keySalt?: SortOrderInput | SortOrder
    alarmSettings?: AlarmSettingsOrderByWithRelationInput
    censusAnswers?: CensusAnswerOrderByRelationAggregateInput
    consents?: ConsentOrderByRelationAggregateInput
    dreamEntries?: DreamEntryOrderByRelationAggregateInput
    dreamerProfile?: DreamerProfileOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
    nightCheckIns?: NightCheckInOrderByRelationAggregateInput
    promptResponses?: PromptResponseOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    studyParticipations?: StudyParticipationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatarEmoji?: StringFilter<"User"> | string
    avatarBgColor?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    timezone?: StringFilter<"User"> | string
    locale?: StringFilter<"User"> | string
    encryptionKeyVersion?: IntFilter<"User"> | number
    keyRecoveryMethod?: StringNullableFilter<"User"> | string | null
    keySalt?: BytesNullableFilter<"User"> | Bytes | null
    alarmSettings?: XOR<AlarmSettingsNullableScalarRelationFilter, AlarmSettingsWhereInput> | null
    censusAnswers?: CensusAnswerListRelationFilter
    consents?: ConsentListRelationFilter
    dreamEntries?: DreamEntryListRelationFilter
    dreamerProfile?: XOR<DreamerProfileNullableScalarRelationFilter, DreamerProfileWhereInput> | null
    events?: EventListRelationFilter
    nightCheckIns?: NightCheckInListRelationFilter
    promptResponses?: PromptResponseListRelationFilter
    sessions?: SessionListRelationFilter
    studyParticipations?: StudyParticipationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarEmoji?: SortOrder
    avatarBgColor?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    encryptionKeyVersion?: SortOrder
    keyRecoveryMethod?: SortOrderInput | SortOrder
    keySalt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarEmoji?: StringWithAggregatesFilter<"User"> | string
    avatarBgColor?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    locale?: StringWithAggregatesFilter<"User"> | string
    encryptionKeyVersion?: IntWithAggregatesFilter<"User"> | number
    keyRecoveryMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    keySalt?: BytesNullableWithAggregatesFilter<"User"> | Bytes | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    tokenHash?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    deviceId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"Session"> | string | null
    lastActiveAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    timestamp?: DateTimeFilter<"Event"> | Date | string
    sequence?: BigIntFilter<"Event"> | bigint | number
    aggregateId?: StringNullableFilter<"Event"> | string | null
    aggregateType?: StringNullableFilter<"Event"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    timestamp?: SortOrder
    sequence?: SortOrder
    aggregateId?: SortOrderInput | SortOrder
    aggregateType?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    userId?: StringFilter<"Event"> | string
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    timestamp?: DateTimeFilter<"Event"> | Date | string
    sequence?: BigIntFilter<"Event"> | bigint | number
    aggregateId?: StringNullableFilter<"Event"> | string | null
    aggregateType?: StringNullableFilter<"Event"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    timestamp?: SortOrder
    sequence?: SortOrder
    aggregateId?: SortOrderInput | SortOrder
    aggregateType?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    userId?: StringWithAggregatesFilter<"Event"> | string
    type?: StringWithAggregatesFilter<"Event"> | string
    payload?: JsonWithAggregatesFilter<"Event">
    timestamp?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    sequence?: BigIntWithAggregatesFilter<"Event"> | bigint | number
    aggregateId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    aggregateType?: StringNullableWithAggregatesFilter<"Event"> | string | null
  }

  export type DreamEntryWhereInput = {
    AND?: DreamEntryWhereInput | DreamEntryWhereInput[]
    OR?: DreamEntryWhereInput[]
    NOT?: DreamEntryWhereInput | DreamEntryWhereInput[]
    id?: StringFilter<"DreamEntry"> | string
    userId?: StringFilter<"DreamEntry"> | string
    ciphertext?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    iv?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    keyVersion?: IntFilter<"DreamEntry"> | number
    audioUrl?: StringNullableFilter<"DreamEntry"> | string | null
    title?: StringNullableFilter<"DreamEntry"> | string | null
    emotions?: StringNullableListFilter<"DreamEntry">
    vividness?: IntNullableFilter<"DreamEntry"> | number | null
    lucidity?: StringNullableFilter<"DreamEntry"> | string | null
    dreamTypes?: StringNullableListFilter<"DreamEntry">
    sleepQuality?: IntNullableFilter<"DreamEntry"> | number | null
    hoursSlept?: FloatNullableFilter<"DreamEntry"> | number | null
    wakeTime?: DateTimeNullableFilter<"DreamEntry"> | Date | string | null
    wakingLifeLink?: StringNullableFilter<"DreamEntry"> | string | null
    capturedAt?: DateTimeFilter<"DreamEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DreamEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: DreamTagListRelationFilter
    facts?: JournalFactListRelationFilter
  }

  export type DreamEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ciphertext?: SortOrderInput | SortOrder
    iv?: SortOrderInput | SortOrder
    keyVersion?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    emotions?: SortOrder
    vividness?: SortOrderInput | SortOrder
    lucidity?: SortOrderInput | SortOrder
    dreamTypes?: SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    hoursSlept?: SortOrderInput | SortOrder
    wakeTime?: SortOrderInput | SortOrder
    wakingLifeLink?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tags?: DreamTagOrderByRelationAggregateInput
    facts?: JournalFactOrderByRelationAggregateInput
  }

  export type DreamEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DreamEntryWhereInput | DreamEntryWhereInput[]
    OR?: DreamEntryWhereInput[]
    NOT?: DreamEntryWhereInput | DreamEntryWhereInput[]
    userId?: StringFilter<"DreamEntry"> | string
    ciphertext?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    iv?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    keyVersion?: IntFilter<"DreamEntry"> | number
    audioUrl?: StringNullableFilter<"DreamEntry"> | string | null
    title?: StringNullableFilter<"DreamEntry"> | string | null
    emotions?: StringNullableListFilter<"DreamEntry">
    vividness?: IntNullableFilter<"DreamEntry"> | number | null
    lucidity?: StringNullableFilter<"DreamEntry"> | string | null
    dreamTypes?: StringNullableListFilter<"DreamEntry">
    sleepQuality?: IntNullableFilter<"DreamEntry"> | number | null
    hoursSlept?: FloatNullableFilter<"DreamEntry"> | number | null
    wakeTime?: DateTimeNullableFilter<"DreamEntry"> | Date | string | null
    wakingLifeLink?: StringNullableFilter<"DreamEntry"> | string | null
    capturedAt?: DateTimeFilter<"DreamEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DreamEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: DreamTagListRelationFilter
    facts?: JournalFactListRelationFilter
  }, "id">

  export type DreamEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ciphertext?: SortOrderInput | SortOrder
    iv?: SortOrderInput | SortOrder
    keyVersion?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    emotions?: SortOrder
    vividness?: SortOrderInput | SortOrder
    lucidity?: SortOrderInput | SortOrder
    dreamTypes?: SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    hoursSlept?: SortOrderInput | SortOrder
    wakeTime?: SortOrderInput | SortOrder
    wakingLifeLink?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DreamEntryCountOrderByAggregateInput
    _avg?: DreamEntryAvgOrderByAggregateInput
    _max?: DreamEntryMaxOrderByAggregateInput
    _min?: DreamEntryMinOrderByAggregateInput
    _sum?: DreamEntrySumOrderByAggregateInput
  }

  export type DreamEntryScalarWhereWithAggregatesInput = {
    AND?: DreamEntryScalarWhereWithAggregatesInput | DreamEntryScalarWhereWithAggregatesInput[]
    OR?: DreamEntryScalarWhereWithAggregatesInput[]
    NOT?: DreamEntryScalarWhereWithAggregatesInput | DreamEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DreamEntry"> | string
    userId?: StringWithAggregatesFilter<"DreamEntry"> | string
    ciphertext?: BytesNullableWithAggregatesFilter<"DreamEntry"> | Bytes | null
    iv?: BytesNullableWithAggregatesFilter<"DreamEntry"> | Bytes | null
    keyVersion?: IntWithAggregatesFilter<"DreamEntry"> | number
    audioUrl?: StringNullableWithAggregatesFilter<"DreamEntry"> | string | null
    title?: StringNullableWithAggregatesFilter<"DreamEntry"> | string | null
    emotions?: StringNullableListFilter<"DreamEntry">
    vividness?: IntNullableWithAggregatesFilter<"DreamEntry"> | number | null
    lucidity?: StringNullableWithAggregatesFilter<"DreamEntry"> | string | null
    dreamTypes?: StringNullableListFilter<"DreamEntry">
    sleepQuality?: IntNullableWithAggregatesFilter<"DreamEntry"> | number | null
    hoursSlept?: FloatNullableWithAggregatesFilter<"DreamEntry"> | number | null
    wakeTime?: DateTimeNullableWithAggregatesFilter<"DreamEntry"> | Date | string | null
    wakingLifeLink?: StringNullableWithAggregatesFilter<"DreamEntry"> | string | null
    capturedAt?: DateTimeWithAggregatesFilter<"DreamEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DreamEntry"> | Date | string
  }

  export type JournalFactWhereInput = {
    AND?: JournalFactWhereInput | JournalFactWhereInput[]
    OR?: JournalFactWhereInput[]
    NOT?: JournalFactWhereInput | JournalFactWhereInput[]
    id?: StringFilter<"JournalFact"> | string
    dreamEntryId?: StringFilter<"JournalFact"> | string
    factType?: StringFilter<"JournalFact"> | string
    value?: JsonFilter<"JournalFact">
    confidence?: FloatFilter<"JournalFact"> | number
    ontologyVersion?: IntFilter<"JournalFact"> | number
    modelVersion?: StringFilter<"JournalFact"> | string
    promptVersion?: IntFilter<"JournalFact"> | number
    startIndex?: IntNullableFilter<"JournalFact"> | number | null
    endIndex?: IntNullableFilter<"JournalFact"> | number | null
    extractedAt?: DateTimeFilter<"JournalFact"> | Date | string
    dreamEntry?: XOR<DreamEntryScalarRelationFilter, DreamEntryWhereInput>
  }

  export type JournalFactOrderByWithRelationInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    factType?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    modelVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrderInput | SortOrder
    endIndex?: SortOrderInput | SortOrder
    extractedAt?: SortOrder
    dreamEntry?: DreamEntryOrderByWithRelationInput
  }

  export type JournalFactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalFactWhereInput | JournalFactWhereInput[]
    OR?: JournalFactWhereInput[]
    NOT?: JournalFactWhereInput | JournalFactWhereInput[]
    dreamEntryId?: StringFilter<"JournalFact"> | string
    factType?: StringFilter<"JournalFact"> | string
    value?: JsonFilter<"JournalFact">
    confidence?: FloatFilter<"JournalFact"> | number
    ontologyVersion?: IntFilter<"JournalFact"> | number
    modelVersion?: StringFilter<"JournalFact"> | string
    promptVersion?: IntFilter<"JournalFact"> | number
    startIndex?: IntNullableFilter<"JournalFact"> | number | null
    endIndex?: IntNullableFilter<"JournalFact"> | number | null
    extractedAt?: DateTimeFilter<"JournalFact"> | Date | string
    dreamEntry?: XOR<DreamEntryScalarRelationFilter, DreamEntryWhereInput>
  }, "id">

  export type JournalFactOrderByWithAggregationInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    factType?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    modelVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrderInput | SortOrder
    endIndex?: SortOrderInput | SortOrder
    extractedAt?: SortOrder
    _count?: JournalFactCountOrderByAggregateInput
    _avg?: JournalFactAvgOrderByAggregateInput
    _max?: JournalFactMaxOrderByAggregateInput
    _min?: JournalFactMinOrderByAggregateInput
    _sum?: JournalFactSumOrderByAggregateInput
  }

  export type JournalFactScalarWhereWithAggregatesInput = {
    AND?: JournalFactScalarWhereWithAggregatesInput | JournalFactScalarWhereWithAggregatesInput[]
    OR?: JournalFactScalarWhereWithAggregatesInput[]
    NOT?: JournalFactScalarWhereWithAggregatesInput | JournalFactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalFact"> | string
    dreamEntryId?: StringWithAggregatesFilter<"JournalFact"> | string
    factType?: StringWithAggregatesFilter<"JournalFact"> | string
    value?: JsonWithAggregatesFilter<"JournalFact">
    confidence?: FloatWithAggregatesFilter<"JournalFact"> | number
    ontologyVersion?: IntWithAggregatesFilter<"JournalFact"> | number
    modelVersion?: StringWithAggregatesFilter<"JournalFact"> | string
    promptVersion?: IntWithAggregatesFilter<"JournalFact"> | number
    startIndex?: IntNullableWithAggregatesFilter<"JournalFact"> | number | null
    endIndex?: IntNullableWithAggregatesFilter<"JournalFact"> | number | null
    extractedAt?: DateTimeWithAggregatesFilter<"JournalFact"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    category?: StringFilter<"Tag"> | string
    taxonomyId?: StringNullableFilter<"Tag"> | string | null
    taxonomyVersion?: IntNullableFilter<"Tag"> | number | null
    usageCount?: IntFilter<"Tag"> | number
    dreamTags?: DreamTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    taxonomyId?: SortOrderInput | SortOrder
    taxonomyVersion?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    dreamTags?: DreamTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    category?: StringFilter<"Tag"> | string
    taxonomyId?: StringNullableFilter<"Tag"> | string | null
    taxonomyVersion?: IntNullableFilter<"Tag"> | number | null
    usageCount?: IntFilter<"Tag"> | number
    dreamTags?: DreamTagListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    taxonomyId?: SortOrderInput | SortOrder
    taxonomyVersion?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    category?: StringWithAggregatesFilter<"Tag"> | string
    taxonomyId?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    taxonomyVersion?: IntNullableWithAggregatesFilter<"Tag"> | number | null
    usageCount?: IntWithAggregatesFilter<"Tag"> | number
  }

  export type DreamTagWhereInput = {
    AND?: DreamTagWhereInput | DreamTagWhereInput[]
    OR?: DreamTagWhereInput[]
    NOT?: DreamTagWhereInput | DreamTagWhereInput[]
    id?: StringFilter<"DreamTag"> | string
    dreamEntryId?: StringFilter<"DreamTag"> | string
    tagId?: StringFilter<"DreamTag"> | string
    source?: StringFilter<"DreamTag"> | string
    createdAt?: DateTimeFilter<"DreamTag"> | Date | string
    dreamEntry?: XOR<DreamEntryScalarRelationFilter, DreamEntryWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type DreamTagOrderByWithRelationInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    tagId?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    dreamEntry?: DreamEntryOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type DreamTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dreamEntryId_tagId?: DreamTagDreamEntryIdTagIdCompoundUniqueInput
    AND?: DreamTagWhereInput | DreamTagWhereInput[]
    OR?: DreamTagWhereInput[]
    NOT?: DreamTagWhereInput | DreamTagWhereInput[]
    dreamEntryId?: StringFilter<"DreamTag"> | string
    tagId?: StringFilter<"DreamTag"> | string
    source?: StringFilter<"DreamTag"> | string
    createdAt?: DateTimeFilter<"DreamTag"> | Date | string
    dreamEntry?: XOR<DreamEntryScalarRelationFilter, DreamEntryWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "dreamEntryId_tagId">

  export type DreamTagOrderByWithAggregationInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    tagId?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    _count?: DreamTagCountOrderByAggregateInput
    _max?: DreamTagMaxOrderByAggregateInput
    _min?: DreamTagMinOrderByAggregateInput
  }

  export type DreamTagScalarWhereWithAggregatesInput = {
    AND?: DreamTagScalarWhereWithAggregatesInput | DreamTagScalarWhereWithAggregatesInput[]
    OR?: DreamTagScalarWhereWithAggregatesInput[]
    NOT?: DreamTagScalarWhereWithAggregatesInput | DreamTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DreamTag"> | string
    dreamEntryId?: StringWithAggregatesFilter<"DreamTag"> | string
    tagId?: StringWithAggregatesFilter<"DreamTag"> | string
    source?: StringWithAggregatesFilter<"DreamTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DreamTag"> | Date | string
  }

  export type CensusInstrumentWhereInput = {
    AND?: CensusInstrumentWhereInput | CensusInstrumentWhereInput[]
    OR?: CensusInstrumentWhereInput[]
    NOT?: CensusInstrumentWhereInput | CensusInstrumentWhereInput[]
    id?: StringFilter<"CensusInstrument"> | string
    slug?: StringFilter<"CensusInstrument"> | string
    name?: StringFilter<"CensusInstrument"> | string
    description?: StringNullableFilter<"CensusInstrument"> | string | null
    version?: IntFilter<"CensusInstrument"> | number
    isActive?: BoolFilter<"CensusInstrument"> | boolean
    isRequired?: BoolFilter<"CensusInstrument"> | boolean
    sortOrder?: IntFilter<"CensusInstrument"> | number
    createdAt?: DateTimeFilter<"CensusInstrument"> | Date | string
    updatedAt?: DateTimeFilter<"CensusInstrument"> | Date | string
    sections?: CensusSectionListRelationFilter
  }

  export type CensusInstrumentOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sections?: CensusSectionOrderByRelationAggregateInput
  }

  export type CensusInstrumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CensusInstrumentWhereInput | CensusInstrumentWhereInput[]
    OR?: CensusInstrumentWhereInput[]
    NOT?: CensusInstrumentWhereInput | CensusInstrumentWhereInput[]
    name?: StringFilter<"CensusInstrument"> | string
    description?: StringNullableFilter<"CensusInstrument"> | string | null
    version?: IntFilter<"CensusInstrument"> | number
    isActive?: BoolFilter<"CensusInstrument"> | boolean
    isRequired?: BoolFilter<"CensusInstrument"> | boolean
    sortOrder?: IntFilter<"CensusInstrument"> | number
    createdAt?: DateTimeFilter<"CensusInstrument"> | Date | string
    updatedAt?: DateTimeFilter<"CensusInstrument"> | Date | string
    sections?: CensusSectionListRelationFilter
  }, "id" | "slug">

  export type CensusInstrumentOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CensusInstrumentCountOrderByAggregateInput
    _avg?: CensusInstrumentAvgOrderByAggregateInput
    _max?: CensusInstrumentMaxOrderByAggregateInput
    _min?: CensusInstrumentMinOrderByAggregateInput
    _sum?: CensusInstrumentSumOrderByAggregateInput
  }

  export type CensusInstrumentScalarWhereWithAggregatesInput = {
    AND?: CensusInstrumentScalarWhereWithAggregatesInput | CensusInstrumentScalarWhereWithAggregatesInput[]
    OR?: CensusInstrumentScalarWhereWithAggregatesInput[]
    NOT?: CensusInstrumentScalarWhereWithAggregatesInput | CensusInstrumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CensusInstrument"> | string
    slug?: StringWithAggregatesFilter<"CensusInstrument"> | string
    name?: StringWithAggregatesFilter<"CensusInstrument"> | string
    description?: StringNullableWithAggregatesFilter<"CensusInstrument"> | string | null
    version?: IntWithAggregatesFilter<"CensusInstrument"> | number
    isActive?: BoolWithAggregatesFilter<"CensusInstrument"> | boolean
    isRequired?: BoolWithAggregatesFilter<"CensusInstrument"> | boolean
    sortOrder?: IntWithAggregatesFilter<"CensusInstrument"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CensusInstrument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CensusInstrument"> | Date | string
  }

  export type CensusSectionWhereInput = {
    AND?: CensusSectionWhereInput | CensusSectionWhereInput[]
    OR?: CensusSectionWhereInput[]
    NOT?: CensusSectionWhereInput | CensusSectionWhereInput[]
    id?: StringFilter<"CensusSection"> | string
    instrumentId?: StringFilter<"CensusSection"> | string
    slug?: StringFilter<"CensusSection"> | string
    name?: StringFilter<"CensusSection"> | string
    description?: StringNullableFilter<"CensusSection"> | string | null
    icon?: StringNullableFilter<"CensusSection"> | string | null
    sortOrder?: IntFilter<"CensusSection"> | number
    estimatedTime?: IntFilter<"CensusSection"> | number
    questions?: CensusQuestionListRelationFilter
    instrument?: XOR<CensusInstrumentScalarRelationFilter, CensusInstrumentWhereInput>
  }

  export type CensusSectionOrderByWithRelationInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
    questions?: CensusQuestionOrderByRelationAggregateInput
    instrument?: CensusInstrumentOrderByWithRelationInput
  }

  export type CensusSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instrumentId_slug?: CensusSectionInstrumentIdSlugCompoundUniqueInput
    AND?: CensusSectionWhereInput | CensusSectionWhereInput[]
    OR?: CensusSectionWhereInput[]
    NOT?: CensusSectionWhereInput | CensusSectionWhereInput[]
    instrumentId?: StringFilter<"CensusSection"> | string
    slug?: StringFilter<"CensusSection"> | string
    name?: StringFilter<"CensusSection"> | string
    description?: StringNullableFilter<"CensusSection"> | string | null
    icon?: StringNullableFilter<"CensusSection"> | string | null
    sortOrder?: IntFilter<"CensusSection"> | number
    estimatedTime?: IntFilter<"CensusSection"> | number
    questions?: CensusQuestionListRelationFilter
    instrument?: XOR<CensusInstrumentScalarRelationFilter, CensusInstrumentWhereInput>
  }, "id" | "instrumentId_slug">

  export type CensusSectionOrderByWithAggregationInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
    _count?: CensusSectionCountOrderByAggregateInput
    _avg?: CensusSectionAvgOrderByAggregateInput
    _max?: CensusSectionMaxOrderByAggregateInput
    _min?: CensusSectionMinOrderByAggregateInput
    _sum?: CensusSectionSumOrderByAggregateInput
  }

  export type CensusSectionScalarWhereWithAggregatesInput = {
    AND?: CensusSectionScalarWhereWithAggregatesInput | CensusSectionScalarWhereWithAggregatesInput[]
    OR?: CensusSectionScalarWhereWithAggregatesInput[]
    NOT?: CensusSectionScalarWhereWithAggregatesInput | CensusSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CensusSection"> | string
    instrumentId?: StringWithAggregatesFilter<"CensusSection"> | string
    slug?: StringWithAggregatesFilter<"CensusSection"> | string
    name?: StringWithAggregatesFilter<"CensusSection"> | string
    description?: StringNullableWithAggregatesFilter<"CensusSection"> | string | null
    icon?: StringNullableWithAggregatesFilter<"CensusSection"> | string | null
    sortOrder?: IntWithAggregatesFilter<"CensusSection"> | number
    estimatedTime?: IntWithAggregatesFilter<"CensusSection"> | number
  }

  export type CensusQuestionWhereInput = {
    AND?: CensusQuestionWhereInput | CensusQuestionWhereInput[]
    OR?: CensusQuestionWhereInput[]
    NOT?: CensusQuestionWhereInput | CensusQuestionWhereInput[]
    id?: StringFilter<"CensusQuestion"> | string
    sectionId?: StringFilter<"CensusQuestion"> | string
    slug?: StringFilter<"CensusQuestion"> | string
    text?: StringFilter<"CensusQuestion"> | string
    helpText?: StringNullableFilter<"CensusQuestion"> | string | null
    type?: StringFilter<"CensusQuestion"> | string
    props?: JsonFilter<"CensusQuestion">
    isRequired?: BoolFilter<"CensusQuestion"> | boolean
    validation?: JsonNullableFilter<"CensusQuestion">
    sortOrder?: IntFilter<"CensusQuestion"> | number
    irtParams?: JsonNullableFilter<"CensusQuestion">
    groupId?: StringNullableFilter<"CensusQuestion"> | string | null
    groupLabel?: StringNullableFilter<"CensusQuestion"> | string | null
    showWhen?: JsonNullableFilter<"CensusQuestion">
    answers?: CensusAnswerListRelationFilter
    section?: XOR<CensusSectionScalarRelationFilter, CensusSectionWhereInput>
  }

  export type CensusQuestionOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    slug?: SortOrder
    text?: SortOrder
    helpText?: SortOrderInput | SortOrder
    type?: SortOrder
    props?: SortOrder
    isRequired?: SortOrder
    validation?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    irtParams?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    groupLabel?: SortOrderInput | SortOrder
    showWhen?: SortOrderInput | SortOrder
    answers?: CensusAnswerOrderByRelationAggregateInput
    section?: CensusSectionOrderByWithRelationInput
  }

  export type CensusQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionId_slug?: CensusQuestionSectionIdSlugCompoundUniqueInput
    AND?: CensusQuestionWhereInput | CensusQuestionWhereInput[]
    OR?: CensusQuestionWhereInput[]
    NOT?: CensusQuestionWhereInput | CensusQuestionWhereInput[]
    sectionId?: StringFilter<"CensusQuestion"> | string
    slug?: StringFilter<"CensusQuestion"> | string
    text?: StringFilter<"CensusQuestion"> | string
    helpText?: StringNullableFilter<"CensusQuestion"> | string | null
    type?: StringFilter<"CensusQuestion"> | string
    props?: JsonFilter<"CensusQuestion">
    isRequired?: BoolFilter<"CensusQuestion"> | boolean
    validation?: JsonNullableFilter<"CensusQuestion">
    sortOrder?: IntFilter<"CensusQuestion"> | number
    irtParams?: JsonNullableFilter<"CensusQuestion">
    groupId?: StringNullableFilter<"CensusQuestion"> | string | null
    groupLabel?: StringNullableFilter<"CensusQuestion"> | string | null
    showWhen?: JsonNullableFilter<"CensusQuestion">
    answers?: CensusAnswerListRelationFilter
    section?: XOR<CensusSectionScalarRelationFilter, CensusSectionWhereInput>
  }, "id" | "sectionId_slug">

  export type CensusQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    slug?: SortOrder
    text?: SortOrder
    helpText?: SortOrderInput | SortOrder
    type?: SortOrder
    props?: SortOrder
    isRequired?: SortOrder
    validation?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    irtParams?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    groupLabel?: SortOrderInput | SortOrder
    showWhen?: SortOrderInput | SortOrder
    _count?: CensusQuestionCountOrderByAggregateInput
    _avg?: CensusQuestionAvgOrderByAggregateInput
    _max?: CensusQuestionMaxOrderByAggregateInput
    _min?: CensusQuestionMinOrderByAggregateInput
    _sum?: CensusQuestionSumOrderByAggregateInput
  }

  export type CensusQuestionScalarWhereWithAggregatesInput = {
    AND?: CensusQuestionScalarWhereWithAggregatesInput | CensusQuestionScalarWhereWithAggregatesInput[]
    OR?: CensusQuestionScalarWhereWithAggregatesInput[]
    NOT?: CensusQuestionScalarWhereWithAggregatesInput | CensusQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CensusQuestion"> | string
    sectionId?: StringWithAggregatesFilter<"CensusQuestion"> | string
    slug?: StringWithAggregatesFilter<"CensusQuestion"> | string
    text?: StringWithAggregatesFilter<"CensusQuestion"> | string
    helpText?: StringNullableWithAggregatesFilter<"CensusQuestion"> | string | null
    type?: StringWithAggregatesFilter<"CensusQuestion"> | string
    props?: JsonWithAggregatesFilter<"CensusQuestion">
    isRequired?: BoolWithAggregatesFilter<"CensusQuestion"> | boolean
    validation?: JsonNullableWithAggregatesFilter<"CensusQuestion">
    sortOrder?: IntWithAggregatesFilter<"CensusQuestion"> | number
    irtParams?: JsonNullableWithAggregatesFilter<"CensusQuestion">
    groupId?: StringNullableWithAggregatesFilter<"CensusQuestion"> | string | null
    groupLabel?: StringNullableWithAggregatesFilter<"CensusQuestion"> | string | null
    showWhen?: JsonNullableWithAggregatesFilter<"CensusQuestion">
  }

  export type CensusAnswerWhereInput = {
    AND?: CensusAnswerWhereInput | CensusAnswerWhereInput[]
    OR?: CensusAnswerWhereInput[]
    NOT?: CensusAnswerWhereInput | CensusAnswerWhereInput[]
    id?: StringFilter<"CensusAnswer"> | string
    userId?: StringFilter<"CensusAnswer"> | string
    questionId?: StringFilter<"CensusAnswer"> | string
    value?: JsonFilter<"CensusAnswer">
    instrumentVersion?: IntFilter<"CensusAnswer"> | number
    createdAt?: DateTimeFilter<"CensusAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"CensusAnswer"> | Date | string
    question?: XOR<CensusQuestionScalarRelationFilter, CensusQuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CensusAnswerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    instrumentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: CensusQuestionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CensusAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_questionId?: CensusAnswerUserIdQuestionIdCompoundUniqueInput
    AND?: CensusAnswerWhereInput | CensusAnswerWhereInput[]
    OR?: CensusAnswerWhereInput[]
    NOT?: CensusAnswerWhereInput | CensusAnswerWhereInput[]
    userId?: StringFilter<"CensusAnswer"> | string
    questionId?: StringFilter<"CensusAnswer"> | string
    value?: JsonFilter<"CensusAnswer">
    instrumentVersion?: IntFilter<"CensusAnswer"> | number
    createdAt?: DateTimeFilter<"CensusAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"CensusAnswer"> | Date | string
    question?: XOR<CensusQuestionScalarRelationFilter, CensusQuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_questionId">

  export type CensusAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    instrumentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CensusAnswerCountOrderByAggregateInput
    _avg?: CensusAnswerAvgOrderByAggregateInput
    _max?: CensusAnswerMaxOrderByAggregateInput
    _min?: CensusAnswerMinOrderByAggregateInput
    _sum?: CensusAnswerSumOrderByAggregateInput
  }

  export type CensusAnswerScalarWhereWithAggregatesInput = {
    AND?: CensusAnswerScalarWhereWithAggregatesInput | CensusAnswerScalarWhereWithAggregatesInput[]
    OR?: CensusAnswerScalarWhereWithAggregatesInput[]
    NOT?: CensusAnswerScalarWhereWithAggregatesInput | CensusAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CensusAnswer"> | string
    userId?: StringWithAggregatesFilter<"CensusAnswer"> | string
    questionId?: StringWithAggregatesFilter<"CensusAnswer"> | string
    value?: JsonWithAggregatesFilter<"CensusAnswer">
    instrumentVersion?: IntWithAggregatesFilter<"CensusAnswer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CensusAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CensusAnswer"> | Date | string
  }

  export type CensusProgressWhereInput = {
    AND?: CensusProgressWhereInput | CensusProgressWhereInput[]
    OR?: CensusProgressWhereInput[]
    NOT?: CensusProgressWhereInput | CensusProgressWhereInput[]
    id?: StringFilter<"CensusProgress"> | string
    userId?: StringFilter<"CensusProgress"> | string
    sectionProgress?: JsonFilter<"CensusProgress">
    totalCompleted?: IntFilter<"CensusProgress"> | number
    totalQuestions?: IntFilter<"CensusProgress"> | number
    scores?: JsonNullableFilter<"CensusProgress">
    lastActivityAt?: DateTimeFilter<"CensusProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"CensusProgress"> | Date | string | null
  }

  export type CensusProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sectionProgress?: SortOrder
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
    scores?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type CensusProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CensusProgressWhereInput | CensusProgressWhereInput[]
    OR?: CensusProgressWhereInput[]
    NOT?: CensusProgressWhereInput | CensusProgressWhereInput[]
    sectionProgress?: JsonFilter<"CensusProgress">
    totalCompleted?: IntFilter<"CensusProgress"> | number
    totalQuestions?: IntFilter<"CensusProgress"> | number
    scores?: JsonNullableFilter<"CensusProgress">
    lastActivityAt?: DateTimeFilter<"CensusProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"CensusProgress"> | Date | string | null
  }, "id" | "userId">

  export type CensusProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sectionProgress?: SortOrder
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
    scores?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CensusProgressCountOrderByAggregateInput
    _avg?: CensusProgressAvgOrderByAggregateInput
    _max?: CensusProgressMaxOrderByAggregateInput
    _min?: CensusProgressMinOrderByAggregateInput
    _sum?: CensusProgressSumOrderByAggregateInput
  }

  export type CensusProgressScalarWhereWithAggregatesInput = {
    AND?: CensusProgressScalarWhereWithAggregatesInput | CensusProgressScalarWhereWithAggregatesInput[]
    OR?: CensusProgressScalarWhereWithAggregatesInput[]
    NOT?: CensusProgressScalarWhereWithAggregatesInput | CensusProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CensusProgress"> | string
    userId?: StringWithAggregatesFilter<"CensusProgress"> | string
    sectionProgress?: JsonWithAggregatesFilter<"CensusProgress">
    totalCompleted?: IntWithAggregatesFilter<"CensusProgress"> | number
    totalQuestions?: IntWithAggregatesFilter<"CensusProgress"> | number
    scores?: JsonNullableWithAggregatesFilter<"CensusProgress">
    lastActivityAt?: DateTimeWithAggregatesFilter<"CensusProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CensusProgress"> | Date | string | null
  }

  export type PromptWhereInput = {
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    id?: StringFilter<"Prompt"> | string
    text?: StringFilter<"Prompt"> | string
    type?: StringFilter<"Prompt"> | string
    responseType?: StringFilter<"Prompt"> | string
    responseProps?: JsonNullableFilter<"Prompt">
    isActive?: BoolFilter<"Prompt"> | boolean
    frequency?: StringNullableFilter<"Prompt"> | string | null
    targetingRules?: JsonNullableFilter<"Prompt">
    studyId?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    study?: XOR<StudyNullableScalarRelationFilter, StudyWhereInput> | null
    responses?: PromptResponseListRelationFilter
  }

  export type PromptOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    responseProps?: SortOrderInput | SortOrder
    isActive?: SortOrder
    frequency?: SortOrderInput | SortOrder
    targetingRules?: SortOrderInput | SortOrder
    studyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    study?: StudyOrderByWithRelationInput
    responses?: PromptResponseOrderByRelationAggregateInput
  }

  export type PromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    text?: StringFilter<"Prompt"> | string
    type?: StringFilter<"Prompt"> | string
    responseType?: StringFilter<"Prompt"> | string
    responseProps?: JsonNullableFilter<"Prompt">
    isActive?: BoolFilter<"Prompt"> | boolean
    frequency?: StringNullableFilter<"Prompt"> | string | null
    targetingRules?: JsonNullableFilter<"Prompt">
    studyId?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    study?: XOR<StudyNullableScalarRelationFilter, StudyWhereInput> | null
    responses?: PromptResponseListRelationFilter
  }, "id">

  export type PromptOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    responseProps?: SortOrderInput | SortOrder
    isActive?: SortOrder
    frequency?: SortOrderInput | SortOrder
    targetingRules?: SortOrderInput | SortOrder
    studyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromptCountOrderByAggregateInput
    _max?: PromptMaxOrderByAggregateInput
    _min?: PromptMinOrderByAggregateInput
  }

  export type PromptScalarWhereWithAggregatesInput = {
    AND?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    OR?: PromptScalarWhereWithAggregatesInput[]
    NOT?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prompt"> | string
    text?: StringWithAggregatesFilter<"Prompt"> | string
    type?: StringWithAggregatesFilter<"Prompt"> | string
    responseType?: StringWithAggregatesFilter<"Prompt"> | string
    responseProps?: JsonNullableWithAggregatesFilter<"Prompt">
    isActive?: BoolWithAggregatesFilter<"Prompt"> | boolean
    frequency?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    targetingRules?: JsonNullableWithAggregatesFilter<"Prompt">
    studyId?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
  }

  export type PromptResponseWhereInput = {
    AND?: PromptResponseWhereInput | PromptResponseWhereInput[]
    OR?: PromptResponseWhereInput[]
    NOT?: PromptResponseWhereInput | PromptResponseWhereInput[]
    id?: StringFilter<"PromptResponse"> | string
    userId?: StringFilter<"PromptResponse"> | string
    promptId?: StringFilter<"PromptResponse"> | string
    value?: JsonFilter<"PromptResponse">
    shownAt?: DateTimeFilter<"PromptResponse"> | Date | string
    respondedAt?: DateTimeFilter<"PromptResponse"> | Date | string
    skipped?: BoolFilter<"PromptResponse"> | boolean
    prompt?: XOR<PromptScalarRelationFilter, PromptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PromptResponseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    value?: SortOrder
    shownAt?: SortOrder
    respondedAt?: SortOrder
    skipped?: SortOrder
    prompt?: PromptOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PromptResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_promptId_shownAt?: PromptResponseUserIdPromptIdShownAtCompoundUniqueInput
    AND?: PromptResponseWhereInput | PromptResponseWhereInput[]
    OR?: PromptResponseWhereInput[]
    NOT?: PromptResponseWhereInput | PromptResponseWhereInput[]
    userId?: StringFilter<"PromptResponse"> | string
    promptId?: StringFilter<"PromptResponse"> | string
    value?: JsonFilter<"PromptResponse">
    shownAt?: DateTimeFilter<"PromptResponse"> | Date | string
    respondedAt?: DateTimeFilter<"PromptResponse"> | Date | string
    skipped?: BoolFilter<"PromptResponse"> | boolean
    prompt?: XOR<PromptScalarRelationFilter, PromptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_promptId_shownAt">

  export type PromptResponseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    value?: SortOrder
    shownAt?: SortOrder
    respondedAt?: SortOrder
    skipped?: SortOrder
    _count?: PromptResponseCountOrderByAggregateInput
    _max?: PromptResponseMaxOrderByAggregateInput
    _min?: PromptResponseMinOrderByAggregateInput
  }

  export type PromptResponseScalarWhereWithAggregatesInput = {
    AND?: PromptResponseScalarWhereWithAggregatesInput | PromptResponseScalarWhereWithAggregatesInput[]
    OR?: PromptResponseScalarWhereWithAggregatesInput[]
    NOT?: PromptResponseScalarWhereWithAggregatesInput | PromptResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptResponse"> | string
    userId?: StringWithAggregatesFilter<"PromptResponse"> | string
    promptId?: StringWithAggregatesFilter<"PromptResponse"> | string
    value?: JsonWithAggregatesFilter<"PromptResponse">
    shownAt?: DateTimeWithAggregatesFilter<"PromptResponse"> | Date | string
    respondedAt?: DateTimeWithAggregatesFilter<"PromptResponse"> | Date | string
    skipped?: BoolWithAggregatesFilter<"PromptResponse"> | boolean
  }

  export type ConsentWhereInput = {
    AND?: ConsentWhereInput | ConsentWhereInput[]
    OR?: ConsentWhereInput[]
    NOT?: ConsentWhereInput | ConsentWhereInput[]
    id?: StringFilter<"Consent"> | string
    userId?: StringFilter<"Consent"> | string
    scope?: StringFilter<"Consent"> | string
    version?: IntFilter<"Consent"> | number
    granted?: BoolFilter<"Consent"> | boolean
    timestamp?: DateTimeFilter<"Consent"> | Date | string
    receiptHash?: StringFilter<"Consent"> | string
    policyHash?: StringFilter<"Consent"> | string
    jurisdiction?: StringNullableFilter<"Consent"> | string | null
    ipHash?: StringNullableFilter<"Consent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    version?: SortOrder
    granted?: SortOrder
    timestamp?: SortOrder
    receiptHash?: SortOrder
    policyHash?: SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsentWhereInput | ConsentWhereInput[]
    OR?: ConsentWhereInput[]
    NOT?: ConsentWhereInput | ConsentWhereInput[]
    userId?: StringFilter<"Consent"> | string
    scope?: StringFilter<"Consent"> | string
    version?: IntFilter<"Consent"> | number
    granted?: BoolFilter<"Consent"> | boolean
    timestamp?: DateTimeFilter<"Consent"> | Date | string
    receiptHash?: StringFilter<"Consent"> | string
    policyHash?: StringFilter<"Consent"> | string
    jurisdiction?: StringNullableFilter<"Consent"> | string | null
    ipHash?: StringNullableFilter<"Consent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    version?: SortOrder
    granted?: SortOrder
    timestamp?: SortOrder
    receiptHash?: SortOrder
    policyHash?: SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    _count?: ConsentCountOrderByAggregateInput
    _avg?: ConsentAvgOrderByAggregateInput
    _max?: ConsentMaxOrderByAggregateInput
    _min?: ConsentMinOrderByAggregateInput
    _sum?: ConsentSumOrderByAggregateInput
  }

  export type ConsentScalarWhereWithAggregatesInput = {
    AND?: ConsentScalarWhereWithAggregatesInput | ConsentScalarWhereWithAggregatesInput[]
    OR?: ConsentScalarWhereWithAggregatesInput[]
    NOT?: ConsentScalarWhereWithAggregatesInput | ConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consent"> | string
    userId?: StringWithAggregatesFilter<"Consent"> | string
    scope?: StringWithAggregatesFilter<"Consent"> | string
    version?: IntWithAggregatesFilter<"Consent"> | number
    granted?: BoolWithAggregatesFilter<"Consent"> | boolean
    timestamp?: DateTimeWithAggregatesFilter<"Consent"> | Date | string
    receiptHash?: StringWithAggregatesFilter<"Consent"> | string
    policyHash?: StringWithAggregatesFilter<"Consent"> | string
    jurisdiction?: StringNullableWithAggregatesFilter<"Consent"> | string | null
    ipHash?: StringNullableWithAggregatesFilter<"Consent"> | string | null
  }

  export type WeatherAggregateWhereInput = {
    AND?: WeatherAggregateWhereInput | WeatherAggregateWhereInput[]
    OR?: WeatherAggregateWhereInput[]
    NOT?: WeatherAggregateWhereInput | WeatherAggregateWhereInput[]
    id?: StringFilter<"WeatherAggregate"> | string
    metric?: StringFilter<"WeatherAggregate"> | string
    period?: StringFilter<"WeatherAggregate"> | string
    periodStart?: DateTimeFilter<"WeatherAggregate"> | Date | string
    value?: JsonFilter<"WeatherAggregate">
    sampleN?: IntFilter<"WeatherAggregate"> | number
    dpEpsilon?: FloatNullableFilter<"WeatherAggregate"> | number | null
    dpDelta?: FloatNullableFilter<"WeatherAggregate"> | number | null
    minNThreshold?: IntFilter<"WeatherAggregate"> | number
    region?: StringNullableFilter<"WeatherAggregate"> | string | null
    methodVersion?: IntFilter<"WeatherAggregate"> | number
    computedAt?: DateTimeFilter<"WeatherAggregate"> | Date | string
  }

  export type WeatherAggregateOrderByWithRelationInput = {
    id?: SortOrder
    metric?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    value?: SortOrder
    sampleN?: SortOrder
    dpEpsilon?: SortOrderInput | SortOrder
    dpDelta?: SortOrderInput | SortOrder
    minNThreshold?: SortOrder
    region?: SortOrderInput | SortOrder
    methodVersion?: SortOrder
    computedAt?: SortOrder
  }

  export type WeatherAggregateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metric_period_periodStart_region?: WeatherAggregateMetricPeriodPeriodStartRegionCompoundUniqueInput
    AND?: WeatherAggregateWhereInput | WeatherAggregateWhereInput[]
    OR?: WeatherAggregateWhereInput[]
    NOT?: WeatherAggregateWhereInput | WeatherAggregateWhereInput[]
    metric?: StringFilter<"WeatherAggregate"> | string
    period?: StringFilter<"WeatherAggregate"> | string
    periodStart?: DateTimeFilter<"WeatherAggregate"> | Date | string
    value?: JsonFilter<"WeatherAggregate">
    sampleN?: IntFilter<"WeatherAggregate"> | number
    dpEpsilon?: FloatNullableFilter<"WeatherAggregate"> | number | null
    dpDelta?: FloatNullableFilter<"WeatherAggregate"> | number | null
    minNThreshold?: IntFilter<"WeatherAggregate"> | number
    region?: StringNullableFilter<"WeatherAggregate"> | string | null
    methodVersion?: IntFilter<"WeatherAggregate"> | number
    computedAt?: DateTimeFilter<"WeatherAggregate"> | Date | string
  }, "id" | "metric_period_periodStart_region">

  export type WeatherAggregateOrderByWithAggregationInput = {
    id?: SortOrder
    metric?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    value?: SortOrder
    sampleN?: SortOrder
    dpEpsilon?: SortOrderInput | SortOrder
    dpDelta?: SortOrderInput | SortOrder
    minNThreshold?: SortOrder
    region?: SortOrderInput | SortOrder
    methodVersion?: SortOrder
    computedAt?: SortOrder
    _count?: WeatherAggregateCountOrderByAggregateInput
    _avg?: WeatherAggregateAvgOrderByAggregateInput
    _max?: WeatherAggregateMaxOrderByAggregateInput
    _min?: WeatherAggregateMinOrderByAggregateInput
    _sum?: WeatherAggregateSumOrderByAggregateInput
  }

  export type WeatherAggregateScalarWhereWithAggregatesInput = {
    AND?: WeatherAggregateScalarWhereWithAggregatesInput | WeatherAggregateScalarWhereWithAggregatesInput[]
    OR?: WeatherAggregateScalarWhereWithAggregatesInput[]
    NOT?: WeatherAggregateScalarWhereWithAggregatesInput | WeatherAggregateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeatherAggregate"> | string
    metric?: StringWithAggregatesFilter<"WeatherAggregate"> | string
    period?: StringWithAggregatesFilter<"WeatherAggregate"> | string
    periodStart?: DateTimeWithAggregatesFilter<"WeatherAggregate"> | Date | string
    value?: JsonWithAggregatesFilter<"WeatherAggregate">
    sampleN?: IntWithAggregatesFilter<"WeatherAggregate"> | number
    dpEpsilon?: FloatNullableWithAggregatesFilter<"WeatherAggregate"> | number | null
    dpDelta?: FloatNullableWithAggregatesFilter<"WeatherAggregate"> | number | null
    minNThreshold?: IntWithAggregatesFilter<"WeatherAggregate"> | number
    region?: StringNullableWithAggregatesFilter<"WeatherAggregate"> | string | null
    methodVersion?: IntWithAggregatesFilter<"WeatherAggregate"> | number
    computedAt?: DateTimeWithAggregatesFilter<"WeatherAggregate"> | Date | string
  }

  export type PersonalWeatherWhereInput = {
    AND?: PersonalWeatherWhereInput | PersonalWeatherWhereInput[]
    OR?: PersonalWeatherWhereInput[]
    NOT?: PersonalWeatherWhereInput | PersonalWeatherWhereInput[]
    id?: StringFilter<"PersonalWeather"> | string
    userId?: StringFilter<"PersonalWeather"> | string
    weather?: JsonFilter<"PersonalWeather">
    streaks?: JsonNullableFilter<"PersonalWeather">
    lastComputedAt?: DateTimeFilter<"PersonalWeather"> | Date | string
  }

  export type PersonalWeatherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    weather?: SortOrder
    streaks?: SortOrderInput | SortOrder
    lastComputedAt?: SortOrder
  }

  export type PersonalWeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PersonalWeatherWhereInput | PersonalWeatherWhereInput[]
    OR?: PersonalWeatherWhereInput[]
    NOT?: PersonalWeatherWhereInput | PersonalWeatherWhereInput[]
    weather?: JsonFilter<"PersonalWeather">
    streaks?: JsonNullableFilter<"PersonalWeather">
    lastComputedAt?: DateTimeFilter<"PersonalWeather"> | Date | string
  }, "id" | "userId">

  export type PersonalWeatherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    weather?: SortOrder
    streaks?: SortOrderInput | SortOrder
    lastComputedAt?: SortOrder
    _count?: PersonalWeatherCountOrderByAggregateInput
    _max?: PersonalWeatherMaxOrderByAggregateInput
    _min?: PersonalWeatherMinOrderByAggregateInput
  }

  export type PersonalWeatherScalarWhereWithAggregatesInput = {
    AND?: PersonalWeatherScalarWhereWithAggregatesInput | PersonalWeatherScalarWhereWithAggregatesInput[]
    OR?: PersonalWeatherScalarWhereWithAggregatesInput[]
    NOT?: PersonalWeatherScalarWhereWithAggregatesInput | PersonalWeatherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalWeather"> | string
    userId?: StringWithAggregatesFilter<"PersonalWeather"> | string
    weather?: JsonWithAggregatesFilter<"PersonalWeather">
    streaks?: JsonNullableWithAggregatesFilter<"PersonalWeather">
    lastComputedAt?: DateTimeWithAggregatesFilter<"PersonalWeather"> | Date | string
  }

  export type StudyWhereInput = {
    AND?: StudyWhereInput | StudyWhereInput[]
    OR?: StudyWhereInput[]
    NOT?: StudyWhereInput | StudyWhereInput[]
    id?: StringFilter<"Study"> | string
    slug?: StringFilter<"Study"> | string
    title?: StringFilter<"Study"> | string
    description?: StringFilter<"Study"> | string
    institution?: StringNullableFilter<"Study"> | string | null
    dataScope?: JsonFilter<"Study">
    duration?: StringNullableFilter<"Study"> | string | null
    consentText?: StringFilter<"Study"> | string
    consentVersion?: IntFilter<"Study"> | number
    status?: StringFilter<"Study"> | string
    startsAt?: DateTimeNullableFilter<"Study"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Study"> | Date | string | null
    maxParticipants?: IntNullableFilter<"Study"> | number | null
    createdAt?: DateTimeFilter<"Study"> | Date | string
    updatedAt?: DateTimeFilter<"Study"> | Date | string
    prompts?: PromptListRelationFilter
    participations?: StudyParticipationListRelationFilter
  }

  export type StudyOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    institution?: SortOrderInput | SortOrder
    dataScope?: SortOrder
    duration?: SortOrderInput | SortOrder
    consentText?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prompts?: PromptOrderByRelationAggregateInput
    participations?: StudyParticipationOrderByRelationAggregateInput
  }

  export type StudyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: StudyWhereInput | StudyWhereInput[]
    OR?: StudyWhereInput[]
    NOT?: StudyWhereInput | StudyWhereInput[]
    title?: StringFilter<"Study"> | string
    description?: StringFilter<"Study"> | string
    institution?: StringNullableFilter<"Study"> | string | null
    dataScope?: JsonFilter<"Study">
    duration?: StringNullableFilter<"Study"> | string | null
    consentText?: StringFilter<"Study"> | string
    consentVersion?: IntFilter<"Study"> | number
    status?: StringFilter<"Study"> | string
    startsAt?: DateTimeNullableFilter<"Study"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Study"> | Date | string | null
    maxParticipants?: IntNullableFilter<"Study"> | number | null
    createdAt?: DateTimeFilter<"Study"> | Date | string
    updatedAt?: DateTimeFilter<"Study"> | Date | string
    prompts?: PromptListRelationFilter
    participations?: StudyParticipationListRelationFilter
  }, "id" | "slug">

  export type StudyOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    institution?: SortOrderInput | SortOrder
    dataScope?: SortOrder
    duration?: SortOrderInput | SortOrder
    consentText?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudyCountOrderByAggregateInput
    _avg?: StudyAvgOrderByAggregateInput
    _max?: StudyMaxOrderByAggregateInput
    _min?: StudyMinOrderByAggregateInput
    _sum?: StudySumOrderByAggregateInput
  }

  export type StudyScalarWhereWithAggregatesInput = {
    AND?: StudyScalarWhereWithAggregatesInput | StudyScalarWhereWithAggregatesInput[]
    OR?: StudyScalarWhereWithAggregatesInput[]
    NOT?: StudyScalarWhereWithAggregatesInput | StudyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Study"> | string
    slug?: StringWithAggregatesFilter<"Study"> | string
    title?: StringWithAggregatesFilter<"Study"> | string
    description?: StringWithAggregatesFilter<"Study"> | string
    institution?: StringNullableWithAggregatesFilter<"Study"> | string | null
    dataScope?: JsonWithAggregatesFilter<"Study">
    duration?: StringNullableWithAggregatesFilter<"Study"> | string | null
    consentText?: StringWithAggregatesFilter<"Study"> | string
    consentVersion?: IntWithAggregatesFilter<"Study"> | number
    status?: StringWithAggregatesFilter<"Study"> | string
    startsAt?: DateTimeNullableWithAggregatesFilter<"Study"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Study"> | Date | string | null
    maxParticipants?: IntNullableWithAggregatesFilter<"Study"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Study"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Study"> | Date | string
  }

  export type StudyParticipationWhereInput = {
    AND?: StudyParticipationWhereInput | StudyParticipationWhereInput[]
    OR?: StudyParticipationWhereInput[]
    NOT?: StudyParticipationWhereInput | StudyParticipationWhereInput[]
    id?: StringFilter<"StudyParticipation"> | string
    userId?: StringFilter<"StudyParticipation"> | string
    studyId?: StringFilter<"StudyParticipation"> | string
    consentedAt?: DateTimeFilter<"StudyParticipation"> | Date | string
    consentVersion?: IntFilter<"StudyParticipation"> | number
    status?: StringFilter<"StudyParticipation"> | string
    withdrawnAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"StudyParticipation"> | string | null
    completedAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StudyParticipationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studyId?: SortOrder
    consentedAt?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    withdrawalReason?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    study?: StudyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StudyParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_studyId?: StudyParticipationUserIdStudyIdCompoundUniqueInput
    AND?: StudyParticipationWhereInput | StudyParticipationWhereInput[]
    OR?: StudyParticipationWhereInput[]
    NOT?: StudyParticipationWhereInput | StudyParticipationWhereInput[]
    userId?: StringFilter<"StudyParticipation"> | string
    studyId?: StringFilter<"StudyParticipation"> | string
    consentedAt?: DateTimeFilter<"StudyParticipation"> | Date | string
    consentVersion?: IntFilter<"StudyParticipation"> | number
    status?: StringFilter<"StudyParticipation"> | string
    withdrawnAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"StudyParticipation"> | string | null
    completedAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_studyId">

  export type StudyParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studyId?: SortOrder
    consentedAt?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    withdrawalReason?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: StudyParticipationCountOrderByAggregateInput
    _avg?: StudyParticipationAvgOrderByAggregateInput
    _max?: StudyParticipationMaxOrderByAggregateInput
    _min?: StudyParticipationMinOrderByAggregateInput
    _sum?: StudyParticipationSumOrderByAggregateInput
  }

  export type StudyParticipationScalarWhereWithAggregatesInput = {
    AND?: StudyParticipationScalarWhereWithAggregatesInput | StudyParticipationScalarWhereWithAggregatesInput[]
    OR?: StudyParticipationScalarWhereWithAggregatesInput[]
    NOT?: StudyParticipationScalarWhereWithAggregatesInput | StudyParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyParticipation"> | string
    userId?: StringWithAggregatesFilter<"StudyParticipation"> | string
    studyId?: StringWithAggregatesFilter<"StudyParticipation"> | string
    consentedAt?: DateTimeWithAggregatesFilter<"StudyParticipation"> | Date | string
    consentVersion?: IntWithAggregatesFilter<"StudyParticipation"> | number
    status?: StringWithAggregatesFilter<"StudyParticipation"> | string
    withdrawnAt?: DateTimeNullableWithAggregatesFilter<"StudyParticipation"> | Date | string | null
    withdrawalReason?: StringNullableWithAggregatesFilter<"StudyParticipation"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"StudyParticipation"> | Date | string | null
  }

  export type EmotionWhereInput = {
    AND?: EmotionWhereInput | EmotionWhereInput[]
    OR?: EmotionWhereInput[]
    NOT?: EmotionWhereInput | EmotionWhereInput[]
    id?: StringFilter<"Emotion"> | string
    name?: StringFilter<"Emotion"> | string
    slug?: StringFilter<"Emotion"> | string
    valence?: FloatFilter<"Emotion"> | number
    arousal?: FloatFilter<"Emotion"> | number
    parentId?: StringNullableFilter<"Emotion"> | string | null
    translations?: JsonNullableFilter<"Emotion">
    version?: IntFilter<"Emotion"> | number
    parent?: XOR<EmotionNullableScalarRelationFilter, EmotionWhereInput> | null
    children?: EmotionListRelationFilter
  }

  export type EmotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    parentId?: SortOrderInput | SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
    parent?: EmotionOrderByWithRelationInput
    children?: EmotionOrderByRelationAggregateInput
  }

  export type EmotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: EmotionWhereInput | EmotionWhereInput[]
    OR?: EmotionWhereInput[]
    NOT?: EmotionWhereInput | EmotionWhereInput[]
    name?: StringFilter<"Emotion"> | string
    valence?: FloatFilter<"Emotion"> | number
    arousal?: FloatFilter<"Emotion"> | number
    parentId?: StringNullableFilter<"Emotion"> | string | null
    translations?: JsonNullableFilter<"Emotion">
    version?: IntFilter<"Emotion"> | number
    parent?: XOR<EmotionNullableScalarRelationFilter, EmotionWhereInput> | null
    children?: EmotionListRelationFilter
  }, "id" | "slug">

  export type EmotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    parentId?: SortOrderInput | SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: EmotionCountOrderByAggregateInput
    _avg?: EmotionAvgOrderByAggregateInput
    _max?: EmotionMaxOrderByAggregateInput
    _min?: EmotionMinOrderByAggregateInput
    _sum?: EmotionSumOrderByAggregateInput
  }

  export type EmotionScalarWhereWithAggregatesInput = {
    AND?: EmotionScalarWhereWithAggregatesInput | EmotionScalarWhereWithAggregatesInput[]
    OR?: EmotionScalarWhereWithAggregatesInput[]
    NOT?: EmotionScalarWhereWithAggregatesInput | EmotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Emotion"> | string
    name?: StringWithAggregatesFilter<"Emotion"> | string
    slug?: StringWithAggregatesFilter<"Emotion"> | string
    valence?: FloatWithAggregatesFilter<"Emotion"> | number
    arousal?: FloatWithAggregatesFilter<"Emotion"> | number
    parentId?: StringNullableWithAggregatesFilter<"Emotion"> | string | null
    translations?: JsonNullableWithAggregatesFilter<"Emotion">
    version?: IntWithAggregatesFilter<"Emotion"> | number
  }

  export type SymbolWhereInput = {
    AND?: SymbolWhereInput | SymbolWhereInput[]
    OR?: SymbolWhereInput[]
    NOT?: SymbolWhereInput | SymbolWhereInput[]
    id?: StringFilter<"Symbol"> | string
    name?: StringFilter<"Symbol"> | string
    slug?: StringFilter<"Symbol"> | string
    category?: StringFilter<"Symbol"> | string
    description?: StringNullableFilter<"Symbol"> | string | null
    interpretations?: JsonNullableFilter<"Symbol">
    translations?: JsonNullableFilter<"Symbol">
    version?: IntFilter<"Symbol"> | number
  }

  export type SymbolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    interpretations?: SortOrderInput | SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
  }

  export type SymbolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SymbolWhereInput | SymbolWhereInput[]
    OR?: SymbolWhereInput[]
    NOT?: SymbolWhereInput | SymbolWhereInput[]
    name?: StringFilter<"Symbol"> | string
    category?: StringFilter<"Symbol"> | string
    description?: StringNullableFilter<"Symbol"> | string | null
    interpretations?: JsonNullableFilter<"Symbol">
    translations?: JsonNullableFilter<"Symbol">
    version?: IntFilter<"Symbol"> | number
  }, "id" | "slug">

  export type SymbolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    interpretations?: SortOrderInput | SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: SymbolCountOrderByAggregateInput
    _avg?: SymbolAvgOrderByAggregateInput
    _max?: SymbolMaxOrderByAggregateInput
    _min?: SymbolMinOrderByAggregateInput
    _sum?: SymbolSumOrderByAggregateInput
  }

  export type SymbolScalarWhereWithAggregatesInput = {
    AND?: SymbolScalarWhereWithAggregatesInput | SymbolScalarWhereWithAggregatesInput[]
    OR?: SymbolScalarWhereWithAggregatesInput[]
    NOT?: SymbolScalarWhereWithAggregatesInput | SymbolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Symbol"> | string
    name?: StringWithAggregatesFilter<"Symbol"> | string
    slug?: StringWithAggregatesFilter<"Symbol"> | string
    category?: StringWithAggregatesFilter<"Symbol"> | string
    description?: StringNullableWithAggregatesFilter<"Symbol"> | string | null
    interpretations?: JsonNullableWithAggregatesFilter<"Symbol">
    translations?: JsonNullableWithAggregatesFilter<"Symbol">
    version?: IntWithAggregatesFilter<"Symbol"> | number
  }

  export type ThemeWhereInput = {
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    id?: StringFilter<"Theme"> | string
    name?: StringFilter<"Theme"> | string
    slug?: StringFilter<"Theme"> | string
    description?: StringNullableFilter<"Theme"> | string | null
    relatedSlugs?: StringNullableListFilter<"Theme">
    translations?: JsonNullableFilter<"Theme">
    version?: IntFilter<"Theme"> | number
  }

  export type ThemeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedSlugs?: SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
  }

  export type ThemeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    name?: StringFilter<"Theme"> | string
    description?: StringNullableFilter<"Theme"> | string | null
    relatedSlugs?: StringNullableListFilter<"Theme">
    translations?: JsonNullableFilter<"Theme">
    version?: IntFilter<"Theme"> | number
  }, "id" | "slug">

  export type ThemeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedSlugs?: SortOrder
    translations?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: ThemeCountOrderByAggregateInput
    _avg?: ThemeAvgOrderByAggregateInput
    _max?: ThemeMaxOrderByAggregateInput
    _min?: ThemeMinOrderByAggregateInput
    _sum?: ThemeSumOrderByAggregateInput
  }

  export type ThemeScalarWhereWithAggregatesInput = {
    AND?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    OR?: ThemeScalarWhereWithAggregatesInput[]
    NOT?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Theme"> | string
    name?: StringWithAggregatesFilter<"Theme"> | string
    slug?: StringWithAggregatesFilter<"Theme"> | string
    description?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    relatedSlugs?: StringNullableListFilter<"Theme">
    translations?: JsonNullableWithAggregatesFilter<"Theme">
    version?: IntWithAggregatesFilter<"Theme"> | number
  }

  export type NightCheckInWhereInput = {
    AND?: NightCheckInWhereInput | NightCheckInWhereInput[]
    OR?: NightCheckInWhereInput[]
    NOT?: NightCheckInWhereInput | NightCheckInWhereInput[]
    id?: StringFilter<"NightCheckIn"> | string
    userId?: StringFilter<"NightCheckIn"> | string
    date?: StringFilter<"NightCheckIn"> | string
    mood?: StringNullableFilter<"NightCheckIn"> | string | null
    dayNotes?: StringNullableFilter<"NightCheckIn"> | string | null
    intention?: StringNullableFilter<"NightCheckIn"> | string | null
    plannedWakeTime?: StringNullableFilter<"NightCheckIn"> | string | null
    reminderEnabled?: BoolFilter<"NightCheckIn"> | boolean
    createdAt?: DateTimeFilter<"NightCheckIn"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NightCheckInOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    dayNotes?: SortOrderInput | SortOrder
    intention?: SortOrderInput | SortOrder
    plannedWakeTime?: SortOrderInput | SortOrder
    reminderEnabled?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NightCheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: NightCheckInUserIdDateCompoundUniqueInput
    AND?: NightCheckInWhereInput | NightCheckInWhereInput[]
    OR?: NightCheckInWhereInput[]
    NOT?: NightCheckInWhereInput | NightCheckInWhereInput[]
    userId?: StringFilter<"NightCheckIn"> | string
    date?: StringFilter<"NightCheckIn"> | string
    mood?: StringNullableFilter<"NightCheckIn"> | string | null
    dayNotes?: StringNullableFilter<"NightCheckIn"> | string | null
    intention?: StringNullableFilter<"NightCheckIn"> | string | null
    plannedWakeTime?: StringNullableFilter<"NightCheckIn"> | string | null
    reminderEnabled?: BoolFilter<"NightCheckIn"> | boolean
    createdAt?: DateTimeFilter<"NightCheckIn"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type NightCheckInOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    dayNotes?: SortOrderInput | SortOrder
    intention?: SortOrderInput | SortOrder
    plannedWakeTime?: SortOrderInput | SortOrder
    reminderEnabled?: SortOrder
    createdAt?: SortOrder
    _count?: NightCheckInCountOrderByAggregateInput
    _max?: NightCheckInMaxOrderByAggregateInput
    _min?: NightCheckInMinOrderByAggregateInput
  }

  export type NightCheckInScalarWhereWithAggregatesInput = {
    AND?: NightCheckInScalarWhereWithAggregatesInput | NightCheckInScalarWhereWithAggregatesInput[]
    OR?: NightCheckInScalarWhereWithAggregatesInput[]
    NOT?: NightCheckInScalarWhereWithAggregatesInput | NightCheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NightCheckIn"> | string
    userId?: StringWithAggregatesFilter<"NightCheckIn"> | string
    date?: StringWithAggregatesFilter<"NightCheckIn"> | string
    mood?: StringNullableWithAggregatesFilter<"NightCheckIn"> | string | null
    dayNotes?: StringNullableWithAggregatesFilter<"NightCheckIn"> | string | null
    intention?: StringNullableWithAggregatesFilter<"NightCheckIn"> | string | null
    plannedWakeTime?: StringNullableWithAggregatesFilter<"NightCheckIn"> | string | null
    reminderEnabled?: BoolWithAggregatesFilter<"NightCheckIn"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NightCheckIn"> | Date | string
  }

  export type SyncQueueItemWhereInput = {
    AND?: SyncQueueItemWhereInput | SyncQueueItemWhereInput[]
    OR?: SyncQueueItemWhereInput[]
    NOT?: SyncQueueItemWhereInput | SyncQueueItemWhereInput[]
    id?: StringFilter<"SyncQueueItem"> | string
    userId?: StringFilter<"SyncQueueItem"> | string
    operation?: StringFilter<"SyncQueueItem"> | string
    resource?: StringFilter<"SyncQueueItem"> | string
    payload?: JsonFilter<"SyncQueueItem">
    status?: StringFilter<"SyncQueueItem"> | string
    attempts?: IntFilter<"SyncQueueItem"> | number
    lastError?: StringNullableFilter<"SyncQueueItem"> | string | null
    createdAt?: DateTimeFilter<"SyncQueueItem"> | Date | string
    processedAt?: DateTimeNullableFilter<"SyncQueueItem"> | Date | string | null
  }

  export type SyncQueueItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    operation?: SortOrder
    resource?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
  }

  export type SyncQueueItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncQueueItemWhereInput | SyncQueueItemWhereInput[]
    OR?: SyncQueueItemWhereInput[]
    NOT?: SyncQueueItemWhereInput | SyncQueueItemWhereInput[]
    userId?: StringFilter<"SyncQueueItem"> | string
    operation?: StringFilter<"SyncQueueItem"> | string
    resource?: StringFilter<"SyncQueueItem"> | string
    payload?: JsonFilter<"SyncQueueItem">
    status?: StringFilter<"SyncQueueItem"> | string
    attempts?: IntFilter<"SyncQueueItem"> | number
    lastError?: StringNullableFilter<"SyncQueueItem"> | string | null
    createdAt?: DateTimeFilter<"SyncQueueItem"> | Date | string
    processedAt?: DateTimeNullableFilter<"SyncQueueItem"> | Date | string | null
  }, "id">

  export type SyncQueueItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    operation?: SortOrder
    resource?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: SyncQueueItemCountOrderByAggregateInput
    _avg?: SyncQueueItemAvgOrderByAggregateInput
    _max?: SyncQueueItemMaxOrderByAggregateInput
    _min?: SyncQueueItemMinOrderByAggregateInput
    _sum?: SyncQueueItemSumOrderByAggregateInput
  }

  export type SyncQueueItemScalarWhereWithAggregatesInput = {
    AND?: SyncQueueItemScalarWhereWithAggregatesInput | SyncQueueItemScalarWhereWithAggregatesInput[]
    OR?: SyncQueueItemScalarWhereWithAggregatesInput[]
    NOT?: SyncQueueItemScalarWhereWithAggregatesInput | SyncQueueItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncQueueItem"> | string
    userId?: StringWithAggregatesFilter<"SyncQueueItem"> | string
    operation?: StringWithAggregatesFilter<"SyncQueueItem"> | string
    resource?: StringWithAggregatesFilter<"SyncQueueItem"> | string
    payload?: JsonWithAggregatesFilter<"SyncQueueItem">
    status?: StringWithAggregatesFilter<"SyncQueueItem"> | string
    attempts?: IntWithAggregatesFilter<"SyncQueueItem"> | number
    lastError?: StringNullableWithAggregatesFilter<"SyncQueueItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncQueueItem"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"SyncQueueItem"> | Date | string | null
  }

  export type AlarmSettingsWhereInput = {
    AND?: AlarmSettingsWhereInput | AlarmSettingsWhereInput[]
    OR?: AlarmSettingsWhereInput[]
    NOT?: AlarmSettingsWhereInput | AlarmSettingsWhereInput[]
    id?: StringFilter<"AlarmSettings"> | string
    userId?: StringFilter<"AlarmSettings"> | string
    isArmed?: BoolFilter<"AlarmSettings"> | boolean
    schedule?: JsonFilter<"AlarmSettings">
    soundId?: StringFilter<"AlarmSettings"> | string
    volume?: IntFilter<"AlarmSettings"> | number
    snoozeMinutes?: IntFilter<"AlarmSettings"> | number
    maxSnoozes?: IntFilter<"AlarmSettings"> | number
    lastSetTime?: StringNullableFilter<"AlarmSettings"> | string | null
    createdAt?: DateTimeFilter<"AlarmSettings"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AlarmSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    isArmed?: SortOrder
    schedule?: SortOrder
    soundId?: SortOrder
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
    lastSetTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AlarmSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AlarmSettingsWhereInput | AlarmSettingsWhereInput[]
    OR?: AlarmSettingsWhereInput[]
    NOT?: AlarmSettingsWhereInput | AlarmSettingsWhereInput[]
    isArmed?: BoolFilter<"AlarmSettings"> | boolean
    schedule?: JsonFilter<"AlarmSettings">
    soundId?: StringFilter<"AlarmSettings"> | string
    volume?: IntFilter<"AlarmSettings"> | number
    snoozeMinutes?: IntFilter<"AlarmSettings"> | number
    maxSnoozes?: IntFilter<"AlarmSettings"> | number
    lastSetTime?: StringNullableFilter<"AlarmSettings"> | string | null
    createdAt?: DateTimeFilter<"AlarmSettings"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AlarmSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    isArmed?: SortOrder
    schedule?: SortOrder
    soundId?: SortOrder
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
    lastSetTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlarmSettingsCountOrderByAggregateInput
    _avg?: AlarmSettingsAvgOrderByAggregateInput
    _max?: AlarmSettingsMaxOrderByAggregateInput
    _min?: AlarmSettingsMinOrderByAggregateInput
    _sum?: AlarmSettingsSumOrderByAggregateInput
  }

  export type AlarmSettingsScalarWhereWithAggregatesInput = {
    AND?: AlarmSettingsScalarWhereWithAggregatesInput | AlarmSettingsScalarWhereWithAggregatesInput[]
    OR?: AlarmSettingsScalarWhereWithAggregatesInput[]
    NOT?: AlarmSettingsScalarWhereWithAggregatesInput | AlarmSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlarmSettings"> | string
    userId?: StringWithAggregatesFilter<"AlarmSettings"> | string
    isArmed?: BoolWithAggregatesFilter<"AlarmSettings"> | boolean
    schedule?: JsonWithAggregatesFilter<"AlarmSettings">
    soundId?: StringWithAggregatesFilter<"AlarmSettings"> | string
    volume?: IntWithAggregatesFilter<"AlarmSettings"> | number
    snoozeMinutes?: IntWithAggregatesFilter<"AlarmSettings"> | number
    maxSnoozes?: IntWithAggregatesFilter<"AlarmSettings"> | number
    lastSetTime?: StringNullableWithAggregatesFilter<"AlarmSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AlarmSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlarmSettings"> | Date | string
  }

  export type DreamerProfileWhereInput = {
    AND?: DreamerProfileWhereInput | DreamerProfileWhereInput[]
    OR?: DreamerProfileWhereInput[]
    NOT?: DreamerProfileWhereInput | DreamerProfileWhereInput[]
    id?: StringFilter<"DreamerProfile"> | string
    userId?: StringFilter<"DreamerProfile"> | string
    boundaryScore?: IntNullableFilter<"DreamerProfile"> | number | null
    lucidityScore?: IntNullableFilter<"DreamerProfile"> | number | null
    emotionScore?: IntNullableFilter<"DreamerProfile"> | number | null
    meaningScore?: IntNullableFilter<"DreamerProfile"> | number | null
    engagementScore?: IntNullableFilter<"DreamerProfile"> | number | null
    boundaryConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    lucidityConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    emotionConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    meaningConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    engagementConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    primaryArchetype?: StringNullableFilter<"DreamerProfile"> | string | null
    secondaryArchetype?: StringNullableFilter<"DreamerProfile"> | string | null
    archetypeConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    unlockPoints?: IntFilter<"DreamerProfile"> | number
    unlockLevel?: IntFilter<"DreamerProfile"> | number
    journalDreamCount?: IntFilter<"DreamerProfile"> | number
    journalLucidPercent?: IntNullableFilter<"DreamerProfile"> | number | null
    journalAvgVividness?: IntNullableFilter<"DreamerProfile"> | number | null
    journalTopEmotions?: StringNullableListFilter<"DreamerProfile">
    journalTopTags?: StringNullableListFilter<"DreamerProfile">
    journalWakingLinkRate?: IntNullableFilter<"DreamerProfile"> | number | null
    scoringVersion?: IntFilter<"DreamerProfile"> | number
    isStale?: BoolFilter<"DreamerProfile"> | boolean
    lastCalculatedAt?: DateTimeNullableFilter<"DreamerProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"DreamerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"DreamerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DreamerProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    boundaryScore?: SortOrderInput | SortOrder
    lucidityScore?: SortOrderInput | SortOrder
    emotionScore?: SortOrderInput | SortOrder
    meaningScore?: SortOrderInput | SortOrder
    engagementScore?: SortOrderInput | SortOrder
    boundaryConfidence?: SortOrderInput | SortOrder
    lucidityConfidence?: SortOrderInput | SortOrder
    emotionConfidence?: SortOrderInput | SortOrder
    meaningConfidence?: SortOrderInput | SortOrder
    engagementConfidence?: SortOrderInput | SortOrder
    primaryArchetype?: SortOrderInput | SortOrder
    secondaryArchetype?: SortOrderInput | SortOrder
    archetypeConfidence?: SortOrderInput | SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrderInput | SortOrder
    journalAvgVividness?: SortOrderInput | SortOrder
    journalTopEmotions?: SortOrder
    journalTopTags?: SortOrder
    journalWakingLinkRate?: SortOrderInput | SortOrder
    scoringVersion?: SortOrder
    isStale?: SortOrder
    lastCalculatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DreamerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DreamerProfileWhereInput | DreamerProfileWhereInput[]
    OR?: DreamerProfileWhereInput[]
    NOT?: DreamerProfileWhereInput | DreamerProfileWhereInput[]
    boundaryScore?: IntNullableFilter<"DreamerProfile"> | number | null
    lucidityScore?: IntNullableFilter<"DreamerProfile"> | number | null
    emotionScore?: IntNullableFilter<"DreamerProfile"> | number | null
    meaningScore?: IntNullableFilter<"DreamerProfile"> | number | null
    engagementScore?: IntNullableFilter<"DreamerProfile"> | number | null
    boundaryConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    lucidityConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    emotionConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    meaningConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    engagementConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    primaryArchetype?: StringNullableFilter<"DreamerProfile"> | string | null
    secondaryArchetype?: StringNullableFilter<"DreamerProfile"> | string | null
    archetypeConfidence?: IntNullableFilter<"DreamerProfile"> | number | null
    unlockPoints?: IntFilter<"DreamerProfile"> | number
    unlockLevel?: IntFilter<"DreamerProfile"> | number
    journalDreamCount?: IntFilter<"DreamerProfile"> | number
    journalLucidPercent?: IntNullableFilter<"DreamerProfile"> | number | null
    journalAvgVividness?: IntNullableFilter<"DreamerProfile"> | number | null
    journalTopEmotions?: StringNullableListFilter<"DreamerProfile">
    journalTopTags?: StringNullableListFilter<"DreamerProfile">
    journalWakingLinkRate?: IntNullableFilter<"DreamerProfile"> | number | null
    scoringVersion?: IntFilter<"DreamerProfile"> | number
    isStale?: BoolFilter<"DreamerProfile"> | boolean
    lastCalculatedAt?: DateTimeNullableFilter<"DreamerProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"DreamerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"DreamerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DreamerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    boundaryScore?: SortOrderInput | SortOrder
    lucidityScore?: SortOrderInput | SortOrder
    emotionScore?: SortOrderInput | SortOrder
    meaningScore?: SortOrderInput | SortOrder
    engagementScore?: SortOrderInput | SortOrder
    boundaryConfidence?: SortOrderInput | SortOrder
    lucidityConfidence?: SortOrderInput | SortOrder
    emotionConfidence?: SortOrderInput | SortOrder
    meaningConfidence?: SortOrderInput | SortOrder
    engagementConfidence?: SortOrderInput | SortOrder
    primaryArchetype?: SortOrderInput | SortOrder
    secondaryArchetype?: SortOrderInput | SortOrder
    archetypeConfidence?: SortOrderInput | SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrderInput | SortOrder
    journalAvgVividness?: SortOrderInput | SortOrder
    journalTopEmotions?: SortOrder
    journalTopTags?: SortOrder
    journalWakingLinkRate?: SortOrderInput | SortOrder
    scoringVersion?: SortOrder
    isStale?: SortOrder
    lastCalculatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DreamerProfileCountOrderByAggregateInput
    _avg?: DreamerProfileAvgOrderByAggregateInput
    _max?: DreamerProfileMaxOrderByAggregateInput
    _min?: DreamerProfileMinOrderByAggregateInput
    _sum?: DreamerProfileSumOrderByAggregateInput
  }

  export type DreamerProfileScalarWhereWithAggregatesInput = {
    AND?: DreamerProfileScalarWhereWithAggregatesInput | DreamerProfileScalarWhereWithAggregatesInput[]
    OR?: DreamerProfileScalarWhereWithAggregatesInput[]
    NOT?: DreamerProfileScalarWhereWithAggregatesInput | DreamerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DreamerProfile"> | string
    userId?: StringWithAggregatesFilter<"DreamerProfile"> | string
    boundaryScore?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    lucidityScore?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    emotionScore?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    meaningScore?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    engagementScore?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    boundaryConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    lucidityConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    emotionConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    meaningConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    engagementConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    primaryArchetype?: StringNullableWithAggregatesFilter<"DreamerProfile"> | string | null
    secondaryArchetype?: StringNullableWithAggregatesFilter<"DreamerProfile"> | string | null
    archetypeConfidence?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    unlockPoints?: IntWithAggregatesFilter<"DreamerProfile"> | number
    unlockLevel?: IntWithAggregatesFilter<"DreamerProfile"> | number
    journalDreamCount?: IntWithAggregatesFilter<"DreamerProfile"> | number
    journalLucidPercent?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    journalAvgVividness?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    journalTopEmotions?: StringNullableListFilter<"DreamerProfile">
    journalTopTags?: StringNullableListFilter<"DreamerProfile">
    journalWakingLinkRate?: IntNullableWithAggregatesFilter<"DreamerProfile"> | number | null
    scoringVersion?: IntWithAggregatesFilter<"DreamerProfile"> | number
    isStale?: BoolWithAggregatesFilter<"DreamerProfile"> | boolean
    lastCalculatedAt?: DateTimeNullableWithAggregatesFilter<"DreamerProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DreamerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DreamerProfile"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type SessionCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
    user: UserCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventCreateManyInput = {
    id?: string
    userId: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DreamEntryCreateInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDreamEntriesInput
    tags?: DreamTagCreateNestedManyWithoutDreamEntryInput
    facts?: JournalFactCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryUncheckedCreateInput = {
    id?: string
    userId: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    tags?: DreamTagUncheckedCreateNestedManyWithoutDreamEntryInput
    facts?: JournalFactUncheckedCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDreamEntriesNestedInput
    tags?: DreamTagUpdateManyWithoutDreamEntryNestedInput
    facts?: JournalFactUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DreamTagUncheckedUpdateManyWithoutDreamEntryNestedInput
    facts?: JournalFactUncheckedUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryCreateManyInput = {
    id?: string
    userId: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
  }

  export type DreamEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactCreateInput = {
    id?: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
    dreamEntry: DreamEntryCreateNestedOneWithoutFactsInput
  }

  export type JournalFactUncheckedCreateInput = {
    id?: string
    dreamEntryId: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
  }

  export type JournalFactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dreamEntry?: DreamEntryUpdateOneRequiredWithoutFactsNestedInput
  }

  export type JournalFactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactCreateManyInput = {
    id?: string
    dreamEntryId: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
  }

  export type JournalFactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    taxonomyId?: string | null
    taxonomyVersion?: number | null
    usageCount?: number
    dreamTags?: DreamTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    taxonomyId?: string | null
    taxonomyVersion?: number | null
    usageCount?: number
    dreamTags?: DreamTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    dreamTags?: DreamTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    dreamTags?: DreamTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    category: string
    taxonomyId?: string | null
    taxonomyVersion?: number | null
    usageCount?: number
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type DreamTagCreateInput = {
    id?: string
    source?: string
    createdAt?: Date | string
    dreamEntry: DreamEntryCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutDreamTagsInput
  }

  export type DreamTagUncheckedCreateInput = {
    id?: string
    dreamEntryId: string
    tagId: string
    source?: string
    createdAt?: Date | string
  }

  export type DreamTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dreamEntry?: DreamEntryUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutDreamTagsNestedInput
  }

  export type DreamTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamTagCreateManyInput = {
    id?: string
    dreamEntryId: string
    tagId: string
    source?: string
    createdAt?: Date | string
  }

  export type DreamTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusInstrumentCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: CensusSectionCreateNestedManyWithoutInstrumentInput
  }

  export type CensusInstrumentUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: CensusSectionUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type CensusInstrumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: CensusSectionUpdateManyWithoutInstrumentNestedInput
  }

  export type CensusInstrumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: CensusSectionUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type CensusInstrumentCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusInstrumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusInstrumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusSectionCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
    questions?: CensusQuestionCreateNestedManyWithoutSectionInput
    instrument: CensusInstrumentCreateNestedOneWithoutSectionsInput
  }

  export type CensusSectionUncheckedCreateInput = {
    id?: string
    instrumentId: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
    questions?: CensusQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type CensusSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    questions?: CensusQuestionUpdateManyWithoutSectionNestedInput
    instrument?: CensusInstrumentUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type CensusSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    questions?: CensusQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type CensusSectionCreateManyInput = {
    id?: string
    instrumentId: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
  }

  export type CensusSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type CensusSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type CensusQuestionCreateInput = {
    id?: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerCreateNestedManyWithoutQuestionInput
    section: CensusSectionCreateNestedOneWithoutQuestionsInput
  }

  export type CensusQuestionUncheckedCreateInput = {
    id?: string
    sectionId: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type CensusQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUpdateManyWithoutQuestionNestedInput
    section?: CensusSectionUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type CensusQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type CensusQuestionCreateManyInput = {
    id?: string
    sectionId: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusAnswerCreateInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    question: CensusQuestionCreateNestedOneWithoutAnswersInput
    user: UserCreateNestedOneWithoutCensusAnswersInput
  }

  export type CensusAnswerUncheckedCreateInput = {
    id?: string
    userId: string
    questionId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: CensusQuestionUpdateOneRequiredWithoutAnswersNestedInput
    user?: UserUpdateOneRequiredWithoutCensusAnswersNestedInput
  }

  export type CensusAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerCreateManyInput = {
    id?: string
    userId: string
    questionId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusProgressCreateInput = {
    id?: string
    userId: string
    sectionProgress: JsonNullValueInput | InputJsonValue
    totalCompleted?: number
    totalQuestions?: number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CensusProgressUncheckedCreateInput = {
    id?: string
    userId: string
    sectionProgress: JsonNullValueInput | InputJsonValue
    totalCompleted?: number
    totalQuestions?: number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CensusProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionProgress?: JsonNullValueInput | InputJsonValue
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CensusProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionProgress?: JsonNullValueInput | InputJsonValue
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CensusProgressCreateManyInput = {
    id?: string
    userId: string
    sectionProgress: JsonNullValueInput | InputJsonValue
    totalCompleted?: number
    totalQuestions?: number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CensusProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionProgress?: JsonNullValueInput | InputJsonValue
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CensusProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionProgress?: JsonNullValueInput | InputJsonValue
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    scores?: NullableJsonNullValueInput | InputJsonValue
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PromptCreateInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    study?: StudyCreateNestedOneWithoutPromptsInput
    responses?: PromptResponseCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PromptResponseUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneWithoutPromptsNestedInput
    responses?: PromptResponseUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PromptResponseUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptCreateManyInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptResponseCreateInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
    prompt: PromptCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutPromptResponsesInput
  }

  export type PromptResponseUncheckedCreateInput = {
    id?: string
    userId: string
    promptId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type PromptResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
    prompt?: PromptUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutPromptResponsesNestedInput
  }

  export type PromptResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptResponseCreateManyInput = {
    id?: string
    userId: string
    promptId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type PromptResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsentCreateInput = {
    id?: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
    user: UserCreateNestedOneWithoutConsentsInput
  }

  export type ConsentUncheckedCreateInput = {
    id?: string
    userId: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
  }

  export type ConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type ConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsentCreateManyInput = {
    id?: string
    userId: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
  }

  export type ConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeatherAggregateCreateInput = {
    id?: string
    metric: string
    period: string
    periodStart: Date | string
    value: JsonNullValueInput | InputJsonValue
    sampleN: number
    dpEpsilon?: number | null
    dpDelta?: number | null
    minNThreshold?: number
    region?: string | null
    methodVersion: number
    computedAt?: Date | string
  }

  export type WeatherAggregateUncheckedCreateInput = {
    id?: string
    metric: string
    period: string
    periodStart: Date | string
    value: JsonNullValueInput | InputJsonValue
    sampleN: number
    dpEpsilon?: number | null
    dpDelta?: number | null
    minNThreshold?: number
    region?: string | null
    methodVersion: number
    computedAt?: Date | string
  }

  export type WeatherAggregateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    sampleN?: IntFieldUpdateOperationsInput | number
    dpEpsilon?: NullableFloatFieldUpdateOperationsInput | number | null
    dpDelta?: NullableFloatFieldUpdateOperationsInput | number | null
    minNThreshold?: IntFieldUpdateOperationsInput | number
    region?: NullableStringFieldUpdateOperationsInput | string | null
    methodVersion?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAggregateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    sampleN?: IntFieldUpdateOperationsInput | number
    dpEpsilon?: NullableFloatFieldUpdateOperationsInput | number | null
    dpDelta?: NullableFloatFieldUpdateOperationsInput | number | null
    minNThreshold?: IntFieldUpdateOperationsInput | number
    region?: NullableStringFieldUpdateOperationsInput | string | null
    methodVersion?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAggregateCreateManyInput = {
    id?: string
    metric: string
    period: string
    periodStart: Date | string
    value: JsonNullValueInput | InputJsonValue
    sampleN: number
    dpEpsilon?: number | null
    dpDelta?: number | null
    minNThreshold?: number
    region?: string | null
    methodVersion: number
    computedAt?: Date | string
  }

  export type WeatherAggregateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    sampleN?: IntFieldUpdateOperationsInput | number
    dpEpsilon?: NullableFloatFieldUpdateOperationsInput | number | null
    dpDelta?: NullableFloatFieldUpdateOperationsInput | number | null
    minNThreshold?: IntFieldUpdateOperationsInput | number
    region?: NullableStringFieldUpdateOperationsInput | string | null
    methodVersion?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherAggregateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: JsonNullValueInput | InputJsonValue
    sampleN?: IntFieldUpdateOperationsInput | number
    dpEpsilon?: NullableFloatFieldUpdateOperationsInput | number | null
    dpDelta?: NullableFloatFieldUpdateOperationsInput | number | null
    minNThreshold?: IntFieldUpdateOperationsInput | number
    region?: NullableStringFieldUpdateOperationsInput | string | null
    methodVersion?: IntFieldUpdateOperationsInput | number
    computedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalWeatherCreateInput = {
    id?: string
    userId: string
    weather: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: Date | string
  }

  export type PersonalWeatherUncheckedCreateInput = {
    id?: string
    userId: string
    weather: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: Date | string
  }

  export type PersonalWeatherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weather?: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalWeatherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weather?: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalWeatherCreateManyInput = {
    id?: string
    userId: string
    weather: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: Date | string
  }

  export type PersonalWeatherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weather?: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalWeatherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weather?: JsonNullValueInput | InputJsonValue
    streaks?: NullableJsonNullValueInput | InputJsonValue
    lastComputedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompts?: PromptCreateNestedManyWithoutStudyInput
    participations?: StudyParticipationCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompts?: PromptUncheckedCreateNestedManyWithoutStudyInput
    participations?: StudyParticipationUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: PromptUpdateManyWithoutStudyNestedInput
    participations?: StudyParticipationUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: PromptUncheckedUpdateManyWithoutStudyNestedInput
    participations?: StudyParticipationUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type StudyCreateManyInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyParticipationCreateInput = {
    id?: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
    study: StudyCreateNestedOneWithoutParticipationsInput
    user: UserCreateNestedOneWithoutStudyParticipationsInput
  }

  export type StudyParticipationUncheckedCreateInput = {
    id?: string
    userId: string
    studyId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type StudyParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study?: StudyUpdateOneRequiredWithoutParticipationsNestedInput
    user?: UserUpdateOneRequiredWithoutStudyParticipationsNestedInput
  }

  export type StudyParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudyParticipationCreateManyInput = {
    id?: string
    userId: string
    studyId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type StudyParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudyParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmotionCreateInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    parent?: EmotionCreateNestedOneWithoutChildrenInput
    children?: EmotionCreateNestedManyWithoutParentInput
  }

  export type EmotionUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    parentId?: string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    children?: EmotionUncheckedCreateNestedManyWithoutParentInput
  }

  export type EmotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    parent?: EmotionUpdateOneWithoutChildrenNestedInput
    children?: EmotionUpdateManyWithoutParentNestedInput
  }

  export type EmotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    children?: EmotionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EmotionCreateManyInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    parentId?: string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type EmotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type EmotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SymbolCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    description?: string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type SymbolUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    category: string
    description?: string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type SymbolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SymbolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SymbolCreateManyInput = {
    id?: string
    name: string
    slug: string
    category: string
    description?: string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type SymbolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SymbolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    interpretations?: NullableJsonNullValueInput | InputJsonValue
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    relatedSlugs?: ThemeCreaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type ThemeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    relatedSlugs?: ThemeCreaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type ThemeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSlugs?: ThemeUpdaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSlugs?: ThemeUpdaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    relatedSlugs?: ThemeCreaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type ThemeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSlugs?: ThemeUpdaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ThemeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedSlugs?: ThemeUpdaterelatedSlugsInput | string[]
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type NightCheckInCreateInput = {
    id?: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNightCheckInsInput
  }

  export type NightCheckInUncheckedCreateInput = {
    id?: string
    userId: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
  }

  export type NightCheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNightCheckInsNestedInput
  }

  export type NightCheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NightCheckInCreateManyInput = {
    id?: string
    userId: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
  }

  export type NightCheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NightCheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncQueueItemCreateInput = {
    id?: string
    userId: string
    operation: string
    resource: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    lastError?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SyncQueueItemUncheckedCreateInput = {
    id?: string
    userId: string
    operation: string
    resource: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    lastError?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SyncQueueItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncQueueItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncQueueItemCreateManyInput = {
    id?: string
    userId: string
    operation: string
    resource: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    attempts?: number
    lastError?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SyncQueueItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncQueueItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlarmSettingsCreateInput = {
    id?: string
    isArmed?: boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: string
    volume?: number
    snoozeMinutes?: number
    maxSnoozes?: number
    lastSetTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAlarmSettingsInput
  }

  export type AlarmSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    isArmed?: boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: string
    volume?: number
    snoozeMinutes?: number
    maxSnoozes?: number
    lastSetTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlarmSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAlarmSettingsNestedInput
  }

  export type AlarmSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmSettingsCreateManyInput = {
    id?: string
    userId: string
    isArmed?: boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: string
    volume?: number
    snoozeMinutes?: number
    maxSnoozes?: number
    lastSetTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlarmSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamerProfileCreateInput = {
    id?: string
    boundaryScore?: number | null
    lucidityScore?: number | null
    emotionScore?: number | null
    meaningScore?: number | null
    engagementScore?: number | null
    boundaryConfidence?: number | null
    lucidityConfidence?: number | null
    emotionConfidence?: number | null
    meaningConfidence?: number | null
    engagementConfidence?: number | null
    primaryArchetype?: string | null
    secondaryArchetype?: string | null
    archetypeConfidence?: number | null
    unlockPoints?: number
    unlockLevel?: number
    journalDreamCount?: number
    journalLucidPercent?: number | null
    journalAvgVividness?: number | null
    journalTopEmotions?: DreamerProfileCreatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileCreatejournalTopTagsInput | string[]
    journalWakingLinkRate?: number | null
    scoringVersion?: number
    isStale?: boolean
    lastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDreamerProfileInput
  }

  export type DreamerProfileUncheckedCreateInput = {
    id?: string
    userId: string
    boundaryScore?: number | null
    lucidityScore?: number | null
    emotionScore?: number | null
    meaningScore?: number | null
    engagementScore?: number | null
    boundaryConfidence?: number | null
    lucidityConfidence?: number | null
    emotionConfidence?: number | null
    meaningConfidence?: number | null
    engagementConfidence?: number | null
    primaryArchetype?: string | null
    secondaryArchetype?: string | null
    archetypeConfidence?: number | null
    unlockPoints?: number
    unlockLevel?: number
    journalDreamCount?: number
    journalLucidPercent?: number | null
    journalAvgVividness?: number | null
    journalTopEmotions?: DreamerProfileCreatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileCreatejournalTopTagsInput | string[]
    journalWakingLinkRate?: number | null
    scoringVersion?: number
    isStale?: boolean
    lastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DreamerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDreamerProfileNestedInput
  }

  export type DreamerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamerProfileCreateManyInput = {
    id?: string
    userId: string
    boundaryScore?: number | null
    lucidityScore?: number | null
    emotionScore?: number | null
    meaningScore?: number | null
    engagementScore?: number | null
    boundaryConfidence?: number | null
    lucidityConfidence?: number | null
    emotionConfidence?: number | null
    meaningConfidence?: number | null
    engagementConfidence?: number | null
    primaryArchetype?: string | null
    secondaryArchetype?: string | null
    archetypeConfidence?: number | null
    unlockPoints?: number
    unlockLevel?: number
    journalDreamCount?: number
    journalLucidPercent?: number | null
    journalAvgVividness?: number | null
    journalTopEmotions?: DreamerProfileCreatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileCreatejournalTopTagsInput | string[]
    journalWakingLinkRate?: number | null
    scoringVersion?: number
    isStale?: boolean
    lastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DreamerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type AlarmSettingsNullableScalarRelationFilter = {
    is?: AlarmSettingsWhereInput | null
    isNot?: AlarmSettingsWhereInput | null
  }

  export type CensusAnswerListRelationFilter = {
    every?: CensusAnswerWhereInput
    some?: CensusAnswerWhereInput
    none?: CensusAnswerWhereInput
  }

  export type ConsentListRelationFilter = {
    every?: ConsentWhereInput
    some?: ConsentWhereInput
    none?: ConsentWhereInput
  }

  export type DreamEntryListRelationFilter = {
    every?: DreamEntryWhereInput
    some?: DreamEntryWhereInput
    none?: DreamEntryWhereInput
  }

  export type DreamerProfileNullableScalarRelationFilter = {
    is?: DreamerProfileWhereInput | null
    isNot?: DreamerProfileWhereInput | null
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type NightCheckInListRelationFilter = {
    every?: NightCheckInWhereInput
    some?: NightCheckInWhereInput
    none?: NightCheckInWhereInput
  }

  export type PromptResponseListRelationFilter = {
    every?: PromptResponseWhereInput
    some?: PromptResponseWhereInput
    none?: PromptResponseWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type StudyParticipationListRelationFilter = {
    every?: StudyParticipationWhereInput
    some?: StudyParticipationWhereInput
    none?: StudyParticipationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CensusAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DreamEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NightCheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    avatarEmoji?: SortOrder
    avatarBgColor?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    encryptionKeyVersion?: SortOrder
    keyRecoveryMethod?: SortOrder
    keySalt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    encryptionKeyVersion?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    avatarEmoji?: SortOrder
    avatarBgColor?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    encryptionKeyVersion?: SortOrder
    keyRecoveryMethod?: SortOrder
    keySalt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    avatarEmoji?: SortOrder
    avatarBgColor?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    encryptionKeyVersion?: SortOrder
    keyRecoveryMethod?: SortOrder
    keySalt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    encryptionKeyVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    timestamp?: SortOrder
    sequence?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sequence?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sequence?: SortOrder
    aggregateId?: SortOrder
    aggregateType?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    sequence?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DreamTagListRelationFilter = {
    every?: DreamTagWhereInput
    some?: DreamTagWhereInput
    none?: DreamTagWhereInput
  }

  export type JournalFactListRelationFilter = {
    every?: JournalFactWhereInput
    some?: JournalFactWhereInput
    none?: JournalFactWhereInput
  }

  export type DreamTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalFactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DreamEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ciphertext?: SortOrder
    iv?: SortOrder
    keyVersion?: SortOrder
    audioUrl?: SortOrder
    title?: SortOrder
    emotions?: SortOrder
    vividness?: SortOrder
    lucidity?: SortOrder
    dreamTypes?: SortOrder
    sleepQuality?: SortOrder
    hoursSlept?: SortOrder
    wakeTime?: SortOrder
    wakingLifeLink?: SortOrder
    capturedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamEntryAvgOrderByAggregateInput = {
    keyVersion?: SortOrder
    vividness?: SortOrder
    sleepQuality?: SortOrder
    hoursSlept?: SortOrder
  }

  export type DreamEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ciphertext?: SortOrder
    iv?: SortOrder
    keyVersion?: SortOrder
    audioUrl?: SortOrder
    title?: SortOrder
    vividness?: SortOrder
    lucidity?: SortOrder
    sleepQuality?: SortOrder
    hoursSlept?: SortOrder
    wakeTime?: SortOrder
    wakingLifeLink?: SortOrder
    capturedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ciphertext?: SortOrder
    iv?: SortOrder
    keyVersion?: SortOrder
    audioUrl?: SortOrder
    title?: SortOrder
    vividness?: SortOrder
    lucidity?: SortOrder
    sleepQuality?: SortOrder
    hoursSlept?: SortOrder
    wakeTime?: SortOrder
    wakingLifeLink?: SortOrder
    capturedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamEntrySumOrderByAggregateInput = {
    keyVersion?: SortOrder
    vividness?: SortOrder
    sleepQuality?: SortOrder
    hoursSlept?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DreamEntryScalarRelationFilter = {
    is?: DreamEntryWhereInput
    isNot?: DreamEntryWhereInput
  }

  export type JournalFactCountOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    factType?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    modelVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrder
    endIndex?: SortOrder
    extractedAt?: SortOrder
  }

  export type JournalFactAvgOrderByAggregateInput = {
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrder
    endIndex?: SortOrder
  }

  export type JournalFactMaxOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    factType?: SortOrder
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    modelVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrder
    endIndex?: SortOrder
    extractedAt?: SortOrder
  }

  export type JournalFactMinOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    factType?: SortOrder
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    modelVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrder
    endIndex?: SortOrder
    extractedAt?: SortOrder
  }

  export type JournalFactSumOrderByAggregateInput = {
    confidence?: SortOrder
    ontologyVersion?: SortOrder
    promptVersion?: SortOrder
    startIndex?: SortOrder
    endIndex?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    taxonomyId?: SortOrder
    taxonomyVersion?: SortOrder
    usageCount?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    taxonomyVersion?: SortOrder
    usageCount?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    taxonomyId?: SortOrder
    taxonomyVersion?: SortOrder
    usageCount?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    taxonomyId?: SortOrder
    taxonomyVersion?: SortOrder
    usageCount?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    taxonomyVersion?: SortOrder
    usageCount?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type DreamTagDreamEntryIdTagIdCompoundUniqueInput = {
    dreamEntryId: string
    tagId: string
  }

  export type DreamTagCountOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    tagId?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type DreamTagMaxOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    tagId?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type DreamTagMinOrderByAggregateInput = {
    id?: SortOrder
    dreamEntryId?: SortOrder
    tagId?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CensusSectionListRelationFilter = {
    every?: CensusSectionWhereInput
    some?: CensusSectionWhereInput
    none?: CensusSectionWhereInput
  }

  export type CensusSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CensusInstrumentCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusInstrumentAvgOrderByAggregateInput = {
    version?: SortOrder
    sortOrder?: SortOrder
  }

  export type CensusInstrumentMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusInstrumentMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusInstrumentSumOrderByAggregateInput = {
    version?: SortOrder
    sortOrder?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CensusQuestionListRelationFilter = {
    every?: CensusQuestionWhereInput
    some?: CensusQuestionWhereInput
    none?: CensusQuestionWhereInput
  }

  export type CensusInstrumentScalarRelationFilter = {
    is?: CensusInstrumentWhereInput
    isNot?: CensusInstrumentWhereInput
  }

  export type CensusQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CensusSectionInstrumentIdSlugCompoundUniqueInput = {
    instrumentId: string
    slug: string
  }

  export type CensusSectionCountOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
  }

  export type CensusSectionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
  }

  export type CensusSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
  }

  export type CensusSectionMinOrderByAggregateInput = {
    id?: SortOrder
    instrumentId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
  }

  export type CensusSectionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    estimatedTime?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CensusSectionScalarRelationFilter = {
    is?: CensusSectionWhereInput
    isNot?: CensusSectionWhereInput
  }

  export type CensusQuestionSectionIdSlugCompoundUniqueInput = {
    sectionId: string
    slug: string
  }

  export type CensusQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    slug?: SortOrder
    text?: SortOrder
    helpText?: SortOrder
    type?: SortOrder
    props?: SortOrder
    isRequired?: SortOrder
    validation?: SortOrder
    sortOrder?: SortOrder
    irtParams?: SortOrder
    groupId?: SortOrder
    groupLabel?: SortOrder
    showWhen?: SortOrder
  }

  export type CensusQuestionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CensusQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    slug?: SortOrder
    text?: SortOrder
    helpText?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    groupId?: SortOrder
    groupLabel?: SortOrder
  }

  export type CensusQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    slug?: SortOrder
    text?: SortOrder
    helpText?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    sortOrder?: SortOrder
    groupId?: SortOrder
    groupLabel?: SortOrder
  }

  export type CensusQuestionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CensusQuestionScalarRelationFilter = {
    is?: CensusQuestionWhereInput
    isNot?: CensusQuestionWhereInput
  }

  export type CensusAnswerUserIdQuestionIdCompoundUniqueInput = {
    userId: string
    questionId: string
  }

  export type CensusAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    instrumentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusAnswerAvgOrderByAggregateInput = {
    instrumentVersion?: SortOrder
  }

  export type CensusAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    instrumentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    instrumentVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CensusAnswerSumOrderByAggregateInput = {
    instrumentVersion?: SortOrder
  }

  export type CensusProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sectionProgress?: SortOrder
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
    scores?: SortOrder
    lastActivityAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CensusProgressAvgOrderByAggregateInput = {
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
  }

  export type CensusProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
    lastActivityAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CensusProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
    lastActivityAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CensusProgressSumOrderByAggregateInput = {
    totalCompleted?: SortOrder
    totalQuestions?: SortOrder
  }

  export type StudyNullableScalarRelationFilter = {
    is?: StudyWhereInput | null
    isNot?: StudyWhereInput | null
  }

  export type PromptCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    responseProps?: SortOrder
    isActive?: SortOrder
    frequency?: SortOrder
    targetingRules?: SortOrder
    studyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    isActive?: SortOrder
    frequency?: SortOrder
    studyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    responseType?: SortOrder
    isActive?: SortOrder
    frequency?: SortOrder
    studyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptScalarRelationFilter = {
    is?: PromptWhereInput
    isNot?: PromptWhereInput
  }

  export type PromptResponseUserIdPromptIdShownAtCompoundUniqueInput = {
    userId: string
    promptId: string
    shownAt: Date | string
  }

  export type PromptResponseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    value?: SortOrder
    shownAt?: SortOrder
    respondedAt?: SortOrder
    skipped?: SortOrder
  }

  export type PromptResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    shownAt?: SortOrder
    respondedAt?: SortOrder
    skipped?: SortOrder
  }

  export type PromptResponseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    shownAt?: SortOrder
    respondedAt?: SortOrder
    skipped?: SortOrder
  }

  export type ConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    version?: SortOrder
    granted?: SortOrder
    timestamp?: SortOrder
    receiptHash?: SortOrder
    policyHash?: SortOrder
    jurisdiction?: SortOrder
    ipHash?: SortOrder
  }

  export type ConsentAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    version?: SortOrder
    granted?: SortOrder
    timestamp?: SortOrder
    receiptHash?: SortOrder
    policyHash?: SortOrder
    jurisdiction?: SortOrder
    ipHash?: SortOrder
  }

  export type ConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    version?: SortOrder
    granted?: SortOrder
    timestamp?: SortOrder
    receiptHash?: SortOrder
    policyHash?: SortOrder
    jurisdiction?: SortOrder
    ipHash?: SortOrder
  }

  export type ConsentSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type WeatherAggregateMetricPeriodPeriodStartRegionCompoundUniqueInput = {
    metric: string
    period: string
    periodStart: Date | string
    region: string
  }

  export type WeatherAggregateCountOrderByAggregateInput = {
    id?: SortOrder
    metric?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    value?: SortOrder
    sampleN?: SortOrder
    dpEpsilon?: SortOrder
    dpDelta?: SortOrder
    minNThreshold?: SortOrder
    region?: SortOrder
    methodVersion?: SortOrder
    computedAt?: SortOrder
  }

  export type WeatherAggregateAvgOrderByAggregateInput = {
    sampleN?: SortOrder
    dpEpsilon?: SortOrder
    dpDelta?: SortOrder
    minNThreshold?: SortOrder
    methodVersion?: SortOrder
  }

  export type WeatherAggregateMaxOrderByAggregateInput = {
    id?: SortOrder
    metric?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    sampleN?: SortOrder
    dpEpsilon?: SortOrder
    dpDelta?: SortOrder
    minNThreshold?: SortOrder
    region?: SortOrder
    methodVersion?: SortOrder
    computedAt?: SortOrder
  }

  export type WeatherAggregateMinOrderByAggregateInput = {
    id?: SortOrder
    metric?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    sampleN?: SortOrder
    dpEpsilon?: SortOrder
    dpDelta?: SortOrder
    minNThreshold?: SortOrder
    region?: SortOrder
    methodVersion?: SortOrder
    computedAt?: SortOrder
  }

  export type WeatherAggregateSumOrderByAggregateInput = {
    sampleN?: SortOrder
    dpEpsilon?: SortOrder
    dpDelta?: SortOrder
    minNThreshold?: SortOrder
    methodVersion?: SortOrder
  }

  export type PersonalWeatherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weather?: SortOrder
    streaks?: SortOrder
    lastComputedAt?: SortOrder
  }

  export type PersonalWeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lastComputedAt?: SortOrder
  }

  export type PersonalWeatherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lastComputedAt?: SortOrder
  }

  export type PromptListRelationFilter = {
    every?: PromptWhereInput
    some?: PromptWhereInput
    none?: PromptWhereInput
  }

  export type PromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    institution?: SortOrder
    dataScope?: SortOrder
    duration?: SortOrder
    consentText?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxParticipants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyAvgOrderByAggregateInput = {
    consentVersion?: SortOrder
    maxParticipants?: SortOrder
  }

  export type StudyMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    institution?: SortOrder
    duration?: SortOrder
    consentText?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxParticipants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    institution?: SortOrder
    duration?: SortOrder
    consentText?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    maxParticipants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudySumOrderByAggregateInput = {
    consentVersion?: SortOrder
    maxParticipants?: SortOrder
  }

  export type StudyScalarRelationFilter = {
    is?: StudyWhereInput
    isNot?: StudyWhereInput
  }

  export type StudyParticipationUserIdStudyIdCompoundUniqueInput = {
    userId: string
    studyId: string
  }

  export type StudyParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studyId?: SortOrder
    consentedAt?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    completedAt?: SortOrder
  }

  export type StudyParticipationAvgOrderByAggregateInput = {
    consentVersion?: SortOrder
  }

  export type StudyParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studyId?: SortOrder
    consentedAt?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    completedAt?: SortOrder
  }

  export type StudyParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studyId?: SortOrder
    consentedAt?: SortOrder
    consentVersion?: SortOrder
    status?: SortOrder
    withdrawnAt?: SortOrder
    withdrawalReason?: SortOrder
    completedAt?: SortOrder
  }

  export type StudyParticipationSumOrderByAggregateInput = {
    consentVersion?: SortOrder
  }

  export type EmotionNullableScalarRelationFilter = {
    is?: EmotionWhereInput | null
    isNot?: EmotionWhereInput | null
  }

  export type EmotionListRelationFilter = {
    every?: EmotionWhereInput
    some?: EmotionWhereInput
    none?: EmotionWhereInput
  }

  export type EmotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    parentId?: SortOrder
    translations?: SortOrder
    version?: SortOrder
  }

  export type EmotionAvgOrderByAggregateInput = {
    valence?: SortOrder
    arousal?: SortOrder
    version?: SortOrder
  }

  export type EmotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
  }

  export type EmotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
  }

  export type EmotionSumOrderByAggregateInput = {
    valence?: SortOrder
    arousal?: SortOrder
    version?: SortOrder
  }

  export type SymbolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    description?: SortOrder
    interpretations?: SortOrder
    translations?: SortOrder
    version?: SortOrder
  }

  export type SymbolAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SymbolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type SymbolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type SymbolSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ThemeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    relatedSlugs?: SortOrder
    translations?: SortOrder
    version?: SortOrder
  }

  export type ThemeAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ThemeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type ThemeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type ThemeSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type NightCheckInUserIdDateCompoundUniqueInput = {
    userId: string
    date: string
  }

  export type NightCheckInCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    dayNotes?: SortOrder
    intention?: SortOrder
    plannedWakeTime?: SortOrder
    reminderEnabled?: SortOrder
    createdAt?: SortOrder
  }

  export type NightCheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    dayNotes?: SortOrder
    intention?: SortOrder
    plannedWakeTime?: SortOrder
    reminderEnabled?: SortOrder
    createdAt?: SortOrder
  }

  export type NightCheckInMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    dayNotes?: SortOrder
    intention?: SortOrder
    plannedWakeTime?: SortOrder
    reminderEnabled?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncQueueItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operation?: SortOrder
    resource?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SyncQueueItemAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type SyncQueueItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operation?: SortOrder
    resource?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SyncQueueItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operation?: SortOrder
    resource?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SyncQueueItemSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type AlarmSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isArmed?: SortOrder
    schedule?: SortOrder
    soundId?: SortOrder
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
    lastSetTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlarmSettingsAvgOrderByAggregateInput = {
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
  }

  export type AlarmSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isArmed?: SortOrder
    soundId?: SortOrder
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
    lastSetTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlarmSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isArmed?: SortOrder
    soundId?: SortOrder
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
    lastSetTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlarmSettingsSumOrderByAggregateInput = {
    volume?: SortOrder
    snoozeMinutes?: SortOrder
    maxSnoozes?: SortOrder
  }

  export type DreamerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boundaryScore?: SortOrder
    lucidityScore?: SortOrder
    emotionScore?: SortOrder
    meaningScore?: SortOrder
    engagementScore?: SortOrder
    boundaryConfidence?: SortOrder
    lucidityConfidence?: SortOrder
    emotionConfidence?: SortOrder
    meaningConfidence?: SortOrder
    engagementConfidence?: SortOrder
    primaryArchetype?: SortOrder
    secondaryArchetype?: SortOrder
    archetypeConfidence?: SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrder
    journalAvgVividness?: SortOrder
    journalTopEmotions?: SortOrder
    journalTopTags?: SortOrder
    journalWakingLinkRate?: SortOrder
    scoringVersion?: SortOrder
    isStale?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamerProfileAvgOrderByAggregateInput = {
    boundaryScore?: SortOrder
    lucidityScore?: SortOrder
    emotionScore?: SortOrder
    meaningScore?: SortOrder
    engagementScore?: SortOrder
    boundaryConfidence?: SortOrder
    lucidityConfidence?: SortOrder
    emotionConfidence?: SortOrder
    meaningConfidence?: SortOrder
    engagementConfidence?: SortOrder
    archetypeConfidence?: SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrder
    journalAvgVividness?: SortOrder
    journalWakingLinkRate?: SortOrder
    scoringVersion?: SortOrder
  }

  export type DreamerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boundaryScore?: SortOrder
    lucidityScore?: SortOrder
    emotionScore?: SortOrder
    meaningScore?: SortOrder
    engagementScore?: SortOrder
    boundaryConfidence?: SortOrder
    lucidityConfidence?: SortOrder
    emotionConfidence?: SortOrder
    meaningConfidence?: SortOrder
    engagementConfidence?: SortOrder
    primaryArchetype?: SortOrder
    secondaryArchetype?: SortOrder
    archetypeConfidence?: SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrder
    journalAvgVividness?: SortOrder
    journalWakingLinkRate?: SortOrder
    scoringVersion?: SortOrder
    isStale?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boundaryScore?: SortOrder
    lucidityScore?: SortOrder
    emotionScore?: SortOrder
    meaningScore?: SortOrder
    engagementScore?: SortOrder
    boundaryConfidence?: SortOrder
    lucidityConfidence?: SortOrder
    emotionConfidence?: SortOrder
    meaningConfidence?: SortOrder
    engagementConfidence?: SortOrder
    primaryArchetype?: SortOrder
    secondaryArchetype?: SortOrder
    archetypeConfidence?: SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrder
    journalAvgVividness?: SortOrder
    journalWakingLinkRate?: SortOrder
    scoringVersion?: SortOrder
    isStale?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DreamerProfileSumOrderByAggregateInput = {
    boundaryScore?: SortOrder
    lucidityScore?: SortOrder
    emotionScore?: SortOrder
    meaningScore?: SortOrder
    engagementScore?: SortOrder
    boundaryConfidence?: SortOrder
    lucidityConfidence?: SortOrder
    emotionConfidence?: SortOrder
    meaningConfidence?: SortOrder
    engagementConfidence?: SortOrder
    archetypeConfidence?: SortOrder
    unlockPoints?: SortOrder
    unlockLevel?: SortOrder
    journalDreamCount?: SortOrder
    journalLucidPercent?: SortOrder
    journalAvgVividness?: SortOrder
    journalWakingLinkRate?: SortOrder
    scoringVersion?: SortOrder
  }

  export type AlarmSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlarmSettingsCreateOrConnectWithoutUserInput
    connect?: AlarmSettingsWhereUniqueInput
  }

  export type CensusAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput> | CensusAnswerCreateWithoutUserInput[] | CensusAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutUserInput | CensusAnswerCreateOrConnectWithoutUserInput[]
    createMany?: CensusAnswerCreateManyUserInputEnvelope
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
  }

  export type ConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput> | ConsentCreateWithoutUserInput[] | ConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutUserInput | ConsentCreateOrConnectWithoutUserInput[]
    createMany?: ConsentCreateManyUserInputEnvelope
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
  }

  export type DreamEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput> | DreamEntryCreateWithoutUserInput[] | DreamEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DreamEntryCreateOrConnectWithoutUserInput | DreamEntryCreateOrConnectWithoutUserInput[]
    createMany?: DreamEntryCreateManyUserInputEnvelope
    connect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
  }

  export type DreamerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: DreamerProfileCreateOrConnectWithoutUserInput
    connect?: DreamerProfileWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type NightCheckInCreateNestedManyWithoutUserInput = {
    create?: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput> | NightCheckInCreateWithoutUserInput[] | NightCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NightCheckInCreateOrConnectWithoutUserInput | NightCheckInCreateOrConnectWithoutUserInput[]
    createMany?: NightCheckInCreateManyUserInputEnvelope
    connect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
  }

  export type PromptResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput> | PromptResponseCreateWithoutUserInput[] | PromptResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutUserInput | PromptResponseCreateOrConnectWithoutUserInput[]
    createMany?: PromptResponseCreateManyUserInputEnvelope
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StudyParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput> | StudyParticipationCreateWithoutUserInput[] | StudyParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutUserInput | StudyParticipationCreateOrConnectWithoutUserInput[]
    createMany?: StudyParticipationCreateManyUserInputEnvelope
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
  }

  export type AlarmSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlarmSettingsCreateOrConnectWithoutUserInput
    connect?: AlarmSettingsWhereUniqueInput
  }

  export type CensusAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput> | CensusAnswerCreateWithoutUserInput[] | CensusAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutUserInput | CensusAnswerCreateOrConnectWithoutUserInput[]
    createMany?: CensusAnswerCreateManyUserInputEnvelope
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
  }

  export type ConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput> | ConsentCreateWithoutUserInput[] | ConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutUserInput | ConsentCreateOrConnectWithoutUserInput[]
    createMany?: ConsentCreateManyUserInputEnvelope
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
  }

  export type DreamEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput> | DreamEntryCreateWithoutUserInput[] | DreamEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DreamEntryCreateOrConnectWithoutUserInput | DreamEntryCreateOrConnectWithoutUserInput[]
    createMany?: DreamEntryCreateManyUserInputEnvelope
    connect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
  }

  export type DreamerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: DreamerProfileCreateOrConnectWithoutUserInput
    connect?: DreamerProfileWhereUniqueInput
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type NightCheckInUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput> | NightCheckInCreateWithoutUserInput[] | NightCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NightCheckInCreateOrConnectWithoutUserInput | NightCheckInCreateOrConnectWithoutUserInput[]
    createMany?: NightCheckInCreateManyUserInputEnvelope
    connect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
  }

  export type PromptResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput> | PromptResponseCreateWithoutUserInput[] | PromptResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutUserInput | PromptResponseCreateOrConnectWithoutUserInput[]
    createMany?: PromptResponseCreateManyUserInputEnvelope
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StudyParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput> | StudyParticipationCreateWithoutUserInput[] | StudyParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutUserInput | StudyParticipationCreateOrConnectWithoutUserInput[]
    createMany?: StudyParticipationCreateManyUserInputEnvelope
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type AlarmSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlarmSettingsCreateOrConnectWithoutUserInput
    upsert?: AlarmSettingsUpsertWithoutUserInput
    disconnect?: AlarmSettingsWhereInput | boolean
    delete?: AlarmSettingsWhereInput | boolean
    connect?: AlarmSettingsWhereUniqueInput
    update?: XOR<XOR<AlarmSettingsUpdateToOneWithWhereWithoutUserInput, AlarmSettingsUpdateWithoutUserInput>, AlarmSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CensusAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput> | CensusAnswerCreateWithoutUserInput[] | CensusAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutUserInput | CensusAnswerCreateOrConnectWithoutUserInput[]
    upsert?: CensusAnswerUpsertWithWhereUniqueWithoutUserInput | CensusAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CensusAnswerCreateManyUserInputEnvelope
    set?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    disconnect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    delete?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    update?: CensusAnswerUpdateWithWhereUniqueWithoutUserInput | CensusAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CensusAnswerUpdateManyWithWhereWithoutUserInput | CensusAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
  }

  export type ConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput> | ConsentCreateWithoutUserInput[] | ConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutUserInput | ConsentCreateOrConnectWithoutUserInput[]
    upsert?: ConsentUpsertWithWhereUniqueWithoutUserInput | ConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConsentCreateManyUserInputEnvelope
    set?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    disconnect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    delete?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    update?: ConsentUpdateWithWhereUniqueWithoutUserInput | ConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConsentUpdateManyWithWhereWithoutUserInput | ConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
  }

  export type DreamEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput> | DreamEntryCreateWithoutUserInput[] | DreamEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DreamEntryCreateOrConnectWithoutUserInput | DreamEntryCreateOrConnectWithoutUserInput[]
    upsert?: DreamEntryUpsertWithWhereUniqueWithoutUserInput | DreamEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DreamEntryCreateManyUserInputEnvelope
    set?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    disconnect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    delete?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    connect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    update?: DreamEntryUpdateWithWhereUniqueWithoutUserInput | DreamEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DreamEntryUpdateManyWithWhereWithoutUserInput | DreamEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DreamEntryScalarWhereInput | DreamEntryScalarWhereInput[]
  }

  export type DreamerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: DreamerProfileCreateOrConnectWithoutUserInput
    upsert?: DreamerProfileUpsertWithoutUserInput
    disconnect?: DreamerProfileWhereInput | boolean
    delete?: DreamerProfileWhereInput | boolean
    connect?: DreamerProfileWhereUniqueInput
    update?: XOR<XOR<DreamerProfileUpdateToOneWithWhereWithoutUserInput, DreamerProfileUpdateWithoutUserInput>, DreamerProfileUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type NightCheckInUpdateManyWithoutUserNestedInput = {
    create?: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput> | NightCheckInCreateWithoutUserInput[] | NightCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NightCheckInCreateOrConnectWithoutUserInput | NightCheckInCreateOrConnectWithoutUserInput[]
    upsert?: NightCheckInUpsertWithWhereUniqueWithoutUserInput | NightCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NightCheckInCreateManyUserInputEnvelope
    set?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    disconnect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    delete?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    connect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    update?: NightCheckInUpdateWithWhereUniqueWithoutUserInput | NightCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NightCheckInUpdateManyWithWhereWithoutUserInput | NightCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NightCheckInScalarWhereInput | NightCheckInScalarWhereInput[]
  }

  export type PromptResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput> | PromptResponseCreateWithoutUserInput[] | PromptResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutUserInput | PromptResponseCreateOrConnectWithoutUserInput[]
    upsert?: PromptResponseUpsertWithWhereUniqueWithoutUserInput | PromptResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromptResponseCreateManyUserInputEnvelope
    set?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    disconnect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    delete?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    update?: PromptResponseUpdateWithWhereUniqueWithoutUserInput | PromptResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromptResponseUpdateManyWithWhereWithoutUserInput | PromptResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StudyParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput> | StudyParticipationCreateWithoutUserInput[] | StudyParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutUserInput | StudyParticipationCreateOrConnectWithoutUserInput[]
    upsert?: StudyParticipationUpsertWithWhereUniqueWithoutUserInput | StudyParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyParticipationCreateManyUserInputEnvelope
    set?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    disconnect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    delete?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    update?: StudyParticipationUpdateWithWhereUniqueWithoutUserInput | StudyParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyParticipationUpdateManyWithWhereWithoutUserInput | StudyParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
  }

  export type AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlarmSettingsCreateOrConnectWithoutUserInput
    upsert?: AlarmSettingsUpsertWithoutUserInput
    disconnect?: AlarmSettingsWhereInput | boolean
    delete?: AlarmSettingsWhereInput | boolean
    connect?: AlarmSettingsWhereUniqueInput
    update?: XOR<XOR<AlarmSettingsUpdateToOneWithWhereWithoutUserInput, AlarmSettingsUpdateWithoutUserInput>, AlarmSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CensusAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput> | CensusAnswerCreateWithoutUserInput[] | CensusAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutUserInput | CensusAnswerCreateOrConnectWithoutUserInput[]
    upsert?: CensusAnswerUpsertWithWhereUniqueWithoutUserInput | CensusAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CensusAnswerCreateManyUserInputEnvelope
    set?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    disconnect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    delete?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    update?: CensusAnswerUpdateWithWhereUniqueWithoutUserInput | CensusAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CensusAnswerUpdateManyWithWhereWithoutUserInput | CensusAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
  }

  export type ConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput> | ConsentCreateWithoutUserInput[] | ConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConsentCreateOrConnectWithoutUserInput | ConsentCreateOrConnectWithoutUserInput[]
    upsert?: ConsentUpsertWithWhereUniqueWithoutUserInput | ConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConsentCreateManyUserInputEnvelope
    set?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    disconnect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    delete?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    connect?: ConsentWhereUniqueInput | ConsentWhereUniqueInput[]
    update?: ConsentUpdateWithWhereUniqueWithoutUserInput | ConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConsentUpdateManyWithWhereWithoutUserInput | ConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
  }

  export type DreamEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput> | DreamEntryCreateWithoutUserInput[] | DreamEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DreamEntryCreateOrConnectWithoutUserInput | DreamEntryCreateOrConnectWithoutUserInput[]
    upsert?: DreamEntryUpsertWithWhereUniqueWithoutUserInput | DreamEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DreamEntryCreateManyUserInputEnvelope
    set?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    disconnect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    delete?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    connect?: DreamEntryWhereUniqueInput | DreamEntryWhereUniqueInput[]
    update?: DreamEntryUpdateWithWhereUniqueWithoutUserInput | DreamEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DreamEntryUpdateManyWithWhereWithoutUserInput | DreamEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DreamEntryScalarWhereInput | DreamEntryScalarWhereInput[]
  }

  export type DreamerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: DreamerProfileCreateOrConnectWithoutUserInput
    upsert?: DreamerProfileUpsertWithoutUserInput
    disconnect?: DreamerProfileWhereInput | boolean
    delete?: DreamerProfileWhereInput | boolean
    connect?: DreamerProfileWhereUniqueInput
    update?: XOR<XOR<DreamerProfileUpdateToOneWithWhereWithoutUserInput, DreamerProfileUpdateWithoutUserInput>, DreamerProfileUncheckedUpdateWithoutUserInput>
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type NightCheckInUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput> | NightCheckInCreateWithoutUserInput[] | NightCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NightCheckInCreateOrConnectWithoutUserInput | NightCheckInCreateOrConnectWithoutUserInput[]
    upsert?: NightCheckInUpsertWithWhereUniqueWithoutUserInput | NightCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NightCheckInCreateManyUserInputEnvelope
    set?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    disconnect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    delete?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    connect?: NightCheckInWhereUniqueInput | NightCheckInWhereUniqueInput[]
    update?: NightCheckInUpdateWithWhereUniqueWithoutUserInput | NightCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NightCheckInUpdateManyWithWhereWithoutUserInput | NightCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NightCheckInScalarWhereInput | NightCheckInScalarWhereInput[]
  }

  export type PromptResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput> | PromptResponseCreateWithoutUserInput[] | PromptResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutUserInput | PromptResponseCreateOrConnectWithoutUserInput[]
    upsert?: PromptResponseUpsertWithWhereUniqueWithoutUserInput | PromptResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromptResponseCreateManyUserInputEnvelope
    set?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    disconnect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    delete?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    update?: PromptResponseUpdateWithWhereUniqueWithoutUserInput | PromptResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromptResponseUpdateManyWithWhereWithoutUserInput | PromptResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StudyParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput> | StudyParticipationCreateWithoutUserInput[] | StudyParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutUserInput | StudyParticipationCreateOrConnectWithoutUserInput[]
    upsert?: StudyParticipationUpsertWithWhereUniqueWithoutUserInput | StudyParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyParticipationCreateManyUserInputEnvelope
    set?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    disconnect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    delete?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    update?: StudyParticipationUpdateWithWhereUniqueWithoutUserInput | StudyParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyParticipationUpdateManyWithWhereWithoutUserInput | StudyParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type DreamEntryCreateemotionsInput = {
    set: string[]
  }

  export type DreamEntryCreatedreamTypesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDreamEntriesInput = {
    create?: XOR<UserCreateWithoutDreamEntriesInput, UserUncheckedCreateWithoutDreamEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDreamEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type DreamTagCreateNestedManyWithoutDreamEntryInput = {
    create?: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput> | DreamTagCreateWithoutDreamEntryInput[] | DreamTagUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutDreamEntryInput | DreamTagCreateOrConnectWithoutDreamEntryInput[]
    createMany?: DreamTagCreateManyDreamEntryInputEnvelope
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
  }

  export type JournalFactCreateNestedManyWithoutDreamEntryInput = {
    create?: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput> | JournalFactCreateWithoutDreamEntryInput[] | JournalFactUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: JournalFactCreateOrConnectWithoutDreamEntryInput | JournalFactCreateOrConnectWithoutDreamEntryInput[]
    createMany?: JournalFactCreateManyDreamEntryInputEnvelope
    connect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
  }

  export type DreamTagUncheckedCreateNestedManyWithoutDreamEntryInput = {
    create?: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput> | DreamTagCreateWithoutDreamEntryInput[] | DreamTagUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutDreamEntryInput | DreamTagCreateOrConnectWithoutDreamEntryInput[]
    createMany?: DreamTagCreateManyDreamEntryInputEnvelope
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
  }

  export type JournalFactUncheckedCreateNestedManyWithoutDreamEntryInput = {
    create?: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput> | JournalFactCreateWithoutDreamEntryInput[] | JournalFactUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: JournalFactCreateOrConnectWithoutDreamEntryInput | JournalFactCreateOrConnectWithoutDreamEntryInput[]
    createMany?: JournalFactCreateManyDreamEntryInputEnvelope
    connect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
  }

  export type DreamEntryUpdateemotionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DreamEntryUpdatedreamTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDreamEntriesNestedInput = {
    create?: XOR<UserCreateWithoutDreamEntriesInput, UserUncheckedCreateWithoutDreamEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDreamEntriesInput
    upsert?: UserUpsertWithoutDreamEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDreamEntriesInput, UserUpdateWithoutDreamEntriesInput>, UserUncheckedUpdateWithoutDreamEntriesInput>
  }

  export type DreamTagUpdateManyWithoutDreamEntryNestedInput = {
    create?: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput> | DreamTagCreateWithoutDreamEntryInput[] | DreamTagUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutDreamEntryInput | DreamTagCreateOrConnectWithoutDreamEntryInput[]
    upsert?: DreamTagUpsertWithWhereUniqueWithoutDreamEntryInput | DreamTagUpsertWithWhereUniqueWithoutDreamEntryInput[]
    createMany?: DreamTagCreateManyDreamEntryInputEnvelope
    set?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    disconnect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    delete?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    update?: DreamTagUpdateWithWhereUniqueWithoutDreamEntryInput | DreamTagUpdateWithWhereUniqueWithoutDreamEntryInput[]
    updateMany?: DreamTagUpdateManyWithWhereWithoutDreamEntryInput | DreamTagUpdateManyWithWhereWithoutDreamEntryInput[]
    deleteMany?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
  }

  export type JournalFactUpdateManyWithoutDreamEntryNestedInput = {
    create?: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput> | JournalFactCreateWithoutDreamEntryInput[] | JournalFactUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: JournalFactCreateOrConnectWithoutDreamEntryInput | JournalFactCreateOrConnectWithoutDreamEntryInput[]
    upsert?: JournalFactUpsertWithWhereUniqueWithoutDreamEntryInput | JournalFactUpsertWithWhereUniqueWithoutDreamEntryInput[]
    createMany?: JournalFactCreateManyDreamEntryInputEnvelope
    set?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    disconnect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    delete?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    connect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    update?: JournalFactUpdateWithWhereUniqueWithoutDreamEntryInput | JournalFactUpdateWithWhereUniqueWithoutDreamEntryInput[]
    updateMany?: JournalFactUpdateManyWithWhereWithoutDreamEntryInput | JournalFactUpdateManyWithWhereWithoutDreamEntryInput[]
    deleteMany?: JournalFactScalarWhereInput | JournalFactScalarWhereInput[]
  }

  export type DreamTagUncheckedUpdateManyWithoutDreamEntryNestedInput = {
    create?: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput> | DreamTagCreateWithoutDreamEntryInput[] | DreamTagUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutDreamEntryInput | DreamTagCreateOrConnectWithoutDreamEntryInput[]
    upsert?: DreamTagUpsertWithWhereUniqueWithoutDreamEntryInput | DreamTagUpsertWithWhereUniqueWithoutDreamEntryInput[]
    createMany?: DreamTagCreateManyDreamEntryInputEnvelope
    set?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    disconnect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    delete?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    update?: DreamTagUpdateWithWhereUniqueWithoutDreamEntryInput | DreamTagUpdateWithWhereUniqueWithoutDreamEntryInput[]
    updateMany?: DreamTagUpdateManyWithWhereWithoutDreamEntryInput | DreamTagUpdateManyWithWhereWithoutDreamEntryInput[]
    deleteMany?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
  }

  export type JournalFactUncheckedUpdateManyWithoutDreamEntryNestedInput = {
    create?: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput> | JournalFactCreateWithoutDreamEntryInput[] | JournalFactUncheckedCreateWithoutDreamEntryInput[]
    connectOrCreate?: JournalFactCreateOrConnectWithoutDreamEntryInput | JournalFactCreateOrConnectWithoutDreamEntryInput[]
    upsert?: JournalFactUpsertWithWhereUniqueWithoutDreamEntryInput | JournalFactUpsertWithWhereUniqueWithoutDreamEntryInput[]
    createMany?: JournalFactCreateManyDreamEntryInputEnvelope
    set?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    disconnect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    delete?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    connect?: JournalFactWhereUniqueInput | JournalFactWhereUniqueInput[]
    update?: JournalFactUpdateWithWhereUniqueWithoutDreamEntryInput | JournalFactUpdateWithWhereUniqueWithoutDreamEntryInput[]
    updateMany?: JournalFactUpdateManyWithWhereWithoutDreamEntryInput | JournalFactUpdateManyWithWhereWithoutDreamEntryInput[]
    deleteMany?: JournalFactScalarWhereInput | JournalFactScalarWhereInput[]
  }

  export type DreamEntryCreateNestedOneWithoutFactsInput = {
    create?: XOR<DreamEntryCreateWithoutFactsInput, DreamEntryUncheckedCreateWithoutFactsInput>
    connectOrCreate?: DreamEntryCreateOrConnectWithoutFactsInput
    connect?: DreamEntryWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DreamEntryUpdateOneRequiredWithoutFactsNestedInput = {
    create?: XOR<DreamEntryCreateWithoutFactsInput, DreamEntryUncheckedCreateWithoutFactsInput>
    connectOrCreate?: DreamEntryCreateOrConnectWithoutFactsInput
    upsert?: DreamEntryUpsertWithoutFactsInput
    connect?: DreamEntryWhereUniqueInput
    update?: XOR<XOR<DreamEntryUpdateToOneWithWhereWithoutFactsInput, DreamEntryUpdateWithoutFactsInput>, DreamEntryUncheckedUpdateWithoutFactsInput>
  }

  export type DreamTagCreateNestedManyWithoutTagInput = {
    create?: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput> | DreamTagCreateWithoutTagInput[] | DreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutTagInput | DreamTagCreateOrConnectWithoutTagInput[]
    createMany?: DreamTagCreateManyTagInputEnvelope
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
  }

  export type DreamTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput> | DreamTagCreateWithoutTagInput[] | DreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutTagInput | DreamTagCreateOrConnectWithoutTagInput[]
    createMany?: DreamTagCreateManyTagInputEnvelope
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
  }

  export type DreamTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput> | DreamTagCreateWithoutTagInput[] | DreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutTagInput | DreamTagCreateOrConnectWithoutTagInput[]
    upsert?: DreamTagUpsertWithWhereUniqueWithoutTagInput | DreamTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DreamTagCreateManyTagInputEnvelope
    set?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    disconnect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    delete?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    update?: DreamTagUpdateWithWhereUniqueWithoutTagInput | DreamTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DreamTagUpdateManyWithWhereWithoutTagInput | DreamTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
  }

  export type DreamTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput> | DreamTagCreateWithoutTagInput[] | DreamTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DreamTagCreateOrConnectWithoutTagInput | DreamTagCreateOrConnectWithoutTagInput[]
    upsert?: DreamTagUpsertWithWhereUniqueWithoutTagInput | DreamTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DreamTagCreateManyTagInputEnvelope
    set?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    disconnect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    delete?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    connect?: DreamTagWhereUniqueInput | DreamTagWhereUniqueInput[]
    update?: DreamTagUpdateWithWhereUniqueWithoutTagInput | DreamTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DreamTagUpdateManyWithWhereWithoutTagInput | DreamTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
  }

  export type DreamEntryCreateNestedOneWithoutTagsInput = {
    create?: XOR<DreamEntryCreateWithoutTagsInput, DreamEntryUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DreamEntryCreateOrConnectWithoutTagsInput
    connect?: DreamEntryWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutDreamTagsInput = {
    create?: XOR<TagCreateWithoutDreamTagsInput, TagUncheckedCreateWithoutDreamTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDreamTagsInput
    connect?: TagWhereUniqueInput
  }

  export type DreamEntryUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<DreamEntryCreateWithoutTagsInput, DreamEntryUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DreamEntryCreateOrConnectWithoutTagsInput
    upsert?: DreamEntryUpsertWithoutTagsInput
    connect?: DreamEntryWhereUniqueInput
    update?: XOR<XOR<DreamEntryUpdateToOneWithWhereWithoutTagsInput, DreamEntryUpdateWithoutTagsInput>, DreamEntryUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutDreamTagsNestedInput = {
    create?: XOR<TagCreateWithoutDreamTagsInput, TagUncheckedCreateWithoutDreamTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutDreamTagsInput
    upsert?: TagUpsertWithoutDreamTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutDreamTagsInput, TagUpdateWithoutDreamTagsInput>, TagUncheckedUpdateWithoutDreamTagsInput>
  }

  export type CensusSectionCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput> | CensusSectionCreateWithoutInstrumentInput[] | CensusSectionUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: CensusSectionCreateOrConnectWithoutInstrumentInput | CensusSectionCreateOrConnectWithoutInstrumentInput[]
    createMany?: CensusSectionCreateManyInstrumentInputEnvelope
    connect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
  }

  export type CensusSectionUncheckedCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput> | CensusSectionCreateWithoutInstrumentInput[] | CensusSectionUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: CensusSectionCreateOrConnectWithoutInstrumentInput | CensusSectionCreateOrConnectWithoutInstrumentInput[]
    createMany?: CensusSectionCreateManyInstrumentInputEnvelope
    connect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CensusSectionUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput> | CensusSectionCreateWithoutInstrumentInput[] | CensusSectionUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: CensusSectionCreateOrConnectWithoutInstrumentInput | CensusSectionCreateOrConnectWithoutInstrumentInput[]
    upsert?: CensusSectionUpsertWithWhereUniqueWithoutInstrumentInput | CensusSectionUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: CensusSectionCreateManyInstrumentInputEnvelope
    set?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    disconnect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    delete?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    connect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    update?: CensusSectionUpdateWithWhereUniqueWithoutInstrumentInput | CensusSectionUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: CensusSectionUpdateManyWithWhereWithoutInstrumentInput | CensusSectionUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: CensusSectionScalarWhereInput | CensusSectionScalarWhereInput[]
  }

  export type CensusSectionUncheckedUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput> | CensusSectionCreateWithoutInstrumentInput[] | CensusSectionUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: CensusSectionCreateOrConnectWithoutInstrumentInput | CensusSectionCreateOrConnectWithoutInstrumentInput[]
    upsert?: CensusSectionUpsertWithWhereUniqueWithoutInstrumentInput | CensusSectionUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: CensusSectionCreateManyInstrumentInputEnvelope
    set?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    disconnect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    delete?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    connect?: CensusSectionWhereUniqueInput | CensusSectionWhereUniqueInput[]
    update?: CensusSectionUpdateWithWhereUniqueWithoutInstrumentInput | CensusSectionUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: CensusSectionUpdateManyWithWhereWithoutInstrumentInput | CensusSectionUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: CensusSectionScalarWhereInput | CensusSectionScalarWhereInput[]
  }

  export type CensusQuestionCreateNestedManyWithoutSectionInput = {
    create?: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput> | CensusQuestionCreateWithoutSectionInput[] | CensusQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutSectionInput | CensusQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: CensusQuestionCreateManySectionInputEnvelope
    connect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
  }

  export type CensusInstrumentCreateNestedOneWithoutSectionsInput = {
    create?: XOR<CensusInstrumentCreateWithoutSectionsInput, CensusInstrumentUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CensusInstrumentCreateOrConnectWithoutSectionsInput
    connect?: CensusInstrumentWhereUniqueInput
  }

  export type CensusQuestionUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput> | CensusQuestionCreateWithoutSectionInput[] | CensusQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutSectionInput | CensusQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: CensusQuestionCreateManySectionInputEnvelope
    connect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
  }

  export type CensusQuestionUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput> | CensusQuestionCreateWithoutSectionInput[] | CensusQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutSectionInput | CensusQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: CensusQuestionUpsertWithWhereUniqueWithoutSectionInput | CensusQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CensusQuestionCreateManySectionInputEnvelope
    set?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    disconnect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    delete?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    connect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    update?: CensusQuestionUpdateWithWhereUniqueWithoutSectionInput | CensusQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CensusQuestionUpdateManyWithWhereWithoutSectionInput | CensusQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CensusQuestionScalarWhereInput | CensusQuestionScalarWhereInput[]
  }

  export type CensusInstrumentUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<CensusInstrumentCreateWithoutSectionsInput, CensusInstrumentUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: CensusInstrumentCreateOrConnectWithoutSectionsInput
    upsert?: CensusInstrumentUpsertWithoutSectionsInput
    connect?: CensusInstrumentWhereUniqueInput
    update?: XOR<XOR<CensusInstrumentUpdateToOneWithWhereWithoutSectionsInput, CensusInstrumentUpdateWithoutSectionsInput>, CensusInstrumentUncheckedUpdateWithoutSectionsInput>
  }

  export type CensusQuestionUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput> | CensusQuestionCreateWithoutSectionInput[] | CensusQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutSectionInput | CensusQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: CensusQuestionUpsertWithWhereUniqueWithoutSectionInput | CensusQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CensusQuestionCreateManySectionInputEnvelope
    set?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    disconnect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    delete?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    connect?: CensusQuestionWhereUniqueInput | CensusQuestionWhereUniqueInput[]
    update?: CensusQuestionUpdateWithWhereUniqueWithoutSectionInput | CensusQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CensusQuestionUpdateManyWithWhereWithoutSectionInput | CensusQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CensusQuestionScalarWhereInput | CensusQuestionScalarWhereInput[]
  }

  export type CensusAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput> | CensusAnswerCreateWithoutQuestionInput[] | CensusAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutQuestionInput | CensusAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: CensusAnswerCreateManyQuestionInputEnvelope
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
  }

  export type CensusSectionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<CensusSectionCreateWithoutQuestionsInput, CensusSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CensusSectionCreateOrConnectWithoutQuestionsInput
    connect?: CensusSectionWhereUniqueInput
  }

  export type CensusAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput> | CensusAnswerCreateWithoutQuestionInput[] | CensusAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutQuestionInput | CensusAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: CensusAnswerCreateManyQuestionInputEnvelope
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
  }

  export type CensusAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput> | CensusAnswerCreateWithoutQuestionInput[] | CensusAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutQuestionInput | CensusAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: CensusAnswerUpsertWithWhereUniqueWithoutQuestionInput | CensusAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: CensusAnswerCreateManyQuestionInputEnvelope
    set?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    disconnect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    delete?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    update?: CensusAnswerUpdateWithWhereUniqueWithoutQuestionInput | CensusAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: CensusAnswerUpdateManyWithWhereWithoutQuestionInput | CensusAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
  }

  export type CensusSectionUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<CensusSectionCreateWithoutQuestionsInput, CensusSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CensusSectionCreateOrConnectWithoutQuestionsInput
    upsert?: CensusSectionUpsertWithoutQuestionsInput
    connect?: CensusSectionWhereUniqueInput
    update?: XOR<XOR<CensusSectionUpdateToOneWithWhereWithoutQuestionsInput, CensusSectionUpdateWithoutQuestionsInput>, CensusSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type CensusAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput> | CensusAnswerCreateWithoutQuestionInput[] | CensusAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: CensusAnswerCreateOrConnectWithoutQuestionInput | CensusAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: CensusAnswerUpsertWithWhereUniqueWithoutQuestionInput | CensusAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: CensusAnswerCreateManyQuestionInputEnvelope
    set?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    disconnect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    delete?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    connect?: CensusAnswerWhereUniqueInput | CensusAnswerWhereUniqueInput[]
    update?: CensusAnswerUpdateWithWhereUniqueWithoutQuestionInput | CensusAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: CensusAnswerUpdateManyWithWhereWithoutQuestionInput | CensusAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
  }

  export type CensusQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<CensusQuestionCreateWithoutAnswersInput, CensusQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutAnswersInput
    connect?: CensusQuestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCensusAnswersInput = {
    create?: XOR<UserCreateWithoutCensusAnswersInput, UserUncheckedCreateWithoutCensusAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCensusAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type CensusQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<CensusQuestionCreateWithoutAnswersInput, CensusQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: CensusQuestionCreateOrConnectWithoutAnswersInput
    upsert?: CensusQuestionUpsertWithoutAnswersInput
    connect?: CensusQuestionWhereUniqueInput
    update?: XOR<XOR<CensusQuestionUpdateToOneWithWhereWithoutAnswersInput, CensusQuestionUpdateWithoutAnswersInput>, CensusQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateOneRequiredWithoutCensusAnswersNestedInput = {
    create?: XOR<UserCreateWithoutCensusAnswersInput, UserUncheckedCreateWithoutCensusAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCensusAnswersInput
    upsert?: UserUpsertWithoutCensusAnswersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCensusAnswersInput, UserUpdateWithoutCensusAnswersInput>, UserUncheckedUpdateWithoutCensusAnswersInput>
  }

  export type StudyCreateNestedOneWithoutPromptsInput = {
    create?: XOR<StudyCreateWithoutPromptsInput, StudyUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutPromptsInput
    connect?: StudyWhereUniqueInput
  }

  export type PromptResponseCreateNestedManyWithoutPromptInput = {
    create?: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput> | PromptResponseCreateWithoutPromptInput[] | PromptResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutPromptInput | PromptResponseCreateOrConnectWithoutPromptInput[]
    createMany?: PromptResponseCreateManyPromptInputEnvelope
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
  }

  export type PromptResponseUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput> | PromptResponseCreateWithoutPromptInput[] | PromptResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutPromptInput | PromptResponseCreateOrConnectWithoutPromptInput[]
    createMany?: PromptResponseCreateManyPromptInputEnvelope
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
  }

  export type StudyUpdateOneWithoutPromptsNestedInput = {
    create?: XOR<StudyCreateWithoutPromptsInput, StudyUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutPromptsInput
    upsert?: StudyUpsertWithoutPromptsInput
    disconnect?: StudyWhereInput | boolean
    delete?: StudyWhereInput | boolean
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutPromptsInput, StudyUpdateWithoutPromptsInput>, StudyUncheckedUpdateWithoutPromptsInput>
  }

  export type PromptResponseUpdateManyWithoutPromptNestedInput = {
    create?: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput> | PromptResponseCreateWithoutPromptInput[] | PromptResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutPromptInput | PromptResponseCreateOrConnectWithoutPromptInput[]
    upsert?: PromptResponseUpsertWithWhereUniqueWithoutPromptInput | PromptResponseUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: PromptResponseCreateManyPromptInputEnvelope
    set?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    disconnect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    delete?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    update?: PromptResponseUpdateWithWhereUniqueWithoutPromptInput | PromptResponseUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: PromptResponseUpdateManyWithWhereWithoutPromptInput | PromptResponseUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
  }

  export type PromptResponseUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput> | PromptResponseCreateWithoutPromptInput[] | PromptResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PromptResponseCreateOrConnectWithoutPromptInput | PromptResponseCreateOrConnectWithoutPromptInput[]
    upsert?: PromptResponseUpsertWithWhereUniqueWithoutPromptInput | PromptResponseUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: PromptResponseCreateManyPromptInputEnvelope
    set?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    disconnect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    delete?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    connect?: PromptResponseWhereUniqueInput | PromptResponseWhereUniqueInput[]
    update?: PromptResponseUpdateWithWhereUniqueWithoutPromptInput | PromptResponseUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: PromptResponseUpdateManyWithWhereWithoutPromptInput | PromptResponseUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
  }

  export type PromptCreateNestedOneWithoutResponsesInput = {
    create?: XOR<PromptCreateWithoutResponsesInput, PromptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PromptCreateOrConnectWithoutResponsesInput
    connect?: PromptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPromptResponsesInput = {
    create?: XOR<UserCreateWithoutPromptResponsesInput, UserUncheckedCreateWithoutPromptResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromptResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type PromptUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<PromptCreateWithoutResponsesInput, PromptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PromptCreateOrConnectWithoutResponsesInput
    upsert?: PromptUpsertWithoutResponsesInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutResponsesInput, PromptUpdateWithoutResponsesInput>, PromptUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutPromptResponsesNestedInput = {
    create?: XOR<UserCreateWithoutPromptResponsesInput, UserUncheckedCreateWithoutPromptResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromptResponsesInput
    upsert?: UserUpsertWithoutPromptResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPromptResponsesInput, UserUpdateWithoutPromptResponsesInput>, UserUncheckedUpdateWithoutPromptResponsesInput>
  }

  export type UserCreateNestedOneWithoutConsentsInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    upsert?: UserUpsertWithoutConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsentsInput, UserUpdateWithoutConsentsInput>, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type PromptCreateNestedManyWithoutStudyInput = {
    create?: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput> | PromptCreateWithoutStudyInput[] | PromptUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutStudyInput | PromptCreateOrConnectWithoutStudyInput[]
    createMany?: PromptCreateManyStudyInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type StudyParticipationCreateNestedManyWithoutStudyInput = {
    create?: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput> | StudyParticipationCreateWithoutStudyInput[] | StudyParticipationUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutStudyInput | StudyParticipationCreateOrConnectWithoutStudyInput[]
    createMany?: StudyParticipationCreateManyStudyInputEnvelope
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput> | PromptCreateWithoutStudyInput[] | PromptUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutStudyInput | PromptCreateOrConnectWithoutStudyInput[]
    createMany?: PromptCreateManyStudyInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type StudyParticipationUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput> | StudyParticipationCreateWithoutStudyInput[] | StudyParticipationUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutStudyInput | StudyParticipationCreateOrConnectWithoutStudyInput[]
    createMany?: StudyParticipationCreateManyStudyInputEnvelope
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
  }

  export type PromptUpdateManyWithoutStudyNestedInput = {
    create?: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput> | PromptCreateWithoutStudyInput[] | PromptUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutStudyInput | PromptCreateOrConnectWithoutStudyInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutStudyInput | PromptUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: PromptCreateManyStudyInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutStudyInput | PromptUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutStudyInput | PromptUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type StudyParticipationUpdateManyWithoutStudyNestedInput = {
    create?: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput> | StudyParticipationCreateWithoutStudyInput[] | StudyParticipationUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutStudyInput | StudyParticipationCreateOrConnectWithoutStudyInput[]
    upsert?: StudyParticipationUpsertWithWhereUniqueWithoutStudyInput | StudyParticipationUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: StudyParticipationCreateManyStudyInputEnvelope
    set?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    disconnect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    delete?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    update?: StudyParticipationUpdateWithWhereUniqueWithoutStudyInput | StudyParticipationUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: StudyParticipationUpdateManyWithWhereWithoutStudyInput | StudyParticipationUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput> | PromptCreateWithoutStudyInput[] | PromptUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutStudyInput | PromptCreateOrConnectWithoutStudyInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutStudyInput | PromptUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: PromptCreateManyStudyInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutStudyInput | PromptUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutStudyInput | PromptUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type StudyParticipationUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput> | StudyParticipationCreateWithoutStudyInput[] | StudyParticipationUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: StudyParticipationCreateOrConnectWithoutStudyInput | StudyParticipationCreateOrConnectWithoutStudyInput[]
    upsert?: StudyParticipationUpsertWithWhereUniqueWithoutStudyInput | StudyParticipationUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: StudyParticipationCreateManyStudyInputEnvelope
    set?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    disconnect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    delete?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    connect?: StudyParticipationWhereUniqueInput | StudyParticipationWhereUniqueInput[]
    update?: StudyParticipationUpdateWithWhereUniqueWithoutStudyInput | StudyParticipationUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: StudyParticipationUpdateManyWithWhereWithoutStudyInput | StudyParticipationUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
  }

  export type StudyCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<StudyCreateWithoutParticipationsInput, StudyUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutParticipationsInput
    connect?: StudyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudyParticipationsInput = {
    create?: XOR<UserCreateWithoutStudyParticipationsInput, UserUncheckedCreateWithoutStudyParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type StudyUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<StudyCreateWithoutParticipationsInput, StudyUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutParticipationsInput
    upsert?: StudyUpsertWithoutParticipationsInput
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutParticipationsInput, StudyUpdateWithoutParticipationsInput>, StudyUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserUpdateOneRequiredWithoutStudyParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutStudyParticipationsInput, UserUncheckedCreateWithoutStudyParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyParticipationsInput
    upsert?: UserUpsertWithoutStudyParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudyParticipationsInput, UserUpdateWithoutStudyParticipationsInput>, UserUncheckedUpdateWithoutStudyParticipationsInput>
  }

  export type EmotionCreateNestedOneWithoutChildrenInput = {
    create?: XOR<EmotionCreateWithoutChildrenInput, EmotionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EmotionCreateOrConnectWithoutChildrenInput
    connect?: EmotionWhereUniqueInput
  }

  export type EmotionCreateNestedManyWithoutParentInput = {
    create?: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput> | EmotionCreateWithoutParentInput[] | EmotionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EmotionCreateOrConnectWithoutParentInput | EmotionCreateOrConnectWithoutParentInput[]
    createMany?: EmotionCreateManyParentInputEnvelope
    connect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
  }

  export type EmotionUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput> | EmotionCreateWithoutParentInput[] | EmotionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EmotionCreateOrConnectWithoutParentInput | EmotionCreateOrConnectWithoutParentInput[]
    createMany?: EmotionCreateManyParentInputEnvelope
    connect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
  }

  export type EmotionUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<EmotionCreateWithoutChildrenInput, EmotionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EmotionCreateOrConnectWithoutChildrenInput
    upsert?: EmotionUpsertWithoutChildrenInput
    disconnect?: EmotionWhereInput | boolean
    delete?: EmotionWhereInput | boolean
    connect?: EmotionWhereUniqueInput
    update?: XOR<XOR<EmotionUpdateToOneWithWhereWithoutChildrenInput, EmotionUpdateWithoutChildrenInput>, EmotionUncheckedUpdateWithoutChildrenInput>
  }

  export type EmotionUpdateManyWithoutParentNestedInput = {
    create?: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput> | EmotionCreateWithoutParentInput[] | EmotionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EmotionCreateOrConnectWithoutParentInput | EmotionCreateOrConnectWithoutParentInput[]
    upsert?: EmotionUpsertWithWhereUniqueWithoutParentInput | EmotionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EmotionCreateManyParentInputEnvelope
    set?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    disconnect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    delete?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    connect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    update?: EmotionUpdateWithWhereUniqueWithoutParentInput | EmotionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EmotionUpdateManyWithWhereWithoutParentInput | EmotionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EmotionScalarWhereInput | EmotionScalarWhereInput[]
  }

  export type EmotionUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput> | EmotionCreateWithoutParentInput[] | EmotionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EmotionCreateOrConnectWithoutParentInput | EmotionCreateOrConnectWithoutParentInput[]
    upsert?: EmotionUpsertWithWhereUniqueWithoutParentInput | EmotionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EmotionCreateManyParentInputEnvelope
    set?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    disconnect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    delete?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    connect?: EmotionWhereUniqueInput | EmotionWhereUniqueInput[]
    update?: EmotionUpdateWithWhereUniqueWithoutParentInput | EmotionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EmotionUpdateManyWithWhereWithoutParentInput | EmotionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EmotionScalarWhereInput | EmotionScalarWhereInput[]
  }

  export type ThemeCreaterelatedSlugsInput = {
    set: string[]
  }

  export type ThemeUpdaterelatedSlugsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutNightCheckInsInput = {
    create?: XOR<UserCreateWithoutNightCheckInsInput, UserUncheckedCreateWithoutNightCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNightCheckInsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNightCheckInsNestedInput = {
    create?: XOR<UserCreateWithoutNightCheckInsInput, UserUncheckedCreateWithoutNightCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNightCheckInsInput
    upsert?: UserUpsertWithoutNightCheckInsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNightCheckInsInput, UserUpdateWithoutNightCheckInsInput>, UserUncheckedUpdateWithoutNightCheckInsInput>
  }

  export type UserCreateNestedOneWithoutAlarmSettingsInput = {
    create?: XOR<UserCreateWithoutAlarmSettingsInput, UserUncheckedCreateWithoutAlarmSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlarmSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAlarmSettingsNestedInput = {
    create?: XOR<UserCreateWithoutAlarmSettingsInput, UserUncheckedCreateWithoutAlarmSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlarmSettingsInput
    upsert?: UserUpsertWithoutAlarmSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlarmSettingsInput, UserUpdateWithoutAlarmSettingsInput>, UserUncheckedUpdateWithoutAlarmSettingsInput>
  }

  export type DreamerProfileCreatejournalTopEmotionsInput = {
    set: string[]
  }

  export type DreamerProfileCreatejournalTopTagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDreamerProfileInput = {
    create?: XOR<UserCreateWithoutDreamerProfileInput, UserUncheckedCreateWithoutDreamerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDreamerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type DreamerProfileUpdatejournalTopEmotionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DreamerProfileUpdatejournalTopTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDreamerProfileNestedInput = {
    create?: XOR<UserCreateWithoutDreamerProfileInput, UserUncheckedCreateWithoutDreamerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDreamerProfileInput
    upsert?: UserUpsertWithoutDreamerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDreamerProfileInput, UserUpdateWithoutDreamerProfileInput>, UserUncheckedUpdateWithoutDreamerProfileInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AlarmSettingsCreateWithoutUserInput = {
    id?: string
    isArmed?: boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: string
    volume?: number
    snoozeMinutes?: number
    maxSnoozes?: number
    lastSetTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlarmSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    isArmed?: boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: string
    volume?: number
    snoozeMinutes?: number
    maxSnoozes?: number
    lastSetTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlarmSettingsCreateOrConnectWithoutUserInput = {
    where: AlarmSettingsWhereUniqueInput
    create: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
  }

  export type CensusAnswerCreateWithoutUserInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    question: CensusQuestionCreateNestedOneWithoutAnswersInput
  }

  export type CensusAnswerUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusAnswerCreateOrConnectWithoutUserInput = {
    where: CensusAnswerWhereUniqueInput
    create: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput>
  }

  export type CensusAnswerCreateManyUserInputEnvelope = {
    data: CensusAnswerCreateManyUserInput | CensusAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConsentCreateWithoutUserInput = {
    id?: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
  }

  export type ConsentUncheckedCreateWithoutUserInput = {
    id?: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
  }

  export type ConsentCreateOrConnectWithoutUserInput = {
    where: ConsentWhereUniqueInput
    create: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput>
  }

  export type ConsentCreateManyUserInputEnvelope = {
    data: ConsentCreateManyUserInput | ConsentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DreamEntryCreateWithoutUserInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    tags?: DreamTagCreateNestedManyWithoutDreamEntryInput
    facts?: JournalFactCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryUncheckedCreateWithoutUserInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    tags?: DreamTagUncheckedCreateNestedManyWithoutDreamEntryInput
    facts?: JournalFactUncheckedCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryCreateOrConnectWithoutUserInput = {
    where: DreamEntryWhereUniqueInput
    create: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput>
  }

  export type DreamEntryCreateManyUserInputEnvelope = {
    data: DreamEntryCreateManyUserInput | DreamEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DreamerProfileCreateWithoutUserInput = {
    id?: string
    boundaryScore?: number | null
    lucidityScore?: number | null
    emotionScore?: number | null
    meaningScore?: number | null
    engagementScore?: number | null
    boundaryConfidence?: number | null
    lucidityConfidence?: number | null
    emotionConfidence?: number | null
    meaningConfidence?: number | null
    engagementConfidence?: number | null
    primaryArchetype?: string | null
    secondaryArchetype?: string | null
    archetypeConfidence?: number | null
    unlockPoints?: number
    unlockLevel?: number
    journalDreamCount?: number
    journalLucidPercent?: number | null
    journalAvgVividness?: number | null
    journalTopEmotions?: DreamerProfileCreatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileCreatejournalTopTagsInput | string[]
    journalWakingLinkRate?: number | null
    scoringVersion?: number
    isStale?: boolean
    lastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DreamerProfileUncheckedCreateWithoutUserInput = {
    id?: string
    boundaryScore?: number | null
    lucidityScore?: number | null
    emotionScore?: number | null
    meaningScore?: number | null
    engagementScore?: number | null
    boundaryConfidence?: number | null
    lucidityConfidence?: number | null
    emotionConfidence?: number | null
    meaningConfidence?: number | null
    engagementConfidence?: number | null
    primaryArchetype?: string | null
    secondaryArchetype?: string | null
    archetypeConfidence?: number | null
    unlockPoints?: number
    unlockLevel?: number
    journalDreamCount?: number
    journalLucidPercent?: number | null
    journalAvgVividness?: number | null
    journalTopEmotions?: DreamerProfileCreatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileCreatejournalTopTagsInput | string[]
    journalWakingLinkRate?: number | null
    scoringVersion?: number
    isStale?: boolean
    lastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DreamerProfileCreateOrConnectWithoutUserInput = {
    where: DreamerProfileWhereUniqueInput
    create: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
  }

  export type EventCreateWithoutUserInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NightCheckInCreateWithoutUserInput = {
    id?: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
  }

  export type NightCheckInUncheckedCreateWithoutUserInput = {
    id?: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
  }

  export type NightCheckInCreateOrConnectWithoutUserInput = {
    where: NightCheckInWhereUniqueInput
    create: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput>
  }

  export type NightCheckInCreateManyUserInputEnvelope = {
    data: NightCheckInCreateManyUserInput | NightCheckInCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromptResponseCreateWithoutUserInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
    prompt: PromptCreateNestedOneWithoutResponsesInput
  }

  export type PromptResponseUncheckedCreateWithoutUserInput = {
    id?: string
    promptId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type PromptResponseCreateOrConnectWithoutUserInput = {
    where: PromptResponseWhereUniqueInput
    create: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput>
  }

  export type PromptResponseCreateManyUserInputEnvelope = {
    data: PromptResponseCreateManyUserInput | PromptResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyParticipationCreateWithoutUserInput = {
    id?: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
    study: StudyCreateNestedOneWithoutParticipationsInput
  }

  export type StudyParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    studyId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type StudyParticipationCreateOrConnectWithoutUserInput = {
    where: StudyParticipationWhereUniqueInput
    create: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput>
  }

  export type StudyParticipationCreateManyUserInputEnvelope = {
    data: StudyParticipationCreateManyUserInput | StudyParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlarmSettingsUpsertWithoutUserInput = {
    update: XOR<AlarmSettingsUpdateWithoutUserInput, AlarmSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<AlarmSettingsCreateWithoutUserInput, AlarmSettingsUncheckedCreateWithoutUserInput>
    where?: AlarmSettingsWhereInput
  }

  export type AlarmSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: AlarmSettingsWhereInput
    data: XOR<AlarmSettingsUpdateWithoutUserInput, AlarmSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AlarmSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isArmed?: BoolFieldUpdateOperationsInput | boolean
    schedule?: JsonNullValueInput | InputJsonValue
    soundId?: StringFieldUpdateOperationsInput | string
    volume?: IntFieldUpdateOperationsInput | number
    snoozeMinutes?: IntFieldUpdateOperationsInput | number
    maxSnoozes?: IntFieldUpdateOperationsInput | number
    lastSetTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: CensusAnswerWhereUniqueInput
    update: XOR<CensusAnswerUpdateWithoutUserInput, CensusAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<CensusAnswerCreateWithoutUserInput, CensusAnswerUncheckedCreateWithoutUserInput>
  }

  export type CensusAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: CensusAnswerWhereUniqueInput
    data: XOR<CensusAnswerUpdateWithoutUserInput, CensusAnswerUncheckedUpdateWithoutUserInput>
  }

  export type CensusAnswerUpdateManyWithWhereWithoutUserInput = {
    where: CensusAnswerScalarWhereInput
    data: XOR<CensusAnswerUpdateManyMutationInput, CensusAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type CensusAnswerScalarWhereInput = {
    AND?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
    OR?: CensusAnswerScalarWhereInput[]
    NOT?: CensusAnswerScalarWhereInput | CensusAnswerScalarWhereInput[]
    id?: StringFilter<"CensusAnswer"> | string
    userId?: StringFilter<"CensusAnswer"> | string
    questionId?: StringFilter<"CensusAnswer"> | string
    value?: JsonFilter<"CensusAnswer">
    instrumentVersion?: IntFilter<"CensusAnswer"> | number
    createdAt?: DateTimeFilter<"CensusAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"CensusAnswer"> | Date | string
  }

  export type ConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: ConsentWhereUniqueInput
    update: XOR<ConsentUpdateWithoutUserInput, ConsentUncheckedUpdateWithoutUserInput>
    create: XOR<ConsentCreateWithoutUserInput, ConsentUncheckedCreateWithoutUserInput>
  }

  export type ConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: ConsentWhereUniqueInput
    data: XOR<ConsentUpdateWithoutUserInput, ConsentUncheckedUpdateWithoutUserInput>
  }

  export type ConsentUpdateManyWithWhereWithoutUserInput = {
    where: ConsentScalarWhereInput
    data: XOR<ConsentUpdateManyMutationInput, ConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type ConsentScalarWhereInput = {
    AND?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
    OR?: ConsentScalarWhereInput[]
    NOT?: ConsentScalarWhereInput | ConsentScalarWhereInput[]
    id?: StringFilter<"Consent"> | string
    userId?: StringFilter<"Consent"> | string
    scope?: StringFilter<"Consent"> | string
    version?: IntFilter<"Consent"> | number
    granted?: BoolFilter<"Consent"> | boolean
    timestamp?: DateTimeFilter<"Consent"> | Date | string
    receiptHash?: StringFilter<"Consent"> | string
    policyHash?: StringFilter<"Consent"> | string
    jurisdiction?: StringNullableFilter<"Consent"> | string | null
    ipHash?: StringNullableFilter<"Consent"> | string | null
  }

  export type DreamEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: DreamEntryWhereUniqueInput
    update: XOR<DreamEntryUpdateWithoutUserInput, DreamEntryUncheckedUpdateWithoutUserInput>
    create: XOR<DreamEntryCreateWithoutUserInput, DreamEntryUncheckedCreateWithoutUserInput>
  }

  export type DreamEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: DreamEntryWhereUniqueInput
    data: XOR<DreamEntryUpdateWithoutUserInput, DreamEntryUncheckedUpdateWithoutUserInput>
  }

  export type DreamEntryUpdateManyWithWhereWithoutUserInput = {
    where: DreamEntryScalarWhereInput
    data: XOR<DreamEntryUpdateManyMutationInput, DreamEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type DreamEntryScalarWhereInput = {
    AND?: DreamEntryScalarWhereInput | DreamEntryScalarWhereInput[]
    OR?: DreamEntryScalarWhereInput[]
    NOT?: DreamEntryScalarWhereInput | DreamEntryScalarWhereInput[]
    id?: StringFilter<"DreamEntry"> | string
    userId?: StringFilter<"DreamEntry"> | string
    ciphertext?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    iv?: BytesNullableFilter<"DreamEntry"> | Bytes | null
    keyVersion?: IntFilter<"DreamEntry"> | number
    audioUrl?: StringNullableFilter<"DreamEntry"> | string | null
    title?: StringNullableFilter<"DreamEntry"> | string | null
    emotions?: StringNullableListFilter<"DreamEntry">
    vividness?: IntNullableFilter<"DreamEntry"> | number | null
    lucidity?: StringNullableFilter<"DreamEntry"> | string | null
    dreamTypes?: StringNullableListFilter<"DreamEntry">
    sleepQuality?: IntNullableFilter<"DreamEntry"> | number | null
    hoursSlept?: FloatNullableFilter<"DreamEntry"> | number | null
    wakeTime?: DateTimeNullableFilter<"DreamEntry"> | Date | string | null
    wakingLifeLink?: StringNullableFilter<"DreamEntry"> | string | null
    capturedAt?: DateTimeFilter<"DreamEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DreamEntry"> | Date | string
  }

  export type DreamerProfileUpsertWithoutUserInput = {
    update: XOR<DreamerProfileUpdateWithoutUserInput, DreamerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<DreamerProfileCreateWithoutUserInput, DreamerProfileUncheckedCreateWithoutUserInput>
    where?: DreamerProfileWhereInput
  }

  export type DreamerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: DreamerProfileWhereInput
    data: XOR<DreamerProfileUpdateWithoutUserInput, DreamerProfileUncheckedUpdateWithoutUserInput>
  }

  export type DreamerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boundaryScore?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityScore?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScore?: NullableIntFieldUpdateOperationsInput | number | null
    meaningScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementScore?: NullableIntFieldUpdateOperationsInput | number | null
    boundaryConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    lucidityConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    emotionConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    meaningConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    engagementConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    primaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryArchetype?: NullableStringFieldUpdateOperationsInput | string | null
    archetypeConfidence?: NullableIntFieldUpdateOperationsInput | number | null
    unlockPoints?: IntFieldUpdateOperationsInput | number
    unlockLevel?: IntFieldUpdateOperationsInput | number
    journalDreamCount?: IntFieldUpdateOperationsInput | number
    journalLucidPercent?: NullableIntFieldUpdateOperationsInput | number | null
    journalAvgVividness?: NullableIntFieldUpdateOperationsInput | number | null
    journalTopEmotions?: DreamerProfileUpdatejournalTopEmotionsInput | string[]
    journalTopTags?: DreamerProfileUpdatejournalTopTagsInput | string[]
    journalWakingLinkRate?: NullableIntFieldUpdateOperationsInput | number | null
    scoringVersion?: IntFieldUpdateOperationsInput | number
    isStale?: BoolFieldUpdateOperationsInput | boolean
    lastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringFilter<"Event"> | string
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    timestamp?: DateTimeFilter<"Event"> | Date | string
    sequence?: BigIntFilter<"Event"> | bigint | number
    aggregateId?: StringNullableFilter<"Event"> | string | null
    aggregateType?: StringNullableFilter<"Event"> | string | null
  }

  export type NightCheckInUpsertWithWhereUniqueWithoutUserInput = {
    where: NightCheckInWhereUniqueInput
    update: XOR<NightCheckInUpdateWithoutUserInput, NightCheckInUncheckedUpdateWithoutUserInput>
    create: XOR<NightCheckInCreateWithoutUserInput, NightCheckInUncheckedCreateWithoutUserInput>
  }

  export type NightCheckInUpdateWithWhereUniqueWithoutUserInput = {
    where: NightCheckInWhereUniqueInput
    data: XOR<NightCheckInUpdateWithoutUserInput, NightCheckInUncheckedUpdateWithoutUserInput>
  }

  export type NightCheckInUpdateManyWithWhereWithoutUserInput = {
    where: NightCheckInScalarWhereInput
    data: XOR<NightCheckInUpdateManyMutationInput, NightCheckInUncheckedUpdateManyWithoutUserInput>
  }

  export type NightCheckInScalarWhereInput = {
    AND?: NightCheckInScalarWhereInput | NightCheckInScalarWhereInput[]
    OR?: NightCheckInScalarWhereInput[]
    NOT?: NightCheckInScalarWhereInput | NightCheckInScalarWhereInput[]
    id?: StringFilter<"NightCheckIn"> | string
    userId?: StringFilter<"NightCheckIn"> | string
    date?: StringFilter<"NightCheckIn"> | string
    mood?: StringNullableFilter<"NightCheckIn"> | string | null
    dayNotes?: StringNullableFilter<"NightCheckIn"> | string | null
    intention?: StringNullableFilter<"NightCheckIn"> | string | null
    plannedWakeTime?: StringNullableFilter<"NightCheckIn"> | string | null
    reminderEnabled?: BoolFilter<"NightCheckIn"> | boolean
    createdAt?: DateTimeFilter<"NightCheckIn"> | Date | string
  }

  export type PromptResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: PromptResponseWhereUniqueInput
    update: XOR<PromptResponseUpdateWithoutUserInput, PromptResponseUncheckedUpdateWithoutUserInput>
    create: XOR<PromptResponseCreateWithoutUserInput, PromptResponseUncheckedCreateWithoutUserInput>
  }

  export type PromptResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: PromptResponseWhereUniqueInput
    data: XOR<PromptResponseUpdateWithoutUserInput, PromptResponseUncheckedUpdateWithoutUserInput>
  }

  export type PromptResponseUpdateManyWithWhereWithoutUserInput = {
    where: PromptResponseScalarWhereInput
    data: XOR<PromptResponseUpdateManyMutationInput, PromptResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type PromptResponseScalarWhereInput = {
    AND?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
    OR?: PromptResponseScalarWhereInput[]
    NOT?: PromptResponseScalarWhereInput | PromptResponseScalarWhereInput[]
    id?: StringFilter<"PromptResponse"> | string
    userId?: StringFilter<"PromptResponse"> | string
    promptId?: StringFilter<"PromptResponse"> | string
    value?: JsonFilter<"PromptResponse">
    shownAt?: DateTimeFilter<"PromptResponse"> | Date | string
    respondedAt?: DateTimeFilter<"PromptResponse"> | Date | string
    skipped?: BoolFilter<"PromptResponse"> | boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    tokenHash?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    deviceName?: StringNullableFilter<"Session"> | string | null
    lastActiveAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type StudyParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyParticipationWhereUniqueInput
    update: XOR<StudyParticipationUpdateWithoutUserInput, StudyParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<StudyParticipationCreateWithoutUserInput, StudyParticipationUncheckedCreateWithoutUserInput>
  }

  export type StudyParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyParticipationWhereUniqueInput
    data: XOR<StudyParticipationUpdateWithoutUserInput, StudyParticipationUncheckedUpdateWithoutUserInput>
  }

  export type StudyParticipationUpdateManyWithWhereWithoutUserInput = {
    where: StudyParticipationScalarWhereInput
    data: XOR<StudyParticipationUpdateManyMutationInput, StudyParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyParticipationScalarWhereInput = {
    AND?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
    OR?: StudyParticipationScalarWhereInput[]
    NOT?: StudyParticipationScalarWhereInput | StudyParticipationScalarWhereInput[]
    id?: StringFilter<"StudyParticipation"> | string
    userId?: StringFilter<"StudyParticipation"> | string
    studyId?: StringFilter<"StudyParticipation"> | string
    consentedAt?: DateTimeFilter<"StudyParticipation"> | Date | string
    consentVersion?: IntFilter<"StudyParticipation"> | number
    status?: StringFilter<"StudyParticipation"> | string
    withdrawnAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
    withdrawalReason?: StringNullableFilter<"StudyParticipation"> | string | null
    completedAt?: DateTimeNullableFilter<"StudyParticipation"> | Date | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDreamEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDreamEntriesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDreamEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDreamEntriesInput, UserUncheckedCreateWithoutDreamEntriesInput>
  }

  export type DreamTagCreateWithoutDreamEntryInput = {
    id?: string
    source?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutDreamTagsInput
  }

  export type DreamTagUncheckedCreateWithoutDreamEntryInput = {
    id?: string
    tagId: string
    source?: string
    createdAt?: Date | string
  }

  export type DreamTagCreateOrConnectWithoutDreamEntryInput = {
    where: DreamTagWhereUniqueInput
    create: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput>
  }

  export type DreamTagCreateManyDreamEntryInputEnvelope = {
    data: DreamTagCreateManyDreamEntryInput | DreamTagCreateManyDreamEntryInput[]
    skipDuplicates?: boolean
  }

  export type JournalFactCreateWithoutDreamEntryInput = {
    id?: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
  }

  export type JournalFactUncheckedCreateWithoutDreamEntryInput = {
    id?: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
  }

  export type JournalFactCreateOrConnectWithoutDreamEntryInput = {
    where: JournalFactWhereUniqueInput
    create: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput>
  }

  export type JournalFactCreateManyDreamEntryInputEnvelope = {
    data: JournalFactCreateManyDreamEntryInput | JournalFactCreateManyDreamEntryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDreamEntriesInput = {
    update: XOR<UserUpdateWithoutDreamEntriesInput, UserUncheckedUpdateWithoutDreamEntriesInput>
    create: XOR<UserCreateWithoutDreamEntriesInput, UserUncheckedCreateWithoutDreamEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDreamEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDreamEntriesInput, UserUncheckedUpdateWithoutDreamEntriesInput>
  }

  export type UserUpdateWithoutDreamEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDreamEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DreamTagUpsertWithWhereUniqueWithoutDreamEntryInput = {
    where: DreamTagWhereUniqueInput
    update: XOR<DreamTagUpdateWithoutDreamEntryInput, DreamTagUncheckedUpdateWithoutDreamEntryInput>
    create: XOR<DreamTagCreateWithoutDreamEntryInput, DreamTagUncheckedCreateWithoutDreamEntryInput>
  }

  export type DreamTagUpdateWithWhereUniqueWithoutDreamEntryInput = {
    where: DreamTagWhereUniqueInput
    data: XOR<DreamTagUpdateWithoutDreamEntryInput, DreamTagUncheckedUpdateWithoutDreamEntryInput>
  }

  export type DreamTagUpdateManyWithWhereWithoutDreamEntryInput = {
    where: DreamTagScalarWhereInput
    data: XOR<DreamTagUpdateManyMutationInput, DreamTagUncheckedUpdateManyWithoutDreamEntryInput>
  }

  export type DreamTagScalarWhereInput = {
    AND?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
    OR?: DreamTagScalarWhereInput[]
    NOT?: DreamTagScalarWhereInput | DreamTagScalarWhereInput[]
    id?: StringFilter<"DreamTag"> | string
    dreamEntryId?: StringFilter<"DreamTag"> | string
    tagId?: StringFilter<"DreamTag"> | string
    source?: StringFilter<"DreamTag"> | string
    createdAt?: DateTimeFilter<"DreamTag"> | Date | string
  }

  export type JournalFactUpsertWithWhereUniqueWithoutDreamEntryInput = {
    where: JournalFactWhereUniqueInput
    update: XOR<JournalFactUpdateWithoutDreamEntryInput, JournalFactUncheckedUpdateWithoutDreamEntryInput>
    create: XOR<JournalFactCreateWithoutDreamEntryInput, JournalFactUncheckedCreateWithoutDreamEntryInput>
  }

  export type JournalFactUpdateWithWhereUniqueWithoutDreamEntryInput = {
    where: JournalFactWhereUniqueInput
    data: XOR<JournalFactUpdateWithoutDreamEntryInput, JournalFactUncheckedUpdateWithoutDreamEntryInput>
  }

  export type JournalFactUpdateManyWithWhereWithoutDreamEntryInput = {
    where: JournalFactScalarWhereInput
    data: XOR<JournalFactUpdateManyMutationInput, JournalFactUncheckedUpdateManyWithoutDreamEntryInput>
  }

  export type JournalFactScalarWhereInput = {
    AND?: JournalFactScalarWhereInput | JournalFactScalarWhereInput[]
    OR?: JournalFactScalarWhereInput[]
    NOT?: JournalFactScalarWhereInput | JournalFactScalarWhereInput[]
    id?: StringFilter<"JournalFact"> | string
    dreamEntryId?: StringFilter<"JournalFact"> | string
    factType?: StringFilter<"JournalFact"> | string
    value?: JsonFilter<"JournalFact">
    confidence?: FloatFilter<"JournalFact"> | number
    ontologyVersion?: IntFilter<"JournalFact"> | number
    modelVersion?: StringFilter<"JournalFact"> | string
    promptVersion?: IntFilter<"JournalFact"> | number
    startIndex?: IntNullableFilter<"JournalFact"> | number | null
    endIndex?: IntNullableFilter<"JournalFact"> | number | null
    extractedAt?: DateTimeFilter<"JournalFact"> | Date | string
  }

  export type DreamEntryCreateWithoutFactsInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDreamEntriesInput
    tags?: DreamTagCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryUncheckedCreateWithoutFactsInput = {
    id?: string
    userId: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    tags?: DreamTagUncheckedCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryCreateOrConnectWithoutFactsInput = {
    where: DreamEntryWhereUniqueInput
    create: XOR<DreamEntryCreateWithoutFactsInput, DreamEntryUncheckedCreateWithoutFactsInput>
  }

  export type DreamEntryUpsertWithoutFactsInput = {
    update: XOR<DreamEntryUpdateWithoutFactsInput, DreamEntryUncheckedUpdateWithoutFactsInput>
    create: XOR<DreamEntryCreateWithoutFactsInput, DreamEntryUncheckedCreateWithoutFactsInput>
    where?: DreamEntryWhereInput
  }

  export type DreamEntryUpdateToOneWithWhereWithoutFactsInput = {
    where?: DreamEntryWhereInput
    data: XOR<DreamEntryUpdateWithoutFactsInput, DreamEntryUncheckedUpdateWithoutFactsInput>
  }

  export type DreamEntryUpdateWithoutFactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDreamEntriesNestedInput
    tags?: DreamTagUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryUncheckedUpdateWithoutFactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DreamTagUncheckedUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamTagCreateWithoutTagInput = {
    id?: string
    source?: string
    createdAt?: Date | string
    dreamEntry: DreamEntryCreateNestedOneWithoutTagsInput
  }

  export type DreamTagUncheckedCreateWithoutTagInput = {
    id?: string
    dreamEntryId: string
    source?: string
    createdAt?: Date | string
  }

  export type DreamTagCreateOrConnectWithoutTagInput = {
    where: DreamTagWhereUniqueInput
    create: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput>
  }

  export type DreamTagCreateManyTagInputEnvelope = {
    data: DreamTagCreateManyTagInput | DreamTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type DreamTagUpsertWithWhereUniqueWithoutTagInput = {
    where: DreamTagWhereUniqueInput
    update: XOR<DreamTagUpdateWithoutTagInput, DreamTagUncheckedUpdateWithoutTagInput>
    create: XOR<DreamTagCreateWithoutTagInput, DreamTagUncheckedCreateWithoutTagInput>
  }

  export type DreamTagUpdateWithWhereUniqueWithoutTagInput = {
    where: DreamTagWhereUniqueInput
    data: XOR<DreamTagUpdateWithoutTagInput, DreamTagUncheckedUpdateWithoutTagInput>
  }

  export type DreamTagUpdateManyWithWhereWithoutTagInput = {
    where: DreamTagScalarWhereInput
    data: XOR<DreamTagUpdateManyMutationInput, DreamTagUncheckedUpdateManyWithoutTagInput>
  }

  export type DreamEntryCreateWithoutTagsInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDreamEntriesInput
    facts?: JournalFactCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
    facts?: JournalFactUncheckedCreateNestedManyWithoutDreamEntryInput
  }

  export type DreamEntryCreateOrConnectWithoutTagsInput = {
    where: DreamEntryWhereUniqueInput
    create: XOR<DreamEntryCreateWithoutTagsInput, DreamEntryUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutDreamTagsInput = {
    id?: string
    name: string
    slug: string
    category: string
    taxonomyId?: string | null
    taxonomyVersion?: number | null
    usageCount?: number
  }

  export type TagUncheckedCreateWithoutDreamTagsInput = {
    id?: string
    name: string
    slug: string
    category: string
    taxonomyId?: string | null
    taxonomyVersion?: number | null
    usageCount?: number
  }

  export type TagCreateOrConnectWithoutDreamTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutDreamTagsInput, TagUncheckedCreateWithoutDreamTagsInput>
  }

  export type DreamEntryUpsertWithoutTagsInput = {
    update: XOR<DreamEntryUpdateWithoutTagsInput, DreamEntryUncheckedUpdateWithoutTagsInput>
    create: XOR<DreamEntryCreateWithoutTagsInput, DreamEntryUncheckedCreateWithoutTagsInput>
    where?: DreamEntryWhereInput
  }

  export type DreamEntryUpdateToOneWithWhereWithoutTagsInput = {
    where?: DreamEntryWhereInput
    data: XOR<DreamEntryUpdateWithoutTagsInput, DreamEntryUncheckedUpdateWithoutTagsInput>
  }

  export type DreamEntryUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDreamEntriesNestedInput
    facts?: JournalFactUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facts?: JournalFactUncheckedUpdateManyWithoutDreamEntryNestedInput
  }

  export type TagUpsertWithoutDreamTagsInput = {
    update: XOR<TagUpdateWithoutDreamTagsInput, TagUncheckedUpdateWithoutDreamTagsInput>
    create: XOR<TagCreateWithoutDreamTagsInput, TagUncheckedCreateWithoutDreamTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutDreamTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutDreamTagsInput, TagUncheckedUpdateWithoutDreamTagsInput>
  }

  export type TagUpdateWithoutDreamTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type TagUncheckedUpdateWithoutDreamTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    taxonomyId?: NullableStringFieldUpdateOperationsInput | string | null
    taxonomyVersion?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type CensusSectionCreateWithoutInstrumentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
    questions?: CensusQuestionCreateNestedManyWithoutSectionInput
  }

  export type CensusSectionUncheckedCreateWithoutInstrumentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
    questions?: CensusQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type CensusSectionCreateOrConnectWithoutInstrumentInput = {
    where: CensusSectionWhereUniqueInput
    create: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput>
  }

  export type CensusSectionCreateManyInstrumentInputEnvelope = {
    data: CensusSectionCreateManyInstrumentInput | CensusSectionCreateManyInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type CensusSectionUpsertWithWhereUniqueWithoutInstrumentInput = {
    where: CensusSectionWhereUniqueInput
    update: XOR<CensusSectionUpdateWithoutInstrumentInput, CensusSectionUncheckedUpdateWithoutInstrumentInput>
    create: XOR<CensusSectionCreateWithoutInstrumentInput, CensusSectionUncheckedCreateWithoutInstrumentInput>
  }

  export type CensusSectionUpdateWithWhereUniqueWithoutInstrumentInput = {
    where: CensusSectionWhereUniqueInput
    data: XOR<CensusSectionUpdateWithoutInstrumentInput, CensusSectionUncheckedUpdateWithoutInstrumentInput>
  }

  export type CensusSectionUpdateManyWithWhereWithoutInstrumentInput = {
    where: CensusSectionScalarWhereInput
    data: XOR<CensusSectionUpdateManyMutationInput, CensusSectionUncheckedUpdateManyWithoutInstrumentInput>
  }

  export type CensusSectionScalarWhereInput = {
    AND?: CensusSectionScalarWhereInput | CensusSectionScalarWhereInput[]
    OR?: CensusSectionScalarWhereInput[]
    NOT?: CensusSectionScalarWhereInput | CensusSectionScalarWhereInput[]
    id?: StringFilter<"CensusSection"> | string
    instrumentId?: StringFilter<"CensusSection"> | string
    slug?: StringFilter<"CensusSection"> | string
    name?: StringFilter<"CensusSection"> | string
    description?: StringNullableFilter<"CensusSection"> | string | null
    icon?: StringNullableFilter<"CensusSection"> | string | null
    sortOrder?: IntFilter<"CensusSection"> | number
    estimatedTime?: IntFilter<"CensusSection"> | number
  }

  export type CensusQuestionCreateWithoutSectionInput = {
    id?: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerCreateNestedManyWithoutQuestionInput
  }

  export type CensusQuestionUncheckedCreateWithoutSectionInput = {
    id?: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type CensusQuestionCreateOrConnectWithoutSectionInput = {
    where: CensusQuestionWhereUniqueInput
    create: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput>
  }

  export type CensusQuestionCreateManySectionInputEnvelope = {
    data: CensusQuestionCreateManySectionInput | CensusQuestionCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type CensusInstrumentCreateWithoutSectionsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusInstrumentUncheckedCreateWithoutSectionsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    isRequired?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusInstrumentCreateOrConnectWithoutSectionsInput = {
    where: CensusInstrumentWhereUniqueInput
    create: XOR<CensusInstrumentCreateWithoutSectionsInput, CensusInstrumentUncheckedCreateWithoutSectionsInput>
  }

  export type CensusQuestionUpsertWithWhereUniqueWithoutSectionInput = {
    where: CensusQuestionWhereUniqueInput
    update: XOR<CensusQuestionUpdateWithoutSectionInput, CensusQuestionUncheckedUpdateWithoutSectionInput>
    create: XOR<CensusQuestionCreateWithoutSectionInput, CensusQuestionUncheckedCreateWithoutSectionInput>
  }

  export type CensusQuestionUpdateWithWhereUniqueWithoutSectionInput = {
    where: CensusQuestionWhereUniqueInput
    data: XOR<CensusQuestionUpdateWithoutSectionInput, CensusQuestionUncheckedUpdateWithoutSectionInput>
  }

  export type CensusQuestionUpdateManyWithWhereWithoutSectionInput = {
    where: CensusQuestionScalarWhereInput
    data: XOR<CensusQuestionUpdateManyMutationInput, CensusQuestionUncheckedUpdateManyWithoutSectionInput>
  }

  export type CensusQuestionScalarWhereInput = {
    AND?: CensusQuestionScalarWhereInput | CensusQuestionScalarWhereInput[]
    OR?: CensusQuestionScalarWhereInput[]
    NOT?: CensusQuestionScalarWhereInput | CensusQuestionScalarWhereInput[]
    id?: StringFilter<"CensusQuestion"> | string
    sectionId?: StringFilter<"CensusQuestion"> | string
    slug?: StringFilter<"CensusQuestion"> | string
    text?: StringFilter<"CensusQuestion"> | string
    helpText?: StringNullableFilter<"CensusQuestion"> | string | null
    type?: StringFilter<"CensusQuestion"> | string
    props?: JsonFilter<"CensusQuestion">
    isRequired?: BoolFilter<"CensusQuestion"> | boolean
    validation?: JsonNullableFilter<"CensusQuestion">
    sortOrder?: IntFilter<"CensusQuestion"> | number
    irtParams?: JsonNullableFilter<"CensusQuestion">
    groupId?: StringNullableFilter<"CensusQuestion"> | string | null
    groupLabel?: StringNullableFilter<"CensusQuestion"> | string | null
    showWhen?: JsonNullableFilter<"CensusQuestion">
  }

  export type CensusInstrumentUpsertWithoutSectionsInput = {
    update: XOR<CensusInstrumentUpdateWithoutSectionsInput, CensusInstrumentUncheckedUpdateWithoutSectionsInput>
    create: XOR<CensusInstrumentCreateWithoutSectionsInput, CensusInstrumentUncheckedCreateWithoutSectionsInput>
    where?: CensusInstrumentWhereInput
  }

  export type CensusInstrumentUpdateToOneWithWhereWithoutSectionsInput = {
    where?: CensusInstrumentWhereInput
    data: XOR<CensusInstrumentUpdateWithoutSectionsInput, CensusInstrumentUncheckedUpdateWithoutSectionsInput>
  }

  export type CensusInstrumentUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusInstrumentUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerCreateWithoutQuestionInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCensusAnswersInput
  }

  export type CensusAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusAnswerCreateOrConnectWithoutQuestionInput = {
    where: CensusAnswerWhereUniqueInput
    create: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type CensusAnswerCreateManyQuestionInputEnvelope = {
    data: CensusAnswerCreateManyQuestionInput | CensusAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type CensusSectionCreateWithoutQuestionsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
    instrument: CensusInstrumentCreateNestedOneWithoutSectionsInput
  }

  export type CensusSectionUncheckedCreateWithoutQuestionsInput = {
    id?: string
    instrumentId: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
  }

  export type CensusSectionCreateOrConnectWithoutQuestionsInput = {
    where: CensusSectionWhereUniqueInput
    create: XOR<CensusSectionCreateWithoutQuestionsInput, CensusSectionUncheckedCreateWithoutQuestionsInput>
  }

  export type CensusAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: CensusAnswerWhereUniqueInput
    update: XOR<CensusAnswerUpdateWithoutQuestionInput, CensusAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<CensusAnswerCreateWithoutQuestionInput, CensusAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type CensusAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: CensusAnswerWhereUniqueInput
    data: XOR<CensusAnswerUpdateWithoutQuestionInput, CensusAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type CensusAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: CensusAnswerScalarWhereInput
    data: XOR<CensusAnswerUpdateManyMutationInput, CensusAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type CensusSectionUpsertWithoutQuestionsInput = {
    update: XOR<CensusSectionUpdateWithoutQuestionsInput, CensusSectionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<CensusSectionCreateWithoutQuestionsInput, CensusSectionUncheckedCreateWithoutQuestionsInput>
    where?: CensusSectionWhereInput
  }

  export type CensusSectionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: CensusSectionWhereInput
    data: XOR<CensusSectionUpdateWithoutQuestionsInput, CensusSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type CensusSectionUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    instrument?: CensusInstrumentUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type CensusSectionUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type CensusQuestionCreateWithoutAnswersInput = {
    id?: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    section: CensusSectionCreateNestedOneWithoutQuestionsInput
  }

  export type CensusQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    sectionId: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusQuestionCreateOrConnectWithoutAnswersInput = {
    where: CensusQuestionWhereUniqueInput
    create: XOR<CensusQuestionCreateWithoutAnswersInput, CensusQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type UserCreateWithoutCensusAnswersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCensusAnswersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCensusAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCensusAnswersInput, UserUncheckedCreateWithoutCensusAnswersInput>
  }

  export type CensusQuestionUpsertWithoutAnswersInput = {
    update: XOR<CensusQuestionUpdateWithoutAnswersInput, CensusQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<CensusQuestionCreateWithoutAnswersInput, CensusQuestionUncheckedCreateWithoutAnswersInput>
    where?: CensusQuestionWhereInput
  }

  export type CensusQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: CensusQuestionWhereInput
    data: XOR<CensusQuestionUpdateWithoutAnswersInput, CensusQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type CensusQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    section?: CensusSectionUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type CensusQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutCensusAnswersInput = {
    update: XOR<UserUpdateWithoutCensusAnswersInput, UserUncheckedUpdateWithoutCensusAnswersInput>
    create: XOR<UserCreateWithoutCensusAnswersInput, UserUncheckedCreateWithoutCensusAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCensusAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCensusAnswersInput, UserUncheckedUpdateWithoutCensusAnswersInput>
  }

  export type UserUpdateWithoutCensusAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCensusAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudyCreateWithoutPromptsInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: StudyParticipationCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutPromptsInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: StudyParticipationUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutPromptsInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutPromptsInput, StudyUncheckedCreateWithoutPromptsInput>
  }

  export type PromptResponseCreateWithoutPromptInput = {
    id?: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
    user: UserCreateNestedOneWithoutPromptResponsesInput
  }

  export type PromptResponseUncheckedCreateWithoutPromptInput = {
    id?: string
    userId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type PromptResponseCreateOrConnectWithoutPromptInput = {
    where: PromptResponseWhereUniqueInput
    create: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput>
  }

  export type PromptResponseCreateManyPromptInputEnvelope = {
    data: PromptResponseCreateManyPromptInput | PromptResponseCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type StudyUpsertWithoutPromptsInput = {
    update: XOR<StudyUpdateWithoutPromptsInput, StudyUncheckedUpdateWithoutPromptsInput>
    create: XOR<StudyCreateWithoutPromptsInput, StudyUncheckedCreateWithoutPromptsInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutPromptsInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutPromptsInput, StudyUncheckedUpdateWithoutPromptsInput>
  }

  export type StudyUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: StudyParticipationUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: StudyParticipationUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type PromptResponseUpsertWithWhereUniqueWithoutPromptInput = {
    where: PromptResponseWhereUniqueInput
    update: XOR<PromptResponseUpdateWithoutPromptInput, PromptResponseUncheckedUpdateWithoutPromptInput>
    create: XOR<PromptResponseCreateWithoutPromptInput, PromptResponseUncheckedCreateWithoutPromptInput>
  }

  export type PromptResponseUpdateWithWhereUniqueWithoutPromptInput = {
    where: PromptResponseWhereUniqueInput
    data: XOR<PromptResponseUpdateWithoutPromptInput, PromptResponseUncheckedUpdateWithoutPromptInput>
  }

  export type PromptResponseUpdateManyWithWhereWithoutPromptInput = {
    where: PromptResponseScalarWhereInput
    data: XOR<PromptResponseUpdateManyMutationInput, PromptResponseUncheckedUpdateManyWithoutPromptInput>
  }

  export type PromptCreateWithoutResponsesInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    study?: StudyCreateNestedOneWithoutPromptsInput
  }

  export type PromptUncheckedCreateWithoutResponsesInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCreateOrConnectWithoutResponsesInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutResponsesInput, PromptUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutPromptResponsesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPromptResponsesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPromptResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPromptResponsesInput, UserUncheckedCreateWithoutPromptResponsesInput>
  }

  export type PromptUpsertWithoutResponsesInput = {
    update: XOR<PromptUpdateWithoutResponsesInput, PromptUncheckedUpdateWithoutResponsesInput>
    create: XOR<PromptCreateWithoutResponsesInput, PromptUncheckedCreateWithoutResponsesInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutResponsesInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutResponsesInput, PromptUncheckedUpdateWithoutResponsesInput>
  }

  export type PromptUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneWithoutPromptsNestedInput
  }

  export type PromptUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPromptResponsesInput = {
    update: XOR<UserUpdateWithoutPromptResponsesInput, UserUncheckedUpdateWithoutPromptResponsesInput>
    create: XOR<UserCreateWithoutPromptResponsesInput, UserUncheckedCreateWithoutPromptResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPromptResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPromptResponsesInput, UserUncheckedUpdateWithoutPromptResponsesInput>
  }

  export type UserUpdateWithoutPromptResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPromptResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConsentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
  }

  export type UserUpsertWithoutConsentsInput = {
    update: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PromptCreateWithoutStudyInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PromptResponseCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutStudyInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PromptResponseUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutStudyInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput>
  }

  export type PromptCreateManyStudyInputEnvelope = {
    data: PromptCreateManyStudyInput | PromptCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type StudyParticipationCreateWithoutStudyInput = {
    id?: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutStudyParticipationsInput
  }

  export type StudyParticipationUncheckedCreateWithoutStudyInput = {
    id?: string
    userId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type StudyParticipationCreateOrConnectWithoutStudyInput = {
    where: StudyParticipationWhereUniqueInput
    create: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput>
  }

  export type StudyParticipationCreateManyStudyInputEnvelope = {
    data: StudyParticipationCreateManyStudyInput | StudyParticipationCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type PromptUpsertWithWhereUniqueWithoutStudyInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutStudyInput, PromptUncheckedUpdateWithoutStudyInput>
    create: XOR<PromptCreateWithoutStudyInput, PromptUncheckedCreateWithoutStudyInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutStudyInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutStudyInput, PromptUncheckedUpdateWithoutStudyInput>
  }

  export type PromptUpdateManyWithWhereWithoutStudyInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutStudyInput>
  }

  export type PromptScalarWhereInput = {
    AND?: PromptScalarWhereInput | PromptScalarWhereInput[]
    OR?: PromptScalarWhereInput[]
    NOT?: PromptScalarWhereInput | PromptScalarWhereInput[]
    id?: StringFilter<"Prompt"> | string
    text?: StringFilter<"Prompt"> | string
    type?: StringFilter<"Prompt"> | string
    responseType?: StringFilter<"Prompt"> | string
    responseProps?: JsonNullableFilter<"Prompt">
    isActive?: BoolFilter<"Prompt"> | boolean
    frequency?: StringNullableFilter<"Prompt"> | string | null
    targetingRules?: JsonNullableFilter<"Prompt">
    studyId?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
  }

  export type StudyParticipationUpsertWithWhereUniqueWithoutStudyInput = {
    where: StudyParticipationWhereUniqueInput
    update: XOR<StudyParticipationUpdateWithoutStudyInput, StudyParticipationUncheckedUpdateWithoutStudyInput>
    create: XOR<StudyParticipationCreateWithoutStudyInput, StudyParticipationUncheckedCreateWithoutStudyInput>
  }

  export type StudyParticipationUpdateWithWhereUniqueWithoutStudyInput = {
    where: StudyParticipationWhereUniqueInput
    data: XOR<StudyParticipationUpdateWithoutStudyInput, StudyParticipationUncheckedUpdateWithoutStudyInput>
  }

  export type StudyParticipationUpdateManyWithWhereWithoutStudyInput = {
    where: StudyParticipationScalarWhereInput
    data: XOR<StudyParticipationUpdateManyMutationInput, StudyParticipationUncheckedUpdateManyWithoutStudyInput>
  }

  export type StudyCreateWithoutParticipationsInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompts?: PromptCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutParticipationsInput = {
    id?: string
    slug: string
    title: string
    description: string
    institution?: string | null
    dataScope: JsonNullValueInput | InputJsonValue
    duration?: string | null
    consentText: string
    consentVersion?: number
    status?: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompts?: PromptUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutParticipationsInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutParticipationsInput, StudyUncheckedCreateWithoutParticipationsInput>
  }

  export type UserCreateWithoutStudyParticipationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudyParticipationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudyParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudyParticipationsInput, UserUncheckedCreateWithoutStudyParticipationsInput>
  }

  export type StudyUpsertWithoutParticipationsInput = {
    update: XOR<StudyUpdateWithoutParticipationsInput, StudyUncheckedUpdateWithoutParticipationsInput>
    create: XOR<StudyCreateWithoutParticipationsInput, StudyUncheckedCreateWithoutParticipationsInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutParticipationsInput, StudyUncheckedUpdateWithoutParticipationsInput>
  }

  export type StudyUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: PromptUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    dataScope?: JsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    consentText?: StringFieldUpdateOperationsInput | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: PromptUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type UserUpsertWithoutStudyParticipationsInput = {
    update: XOR<UserUpdateWithoutStudyParticipationsInput, UserUncheckedUpdateWithoutStudyParticipationsInput>
    create: XOR<UserCreateWithoutStudyParticipationsInput, UserUncheckedCreateWithoutStudyParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudyParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudyParticipationsInput, UserUncheckedUpdateWithoutStudyParticipationsInput>
  }

  export type UserUpdateWithoutStudyParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudyParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmotionCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    parent?: EmotionCreateNestedOneWithoutChildrenInput
  }

  export type EmotionUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    parentId?: string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type EmotionCreateOrConnectWithoutChildrenInput = {
    where: EmotionWhereUniqueInput
    create: XOR<EmotionCreateWithoutChildrenInput, EmotionUncheckedCreateWithoutChildrenInput>
  }

  export type EmotionCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    children?: EmotionCreateNestedManyWithoutParentInput
  }

  export type EmotionUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    children?: EmotionUncheckedCreateNestedManyWithoutParentInput
  }

  export type EmotionCreateOrConnectWithoutParentInput = {
    where: EmotionWhereUniqueInput
    create: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput>
  }

  export type EmotionCreateManyParentInputEnvelope = {
    data: EmotionCreateManyParentInput | EmotionCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type EmotionUpsertWithoutChildrenInput = {
    update: XOR<EmotionUpdateWithoutChildrenInput, EmotionUncheckedUpdateWithoutChildrenInput>
    create: XOR<EmotionCreateWithoutChildrenInput, EmotionUncheckedCreateWithoutChildrenInput>
    where?: EmotionWhereInput
  }

  export type EmotionUpdateToOneWithWhereWithoutChildrenInput = {
    where?: EmotionWhereInput
    data: XOR<EmotionUpdateWithoutChildrenInput, EmotionUncheckedUpdateWithoutChildrenInput>
  }

  export type EmotionUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    parent?: EmotionUpdateOneWithoutChildrenNestedInput
  }

  export type EmotionUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type EmotionUpsertWithWhereUniqueWithoutParentInput = {
    where: EmotionWhereUniqueInput
    update: XOR<EmotionUpdateWithoutParentInput, EmotionUncheckedUpdateWithoutParentInput>
    create: XOR<EmotionCreateWithoutParentInput, EmotionUncheckedCreateWithoutParentInput>
  }

  export type EmotionUpdateWithWhereUniqueWithoutParentInput = {
    where: EmotionWhereUniqueInput
    data: XOR<EmotionUpdateWithoutParentInput, EmotionUncheckedUpdateWithoutParentInput>
  }

  export type EmotionUpdateManyWithWhereWithoutParentInput = {
    where: EmotionScalarWhereInput
    data: XOR<EmotionUpdateManyMutationInput, EmotionUncheckedUpdateManyWithoutParentInput>
  }

  export type EmotionScalarWhereInput = {
    AND?: EmotionScalarWhereInput | EmotionScalarWhereInput[]
    OR?: EmotionScalarWhereInput[]
    NOT?: EmotionScalarWhereInput | EmotionScalarWhereInput[]
    id?: StringFilter<"Emotion"> | string
    name?: StringFilter<"Emotion"> | string
    slug?: StringFilter<"Emotion"> | string
    valence?: FloatFilter<"Emotion"> | number
    arousal?: FloatFilter<"Emotion"> | number
    parentId?: StringNullableFilter<"Emotion"> | string | null
    translations?: JsonNullableFilter<"Emotion">
    version?: IntFilter<"Emotion"> | number
  }

  export type UserCreateWithoutNightCheckInsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNightCheckInsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNightCheckInsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNightCheckInsInput, UserUncheckedCreateWithoutNightCheckInsInput>
  }

  export type UserUpsertWithoutNightCheckInsInput = {
    update: XOR<UserUpdateWithoutNightCheckInsInput, UserUncheckedUpdateWithoutNightCheckInsInput>
    create: XOR<UserCreateWithoutNightCheckInsInput, UserUncheckedCreateWithoutNightCheckInsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNightCheckInsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNightCheckInsInput, UserUncheckedUpdateWithoutNightCheckInsInput>
  }

  export type UserUpdateWithoutNightCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNightCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAlarmSettingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileCreateNestedOneWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlarmSettingsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    dreamerProfile?: DreamerProfileUncheckedCreateNestedOneWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlarmSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlarmSettingsInput, UserUncheckedCreateWithoutAlarmSettingsInput>
  }

  export type UserUpsertWithoutAlarmSettingsInput = {
    update: XOR<UserUpdateWithoutAlarmSettingsInput, UserUncheckedUpdateWithoutAlarmSettingsInput>
    create: XOR<UserCreateWithoutAlarmSettingsInput, UserUncheckedCreateWithoutAlarmSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlarmSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlarmSettingsInput, UserUncheckedUpdateWithoutAlarmSettingsInput>
  }

  export type UserUpdateWithoutAlarmSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUpdateOneWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlarmSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    dreamerProfile?: DreamerProfileUncheckedUpdateOneWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDreamerProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerCreateNestedManyWithoutUserInput
    consents?: ConsentCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDreamerProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    avatarEmoji?: string
    avatarBgColor?: string
    email?: string | null
    emailVerifiedAt?: Date | string | null
    timezone?: string
    locale?: string
    encryptionKeyVersion?: number
    keyRecoveryMethod?: string | null
    keySalt?: Bytes | null
    alarmSettings?: AlarmSettingsUncheckedCreateNestedOneWithoutUserInput
    censusAnswers?: CensusAnswerUncheckedCreateNestedManyWithoutUserInput
    consents?: ConsentUncheckedCreateNestedManyWithoutUserInput
    dreamEntries?: DreamEntryUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUserInput
    nightCheckIns?: NightCheckInUncheckedCreateNestedManyWithoutUserInput
    promptResponses?: PromptResponseUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    studyParticipations?: StudyParticipationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDreamerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDreamerProfileInput, UserUncheckedCreateWithoutDreamerProfileInput>
  }

  export type UserUpsertWithoutDreamerProfileInput = {
    update: XOR<UserUpdateWithoutDreamerProfileInput, UserUncheckedUpdateWithoutDreamerProfileInput>
    create: XOR<UserCreateWithoutDreamerProfileInput, UserUncheckedCreateWithoutDreamerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDreamerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDreamerProfileInput, UserUncheckedUpdateWithoutDreamerProfileInput>
  }

  export type UserUpdateWithoutDreamerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUpdateManyWithoutUserNestedInput
    consents?: ConsentUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDreamerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarEmoji?: StringFieldUpdateOperationsInput | string
    avatarBgColor?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    encryptionKeyVersion?: IntFieldUpdateOperationsInput | number
    keyRecoveryMethod?: NullableStringFieldUpdateOperationsInput | string | null
    keySalt?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    alarmSettings?: AlarmSettingsUncheckedUpdateOneWithoutUserNestedInput
    censusAnswers?: CensusAnswerUncheckedUpdateManyWithoutUserNestedInput
    consents?: ConsentUncheckedUpdateManyWithoutUserNestedInput
    dreamEntries?: DreamEntryUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUserNestedInput
    nightCheckIns?: NightCheckInUncheckedUpdateManyWithoutUserNestedInput
    promptResponses?: PromptResponseUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    studyParticipations?: StudyParticipationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CensusAnswerCreateManyUserInput = {
    id?: string
    questionId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsentCreateManyUserInput = {
    id?: string
    scope: string
    version: number
    granted: boolean
    timestamp?: Date | string
    receiptHash: string
    policyHash: string
    jurisdiction?: string | null
    ipHash?: string | null
  }

  export type DreamEntryCreateManyUserInput = {
    id?: string
    ciphertext?: Bytes | null
    iv?: Bytes | null
    keyVersion?: number
    audioUrl?: string | null
    title?: string | null
    emotions?: DreamEntryCreateemotionsInput | string[]
    vividness?: number | null
    lucidity?: string | null
    dreamTypes?: DreamEntryCreatedreamTypesInput | string[]
    sleepQuality?: number | null
    hoursSlept?: number | null
    wakeTime?: Date | string | null
    wakingLifeLink?: string | null
    capturedAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyUserInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sequence?: bigint | number
    aggregateId?: string | null
    aggregateType?: string | null
  }

  export type NightCheckInCreateManyUserInput = {
    id?: string
    date: string
    mood?: string | null
    dayNotes?: string | null
    intention?: string | null
    plannedWakeTime?: string | null
    reminderEnabled?: boolean
    createdAt?: Date | string
  }

  export type PromptResponseCreateManyUserInput = {
    id?: string
    promptId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type SessionCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    deviceId?: string | null
    deviceName?: string | null
    lastActiveAt?: Date | string
    createdAt?: Date | string
  }

  export type StudyParticipationCreateManyUserInput = {
    id?: string
    studyId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type CensusAnswerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: CensusQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type CensusAnswerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    granted?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptHash?: StringFieldUpdateOperationsInput | string
    policyHash?: StringFieldUpdateOperationsInput | string
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DreamEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DreamTagUpdateManyWithoutDreamEntryNestedInput
    facts?: JournalFactUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DreamTagUncheckedUpdateManyWithoutDreamEntryNestedInput
    facts?: JournalFactUncheckedUpdateManyWithoutDreamEntryNestedInput
  }

  export type DreamEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ciphertext?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    iv?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    emotions?: DreamEntryUpdateemotionsInput | string[]
    vividness?: NullableIntFieldUpdateOperationsInput | number | null
    lucidity?: NullableStringFieldUpdateOperationsInput | string | null
    dreamTypes?: DreamEntryUpdatedreamTypesInput | string[]
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    hoursSlept?: NullableFloatFieldUpdateOperationsInput | number | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakingLifeLink?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sequence?: BigIntFieldUpdateOperationsInput | bigint | number
    aggregateId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NightCheckInUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NightCheckInUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NightCheckInUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    dayNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intention?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWakeTime?: NullableStringFieldUpdateOperationsInput | string | null
    reminderEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
    prompt?: PromptUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type PromptResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    study?: StudyUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type StudyParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudyParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DreamTagCreateManyDreamEntryInput = {
    id?: string
    tagId: string
    source?: string
    createdAt?: Date | string
  }

  export type JournalFactCreateManyDreamEntryInput = {
    id?: string
    factType: string
    value: JsonNullValueInput | InputJsonValue
    confidence?: number
    ontologyVersion: number
    modelVersion: string
    promptVersion: number
    startIndex?: number | null
    endIndex?: number | null
    extractedAt?: Date | string
  }

  export type DreamTagUpdateWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutDreamTagsNestedInput
  }

  export type DreamTagUncheckedUpdateWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamTagUncheckedUpdateManyWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactUpdateWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactUncheckedUpdateWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFactUncheckedUpdateManyWithoutDreamEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    factType?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    ontologyVersion?: IntFieldUpdateOperationsInput | number
    modelVersion?: StringFieldUpdateOperationsInput | string
    promptVersion?: IntFieldUpdateOperationsInput | number
    startIndex?: NullableIntFieldUpdateOperationsInput | number | null
    endIndex?: NullableIntFieldUpdateOperationsInput | number | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamTagCreateManyTagInput = {
    id?: string
    dreamEntryId: string
    source?: string
    createdAt?: Date | string
  }

  export type DreamTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dreamEntry?: DreamEntryUpdateOneRequiredWithoutTagsNestedInput
  }

  export type DreamTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DreamTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    dreamEntryId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusSectionCreateManyInstrumentInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    estimatedTime?: number
  }

  export type CensusSectionUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    questions?: CensusQuestionUpdateManyWithoutSectionNestedInput
  }

  export type CensusSectionUncheckedUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    questions?: CensusQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type CensusSectionUncheckedUpdateManyWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type CensusQuestionCreateManySectionInput = {
    id?: string
    slug: string
    text: string
    helpText?: string | null
    type: string
    props: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: string | null
    groupLabel?: string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusQuestionUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type CensusQuestionUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
    answers?: CensusAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type CensusQuestionUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    props?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    validation?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    irtParams?: NullableJsonNullValueInput | InputJsonValue
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    groupLabel?: NullableStringFieldUpdateOperationsInput | string | null
    showWhen?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CensusAnswerCreateManyQuestionInput = {
    id?: string
    userId: string
    value: JsonNullValueInput | InputJsonValue
    instrumentVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CensusAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCensusAnswersNestedInput
  }

  export type CensusAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    instrumentVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptResponseCreateManyPromptInput = {
    id?: string
    userId: string
    value: JsonNullValueInput | InputJsonValue
    shownAt: Date | string
    respondedAt?: Date | string
    skipped?: boolean
  }

  export type PromptResponseUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPromptResponsesNestedInput
  }

  export type PromptResponseUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptResponseUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skipped?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptCreateManyStudyInput = {
    id?: string
    text: string
    type: string
    responseType: string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    frequency?: string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyParticipationCreateManyStudyInput = {
    id?: string
    userId: string
    consentedAt?: Date | string
    consentVersion: number
    status?: string
    withdrawnAt?: Date | string | null
    withdrawalReason?: string | null
    completedAt?: Date | string | null
  }

  export type PromptUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PromptResponseUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PromptResponseUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    responseType?: StringFieldUpdateOperationsInput | string
    responseProps?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    targetingRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyParticipationUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutStudyParticipationsNestedInput
  }

  export type StudyParticipationUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudyParticipationUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consentVersion?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawalReason?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmotionCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    valence: number
    arousal: number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type EmotionUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    children?: EmotionUpdateManyWithoutParentNestedInput
  }

  export type EmotionUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    children?: EmotionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EmotionUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    valence?: FloatFieldUpdateOperationsInput | number
    arousal?: FloatFieldUpdateOperationsInput | number
    translations?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}